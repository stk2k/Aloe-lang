<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Spec (Draft, English)</title>
  <meta name="edit-version" content="33">
  <meta name="edit-date" content="2025-12-18T23:30:08+09:00">
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout { display: flex; min-height: 100vh; }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 { font-size: 1.1rem; margin: 0 0 0.4rem; }
    .sidebar .subtitle { font-size: 0.8rem; color: #9ca3af; margin-bottom: 1.4rem; }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul { list-style: none; padding: 0; margin: 0; font-size: 0.9rem; }
    .sidebar nav li { margin: 0.15rem 0; }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover { background: #1f2937; }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 { margin-top: 1.6em; color: #111827; }
    h1 { margin-top: 0; }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol { padding-left: 1.4em; }
    hr { margin: 2.2rem 0; border: none; border-top: 1px solid #e5e7eb; }
    .note { font-size: 0.9rem; color: #4b5563; }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Left menu -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft - English + validity model (edit-version 33)</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; invalid</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Identifier <code>_</code> (Underscore)</a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with-blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
        <li><a href="#validity-model">8.1 Reference validity model</a></li>
        <li><a href="#boxing-unboxing">2.4 boxing / unboxing</a></li>
        <li><a href="#implicit-unbox-cast">5.2.2 Implicit unbox cast</a></li>
        <li><a href="#unbox-operator">15.3 unbox operator</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Spec (Draft, English)</h1>
    <p class="note">
      edit-version: 33<br>
      edit-date: 2025-12-18T23:30:08+09:00
    </p>
    <p class="note">
      This document is an English draft based on the upstream specification.<br>
      In addition, it introduces a reference validity model using <strong>valid / invalid</strong> and
      <strong>removes null from the specification</strong>.<br>
      It also includes an extension to <strong>4.2 with-blocks</strong>:
      <strong>type-based with (for class/struct/enum) as a shorthand for static members / enumerators</strong>.<br>
      Furthermore, it introduces the universal type <code>object</code> and box objects, implicit unbox casts,
      and the <code>unbox</code> operator.<br>
      Other parts are kept as faithful as possible to the upstream.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language aiming for simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and targets the following goals.
    </p>
    <ul>
      <li>Readable and writable for education and small applications</li>
      <li>Runs on the C# runtime and WebAssembly (WASM) environments</li>
      <li>Controls I/O and concurrency while remaining statically typed via <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Features:</p>
    <ul>
      <li>Static typing
        <ul>
          <li>Type inference via <code>var</code></li>
          <li>Explicit typing via <code>let</code></li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> ... value type</li>
          <li><code>class</code> / <code>object</code> ... reference type</li>
        </ul>
      </li>
      <li>GC-based memory management (exact algorithm is VM-implementation-defined)</li>
      <li>Reference invalid state (<code>invalid</code>) as a language-level model
        <ul>
          <li><code>delete</code> invalidates a reference variable; accessing members afterward throws an exception.</li>
          <li><code>invalid</code> is not assignable (for validity checks only).</li>
        </ul>
      </li>
      <li>Universal reference type <code>object</code> and boxing / unboxing via box objects</li>
      <li>Dataflow-style design via <code>pipe</code> / <code>filter</code></li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li>From <code>//</code> to end of line is a line comment.</li>
      <li><code>/*</code> to <code>*/</code> is a block comment.</li>
      <li>
        Block comments are not nested: the comment starts at the first <code>/*</code> and ends at the first following <code>*/</code>.<br>
        Any additional <code>/*</code> or <code>*/</code> tokens inside are treated as part of the comment.
      </li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: ASCII letters (A-Z, a-z), digits (0-9), underscore <code>_</code></li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Identifiers are case-sensitive.</li>
      <li>Keywords cannot be used as identifiers.</li>
      <li><code>_</code> can be used as a normal identifier (no special meaning).</li>
      <li>Unicode characters may be used (excluding whitespace and separators).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
ifnot
import
implements
in
interface
is
let
main
map
match
method
namespace
new
object
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
unbox
valid
invalid
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li>Use <code>namespace</code> (not <code>package</code>).</li>
      <li><code>final</code> is removed; use <code>sealed</code> to prohibit extension.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checks.</li>
      <li><code>null</code> is removed from the specification.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>Floating point literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>Decimal literals: <code>10.12345678901234567890:d</code></li>
      <li>Booleans: <code>true</code>, <code>false</code></li>
      <li>Strings: <code>"Hello, World!"</code></li>
      <li>Characters: <code>'A'</code>, <code>'z'</code></li>
      <li>Reference validity: <code>valid</code>, <code>invalid</code> (checks only; not assignable)</li>
      <li>Array literals: <code>[1, 2, 3]</code></li>
      <li>List literals: <code>(1, 2, 3)</code></li>
      <li>Set literals: <code>{1, 2, 3}</code></li>
      <li>Map literals: <code>["key1": 10, "key2": 20]</code></li>
      <li>Enum literals: <code>EnumType.Value1</code></li>
      <li>Struct literals: <code>Point { x: 0, y: 1 }</code></li>
      <li>Object creation: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>All statements must end with a semicolon <code>;</code>.</li>
      <li>There is no automatic semicolon insertion.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines separate tokens.</li>
      <li>Consecutive whitespace is treated as a single separator.</li>
      <li>Indentation has no semantic meaning.</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase except <code>Result</code>.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe defines the following 8 primitive types.
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> - boolean value.</li>
      <li><code>int</code> / <code>integer</code> - signed integer.</li>
      <li><code>float</code> - floating point number.</li>
      <li><code>decimal</code> - high precision decimal number.</li>
      <li><code>string</code> - string (internally Unicode).</li>
      <li><code>byte</code> - unsigned integer 0-255.</li>
      <li><code>char</code> - a single character.</li>
      <li><code>void</code> - no return value (return-only type).</li>
    </ul>
    <p>
      <code>valid</code> / <code>invalid</code> are not types.
      They are <strong>special constants (literals) for checking reference validity</strong>.<br>
      <code>null</code> is removed from the specification; invalid references are modeled via <code>invalid</code>.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Arrays: <code>T[]</code></li>
      <li>Lists: <code>T()</code></li>
      <li>Sets: <code>T{}</code></li>
      <li>Maps: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Async tasks: <code>task</code></li>
      <li>Universal reference: <code>object</code></li>
      <li>Pipes: <code>pipe&lt;T&gt;</code> (see Chapter 18)</li>
      <li>Result type: <code>Result&lt;T&gt;</code> (see Chapter 18)</li>
    </ul>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internal representation is int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implementation-wise a reference type)</li>
          <li><code>object</code></li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>object type</h4>
    <ul>
      <li><code>object</code> is a special reference type that can hold any value except <code>void</code>.</li>
      <li>Any reference-typed value can be implicitly assigned to <code>object</code> (reference copy).</li>
      <li>Assigning a primitive value to <code>object</code> performs boxing into the corresponding box object (see 2.4).</li>
      <li>There is no implicit conversion from <code>object</code> to a concrete type (use <code>as</code> or implicit unbox casts).</li>
      <li>Within <code>if (x is T) { ... }</code>, <code>x</code> may be treated as type <code>T</code> (flow-dependent narrowing).</li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Struct fields may only be primitives and other structs.</li>
      <li>Reference-typed fields (e.g., classes) are not allowed.</li>
      <li>Struct assignment always copies by value.</li>
      <li>No max-size limit is defined by the spec.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>A class may have struct fields.</li>
      <li>Assigning a class instance to another variable copies the reference (the object is shared).</li>
    </ul>

    <h3 id="boxing-unboxing">2.4 boxing / unboxing (box objects and ToXxx)</h3>
    <p>
      Aloe defines a <strong>box object</strong> class for each primitive type in order to store primitives inside <code>object</code>.
      A box object name starts with an uppercase letter and derives from <code>object</code>.
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> - <code>Boolean</code></li>
      <li><code>int</code> / <code>integer</code> - <code>Integer</code></li>
      <li><code>float</code> - <code>Float</code></li>
      <li><code>decimal</code> - <code>Decimal</code></li>
      <li><code>string</code> - <code>String</code></li>
      <li><code>byte</code> - <code>Byte</code></li>
      <li><code>char</code> - <code>Char</code></li>
    </ul>
    <ul>
      <li>A box object stores the corresponding value internally, but it does not expose a public value property (value is private).</li>
      <li>Unboxing is performed via the corresponding <code>ToXxx()</code> method.</li>
      <li>Canonical <code>ToXxx()</code> names are:
        <ul>
          <li><code>ToBool()</code>, <code>ToInt()</code>, <code>ToFloat()</code>, <code>ToDecimal()</code>, <code>ToString()</code>, <code>ToByte()</code>, <code>ToChar()</code></li>
        </ul>
      </li>
      <li>Boxing: assigning a primitive to <code>object</code> stores an instance of the corresponding box object.</li>
      <li>Unboxing: extracting a primitive from <code>object</code> uses <code>as</code>, implicit unbox casts, or the <code>unbox</code> operator.</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> result in <code>float</code>.
        <ul>
          <li><code>int + float -&gt; float</code></li>
          <li><code>int - float -&gt; float</code></li>
          <li><code>int * float -&gt; float</code></li>
          <li><code>int / float -&gt; float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision decimal number.</li>
      <li>Mixed expressions with <code>int</code> / <code>float</code> may promote to <code>decimal</code> as needed.</li>
      <li>Overflow / underflow / precision issues are treated as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe does not have a parenthesized cast syntax (e.g., <code>(T)x</code>).</li>
      <li>Type conversions are performed via the <code>as</code> operator (see 15.1).</li>
      <li>Implicit and explicit conversions between enum and int are prohibited.</li>
      <li>Mixing enum and numeric types in an expression is a compile error (except bit ops on bitfield enum).</li>
      <li>Internal representation of enum / bitfield enum is int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0-255.</li>
          <li>Arithmetic between bytes is allowed, but out-of-range may be an error.</li>
          <li>Mixed expressions with int promote to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic on char is not allowed.</li>
          <li>Comparisons (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are only allowed between chars.</li>
          <li>No implicit conversion to/from numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow are handled as exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.</p>
    <ul>
      <li><code>main</code> block</li>
      <li>Class definition block</li>
      <li>Method definition block</li>
      <li>Any <code>{ ... }</code> block</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadows the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>Declaring the same name in an inner scope shadows the outer one.</li>
      <li>If a field name conflicts with a local variable, the local wins; use <code>this.</code> to access the field.</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks (member access shorthand)</h3>
    <p>
      Aloe provides <code>with</code> blocks to write repeated member accesses more concisely.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated exactly once at the start of the block and stored (not re-evaluated).</li>
        </ul>
      </li>
      <li><strong><code>_</code> is not special.</strong> There is no implicit variable for the with-target.</li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>The innermost <code>with</code> is used for resolving <code>.</code>.</li>
          <li>Outer objects remain accessible via their variable names.</li>
        </ul>
      </li>
      <li>Multiple <code>with</code> targets may be listed in the same block (similar to C# <code>using</code> style):</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against user, then profile
}
</code></pre>
    <ul>
      <li>Resolution order is <strong>left to right</strong>.</li>
      <li>The member resolves to the first target where it is found.</li>
      <li>If the same member exists in multiple targets and resolution becomes ambiguous, it is a <strong>compile error</strong>.</li>
    </ul>
    <p>
      <code>with</code> is syntactic sugar: it can be desugared into explicit <code>obj.member</code> accesses before type-checking and codegen.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enumerator shorthand)</h4>
    <p>
      In addition to <code>with (expr)</code>, Aloe supports <code>with</code> targeting a <strong>type name</strong>.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here <code>TypeName</code> must be one of:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> / <code>bitfield enum</code> type</li>
    </ul>
    <p>In this case, it is interpreted as a “type-context with”:</p>
    <ul>
      <li>The content inside <code>()</code> is not evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; it does not instantiate anything.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.</li>
          <li>Accessing instance members inside a type-based with is a compile error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Type-based with may be mixed with multi-target with; resolution is left-to-right and ambiguity is a compile error.
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The variable type is inferred from the right-hand expression.</li>
      <li><code>var x = 1;</code> is always <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = invalid;</code> is a compile error (<code>invalid</code> is not assignable).</li>
      <li>If the RHS expression is of type <code>object</code>, the inferred type is <code>object</code>.</li>
    </ul>

<pre><code>function SomeFunc(): object {
    return 123;   // boxing to Integer
}

function main(args: string[]): int {
    var x = 1;            // int
    var a = 123;          // int
    var v = SomeFunc();   // object
    return 0;
}
</code></pre>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>
    <ul>
      <li><code>let x: Foo = invalid;</code> is a compile error (<code>invalid</code> is not assignable).</li>
    </ul>

    <h3>5.2.1 Uninitialized references</h3>
    <p>
      Declarations of reference-typed variables may omit initialization.
      In that case, the reference is treated as <strong>invalid</strong> (uninitialized and invalid are not distinguished).
    </p>
<pre><code>var obj: Foo;        // OK (uninitialized reference)
obj.Value;           // runtime exception (InvalidReferenceException)
</code></pre>
    <ul>
      <li>An uninitialized reference-typed variable is treated as <strong>invalid</strong> at runtime.</li>
      <li>Member access on an invalid reference throws <strong>InvalidReferenceException</strong>.</li>
    </ul>

    <h3 id="implicit-unbox-cast">5.2.2 Implicit unbox cast (non-consuming)</h3>
    <p>
      In contexts where the <strong>expected type</strong> is fixed to a primitive type <code>P</code>,
      an <strong>implicit unbox cast</strong> is permitted for expression <code>E</code>.
      An implicit unbox cast <strong>does not consume</strong> the reference (it does not invalidate a variable).
    </p>
    <p>Examples of contexts where implicit unbox casts are permitted:</p>
    <ul>
      <li><code>let x:P = E;</code> (initialization)</li>
      <li><code>x = E;</code> (assignment, where <code>x</code> has type <code>P</code>)</li>
      <li><code>return E;</code> (function return type is <code>P</code>)</li>
      <li><code>f(E)</code> (parameter type is <code>P</code>)</li>
    </ul>
    <p>
      Implicit unbox casts are semantically equivalent to <code>E as P</code>, and throw <code>InvalidCastException</code> on failure.
      Using an alternate value via <code>ifnot</code> is available only with an explicit <code>as</code> (see 15.1).
    </p>
    <p>Success conditions (no conversion is performed):</p>
    <ul>
      <li>The runtime value of <code>E</code> is the primitive <code>P</code>.</li>
      <li>Or the runtime value of <code>E</code> is the corresponding box object (e.g., <code>Integer</code>) and <code>P</code> can be extracted via <code>ToXxx()</code>.</li>
    </ul>
    <p>Prohibited:</p>
    <ul>
      <li>No numeric type conversion (e.g., do not implicitly convert <code>Integer</code> to <code>byte</code>).</li>
      <li>No parsing or format conversion (e.g., do not implicitly convert <code>"123"</code> to <code>int</code>).</li>
    </ul>
<pre><code>let o: object = 123;      // boxing: Integer
let i: int = o;           // OK (implicit unbox cast) == (o as int)

let s2: string = o;       // failure (no conversion) throws InvalidCastException
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables are not reassignable.</li>
      <li><code>const</code> requires a type annotation.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields in class/struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id;
    }
    method change(): void {
        this.count = this.count + 1;
    }
}
</code></pre>
    <ul>
      <li><code>field</code> ... normal field.</li>
      <li><code>readonly field</code> ... assignable only inside constructor; read-only afterward.</li>
      <li>Same meaning for struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>Class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended via <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>Struct is a value type.</li>
      <li>Fields are limited to primitives and other structs (reference-typed fields are prohibited).</li>
      <li>Struct copying is always by value.</li>
      <li>Struct inheritance is not supported (<code>sealed struct</code> is only a “no extension” marker).</li>
    </ul>

    <h4>Struct layout annotations: @StructLayout / @FieldOffset</h4>
    <p>(Omitted: conforms to upstream.)</p>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <p>(Trait details conform to upstream.)</p>

    <hr>

    <h2 id="ch8">8. delete &amp; invalid</h2>

    <h3 id="validity-model">8.1 Reference validity model (valid / invalid)</h3>
    <p>
      Aloe models whether a reference is “valid” or “invalid”.<br>
      <code>invalid</code> is <strong>not assignable</strong>, but may be used for validity checks.
    </p>

<pre><code>var obj = new FizzBuzz();
delete obj;           // obj becomes invalid
if (obj is invalid) {
    print("invalid");
}
</code></pre>

    <ul>
      <li><code>delete x;</code> invalidates the reference variable <code>x</code>.</li>
      <li><strong><code>delete</code> must not throw.</strong> It has no effect if the variable is already invalid.</li>
      <li>After invalidation, member access through <code>x</code> causes <strong>InvalidReferenceException</strong>.</li>
      <li>Other variables referencing the same object are not affected (invalidation is per-variable).</li>
      <li>Actual memory reclamation is decided by the runtime (GC).</li>
      <li><strong>Uninitialized references and invalid are not distinguished.</strong> Uninitialized reference variables are treated as invalid.</li>
      <li><code>invalid</code> is for checks only; <code>x = invalid</code> and <code>let x: Foo = invalid</code> are compile errors.</li>
    </ul>

    <h3>8.2 Accessing invalid references</h3>
<pre><code>var obj: Foo;     // invalid
obj.Value;        // throws InvalidReferenceException
</code></pre>
    <ul>
      <li>Member access on invalid references always throws <code>InvalidReferenceException</code>.</li>
      <li>Even if the implementation can prove invalid statically, behavior is the same (optimizations are implementation-defined).</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
}

if (obj is ILogger) {
}

if (obj is Trait_A) {
}

if (obj is valid) {
}

if (obj is invalid) {
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks when the RHS is a type name.</li>
      <li>Inheritance relationships are considered (Derived is also Base).</li>
      <li>It can be used with interfaces and traits.</li>
      <li><code>is valid</code> / <code>is invalid</code> checks reference validity.</li>
      <li><strong><code>invalid is T</code> is always <code>false</code>.</strong> It must not throw.</li>
      <li><strong>Ambiguous name resolution is always a compile error.</strong></li>
      <li>The LHS of <code>is</code> must be an expression (a value).</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Arrays / Lists / Sets / Maps)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>Internal representation is always int32.</li>
      <li>Enum types are also targets of type-based with, allowing shorthand access to enumerators (e.g., <code>with (Color) { Red; }</code>).</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <hr>

    <h2 id="ch12">12. main Block (Entry point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0;
}
</code></pre>
    <ul>
      <li>Program entry point.</li>
      <li><code>args</code> are command-line arguments.</li>
      <li>Return value is specified by a <code>return</code> statement of type <code>int</code>.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Identifier <code>_</code> (Underscore)</h2>
    <p>
      In Aloe, <code>_</code> is a normal identifier and has no special “temporary variable” meaning.<br>
      In <code>with</code> blocks as well, <code>_</code> is not special (see 4.2).
    </p>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a);
print(b);
</code></pre>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 as operator and ifnot (type casting and fallback)</h3>
    <p>
      Aloe does not have a parenthesized cast; it uses the <code>as</code> operator for type casting.
      <code>as</code> throws <code>InvalidCastException</code> on failure.
      With <code>ifnot</code>, a fallback value or <code>throw</code> can be specified.
    </p>

<pre><code>let o: object = 123;                 // boxing: Integer

let i1: int = o as int;              // OK (unboxing); on failure throws InvalidCastException
let i2: int = o as int ifnot -1;     // on failure use -1
let i3: int = o as int ifnot throw;  // on failure throw InvalidCastException (same as omitted)
</code></pre>

    <ul>
      <li>If <code>T</code> is a reference type in <code>E as T</code>, runtime type checking is performed.</li>
      <li>If <code>P</code> is a primitive in <code>E as P</code>:
        <ul>
          <li>If <code>E</code> is primitive <code>P</code>, it succeeds as-is.</li>
          <li>If <code>E</code> is the corresponding box object (e.g., <code>Integer</code>), it succeeds by unboxing via <code>ToXxx()</code>.</li>
          <li>Otherwise it fails (<code>InvalidCastException</code>).</li>
        </ul>
      </li>
      <li>Omitting <code>ifnot</code> is equivalent to <code>ifnot throw</code>.</li>
      <li><code>ifnot throw</code> throws <code>InvalidCastException</code>.</li>
      <li><code>as</code> does not perform conversions (no numeric conversions, no parsing, etc.).</li>
    </ul>

    <h3 id="unbox-operator">15.3 unbox operator (consuming unboxing)</h3>
    <p>
      <code>unbox</code> extracts a primitive value from a reference variable and invalidates the variable on success.
      This is a “consuming unboxing” (move-like unboxing).
    </p>

<pre><code>let o: object = 123;         // boxing: Integer
let i: int = unbox o;        // i = 123, o becomes invalid
</code></pre>

    <ul>
      <li>The operand of <code>unbox</code> must be an assignable reference variable (an lvalue).</li>
      <li><code>unbox x</code> may only be used in contexts where the expected type is fixed to a primitive <code>P</code>.</li>
      <li>Evaluation rules (<code>x</code> is evaluated exactly once):
        <ul>
          <li>If <code>x</code> is invalid: throw <code>InvalidReferenceException</code> (and <code>x</code> does not change).</li>
          <li>If unboxing fails: throw <code>InvalidCastException</code> (and <code>x</code> does not change).</li>
          <li>If unboxing succeeds: return the value, then invalidate <code>x</code> as if <code>delete x;</code> were executed.</li>
        </ul>
      </li>
      <li>Unlike implicit unbox casts, <code>unbox</code> consumes the reference variable on success.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
}
catch (e) {
}
finally {
}
</code></pre>

    <h3>16.1 Standard exception overview</h3>
<pre><code>Exception
+- SystemException
|  +- InvalidReferenceException
|  +- InvalidCastException
|  +- IndexOutOfBoundsException
|  +- OverflowException
|  +- ZeroDivisionException
|  +- InvalidOperationException
|  +- NotImplementedException
|  +- TimeoutException
|  +- ArgumentException
|  |  +- ArgumentNullException
|  |  +- ArgumentOutOfRangeException
|  +- FormatException
+- IOException
   +- FileNotFoundException
   +- EndOfStreamException
   +- IOException (general)
</code></pre>
    <ul>
      <li><code>InvalidReferenceException</code> is thrown for invalid reference access (see Chapter 8).</li>
      <li><code>InvalidCastException</code> is thrown for cast failures via <code>as</code> / implicit unbox casts / <code>unbox</code>.</li>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
      <li>Parsing/format errors use <code>FormatException</code>.</li>
      <li><code>InvalidOperationException</code> is used for invalid operations in a state.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
    <p>(Omitted: conforms to upstream.)</p>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>
    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to compose streaming processing for servers / CLI / web apps.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <p>(Omitted: conforms to upstream.)</p>

    <h3>18.2 Result&lt;T&gt; and ROP principle</h3>
    <ul>
      <li><strong>Only within pipes (filter / producer / consumer) are values wrapped into Result.</strong></li>
      <li><strong>The bound of filter / producer / consumer must return Result; violations are compile errors.</strong></li>
      <li>Normal functions/methods have free return types; they may throw exceptions on failure (per their own contract).</li>
    </ul>

    <h3>18.7 Template map for collections</h3>
    <p>
      Prohibited uses of template map are compile errors whenever statically detectable.
    </p>

    <hr>

    <h2 id="editor-notes">Appendix: Editing policy for generative AI (not part of the spec)</h2>
    <p class="note">
      <strong>Shared editing policy for Aloe Language Spec / AloeVM Spec:</strong><br>
      ・This document and the AloeVM spec are operated under the same editing policy.<br>
      ・The Japanese and English versions must always match in meaning (chapter structure, headings, and content); do not simplify/extend only one side.<br>
      ・<code>edit-version</code> is shared between Japanese and English versions and is incremented by +1 only when the spec body (including samples) changes. Do not decrement or roll back.<br>
      ・<code>edit-date</code> must always be the Asia/Tokyo current time at the moment of applying edits, in ISO 8601 format (YYYY-MM-DDThh:mm:ss+09:00). Do not guess or use other time zones.<br>
      ・Do not modify unrelated parts. Even if the meaning is the same, do not rewrite variable names, method names, or wording “for improvement.”<br>
      ・If you want to add new specs or change meanings of existing specs, consult the user and obtain agreement before applying.<br>
      ・Always treat the last full HTML provided by the user as the canonical text, and apply only minimal diffs to that version.<br>
      ・If you cannot reproduce the last HTML or are unsure which version is the latest, stop editing and ask the user.<br>
      ・Do not use emoji or non-standard glyphs in HTML. Japanese characters must be limited to JIS Level 1 and Level 2.<br>
    </p>

  </main>
</div>
</body>
</html>
