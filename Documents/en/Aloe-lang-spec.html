<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English)</title>
  <meta name="edit-version" content="28">
  <meta name="edit-date" content="2025-12-17T23:56:15+09:00">
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout { display: flex; min-height: 100vh; }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 { font-size: 1.1rem; margin: 0 0 0.4rem; }
    .sidebar .subtitle { font-size: 0.8rem; color: #9ca3af; margin-bottom: 1.4rem; }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul { list-style: none; padding: 0; margin: 0; font-size: 0.9rem; }
    .sidebar nav li { margin: 0.15rem 0; }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover { background: #1f2937; }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 { margin-top: 1.6em; color: #111827; }
    h1 { margin-top: 0; }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol { padding-left: 1.4em; }
    hr { margin: 2.2rem 0; border: none; border-top: 1px solid #e5e7eb; }
    .note { font-size: 0.9rem; color: #4b5563; }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Left menu -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft - English (edit-version 28)</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; valid/invalid</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with-blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
        <li><a href="#valid-invalid">8.1 valid / invalid</a></li>
        <li><a href="#result-boundary">18.2 Result boundary</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English)</h1>

    <p class="note">
      edit-version: 28<br>
      edit-date: 2025-12-17T23:56:15+09:00
    </p>

    <p class="note">
      This document is an English draft specification for Aloe.<br>
      (Reference: <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>)<br>
      This revision (edit-version 28) updates the primitive-type definition, removes <code>null</code> from the language surface,
      and introduces <strong><code>valid</code>/<code>invalid</code></strong> as special literals for validity checks.
      It also clarifies the boundary between compile-time errors and runtime exceptions, especially around <code>Result</code>,
      <code>invalid</code> references, ambiguous name resolution, and template <code>map</code> constraints.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language aiming for a simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and targets:
    </p>
    <ul>
      <li>Ease of reading/writing for education and small applications</li>
      <li>Execution on C# runtime and WebAssembly (WASM) environments</li>
      <li>Static-typed control of I/O and concurrency via <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Key features:</p>
    <ul>
      <li>Static typing
        <ul>
          <li>Type inference with <code>var</code></li>
          <li>Explicit typing with <code>let</code></li>
        </ul>
      </li>
      <li>Value types / reference types</li>
      <li>GC-based memory management (specific algorithms are VM-implementation-defined)</li>
      <li>No surface-level <code>null</code>; instead, reference validity is represented by <code>valid</code>/<code>invalid</code></li>
      <li>Data-flow style design with <code>pipe</code> / <code>filter</code></li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> starts a line comment until end-of-line.</li>
      <li><code>/*</code> ... <code>*/</code> is a multi-line comment.</li>
      <li>Multi-line comments do not nest. The first <code>*/</code> closes the comment.</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: ASCII letters (A-Z, a-z), digits (0-9), underscore <code>_</code></li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Keywords cannot be used as identifiers.</li>
      <li>Identifiers starting with <code>_</code> are conventionally treated as “private”.</li>
      <li>Unicode identifiers may be allowed (excluding whitespace and separators); details are implementation-defined.</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
any
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> is not used; use <code>namespace</code>.</li>
      <li><code>final</code> is removed; use <code>sealed</code> to prevent extension.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checks.</li>
      <li><code>valid</code> and <code>invalid</code> are <strong>special literals</strong>, not keywords.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code></li>
      <li>Float: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>Decimal: <code>10.12345678901234567890:d</code></li>
      <li>Boolean: <code>true</code>, <code>false</code></li>
      <li>String: <code>"Hello, World!"</code></li>
      <li>Char: <code>'A'</code>, <code>'z'</code></li>
      <li><strong>Validity literals:</strong> <code>valid</code>, <code>invalid</code> (comparison/check only; not assignable)</li>
      <li>Array: <code>[1, 2, 3]</code></li>
      <li>List: <code>(1, 2, 3)</code></li>
      <li>Set: <code>{1, 2, 3}</code></li>
      <li>Map: <code>["key1": 10, "key2": 20]</code></li>
      <li>Enum: <code>EnumType.Value1</code></li>
      <li>Struct: <code>Point { x: 0, y: 1 }</code></li>
      <li>Object construction: <code>new ClassName()</code></li>
    </ul>
    <ul>
      <li><code>null</code> does not exist in the language surface and must not appear in source code.</li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>All statements end with semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion on line breaks.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and line breaks separate tokens.</li>
      <li>Indentation has no meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>Keywords are lowercase (except <code>Result</code>).</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      In Aloe, “primitive types” are defined as the following <strong>8</strong> types:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> - boolean</li>
      <li><code>int</code> / <code>integer</code> - signed integer</li>
      <li><code>float</code> - floating point</li>
      <li><code>decimal</code> - high-precision decimal</li>
      <li><code>string</code> - string (internally Unicode; implementation-defined)</li>
      <li><code>byte</code> - 8-bit unsigned integer (0-255)</li>
      <li><code>char</code> - character</li>
      <li><code>void</code> - no return value (return-position only)</li>
    </ul>
    <p>
      <strong><code>valid</code>/<code>invalid</code></strong> are not types; they are special literals used only for validity checks.
      Their runtime representation may map to VM-level null-like state, but <code>null</code> is not exposed in source.
    </p>
    <p>
      Aloe also introduces the special type <code>any</code> to hold values of arbitrary types where needed.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Async task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see Chapter 18)</li>
      <li>Result type: <code>Result&lt;T&gt;</code> (see Chapter 18)</li>
    </ul>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internal representation is int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implementation-defined, typically reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>any type</h4>
    <ul>
      <li><code>any</code> can hold any value except <code>void</code>.</li>
      <li>Any value of type T can be implicitly converted to <code>any</code>.</li>
      <li>No implicit conversion from <code>any</code> to a concrete type.</li>
      <li>Inside <code>if (x is T) { ... }</code>, <code>x</code> may be treated as T (flow-sensitive narrowing).</li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>A struct field can contain primitive types and other structs.</li>
      <li>Reference-type fields are not allowed in structs.</li>
      <li>Struct assignment always copies by value.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>A class may contain structs as fields.</li>
      <li>Assigning a class instance copies the reference (shared object).</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Mixed arithmetic between <code>int</code> and <code>float</code> results in <code>float</code>.</li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision base-10 type.</li>
      <li>Overflow/underflow/precision issues are handled as <code>OverflowException</code> (see Chapter 16).</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Implicit and explicit conversions between enum and int are forbidden.</li>
      <li>Mixing enum with numeric types is a compile-time error (except bit operations for bitfield enum).</li>
      <li>Internal representation of enum/bitfield enum is int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code> range is 0-255.</li>
      <li>Byte arithmetic is allowed; out-of-range may raise runtime exception (implementation-defined).</li>
      <li>Mixing <code>byte</code> and <code>int</code> promotes to <code>int</code>.</li>
      <li><code>char</code> arithmetic is not allowed.</li>
      <li>Comparisons for <code>char</code> are allowed only between chars.</li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow is handled by exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by zero (including 0 / 0.0).</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadows the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>

    <h3 id="with-blocks">4.2 with-blocks (member access shorthand)</h3>
    <p>
      Aloe provides <code>with</code> blocks to write member accesses concisely for the same target object.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated once at block entry and stored in an internal temp variable.</li>
          <li>Special temp variable <code>_</code> refers to the current with-target object inside the block.</li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks: inner blocks shadow the <code>.</code> resolution and <code>_</code>.</li>
      <li>Multiple targets may be listed, C#-using-style:</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>Resolution order is implementation-defined.</li>
      <li><strong>If resolution is ambiguous (multiple targets have the same member), it is a compile-time error.</strong></li>
    </ul>

    <h4 id="with-type">4.2.1 Type-based with (static members / enum enumerators)</h4>
    <p>
      In addition to <code>with (expr)</code>, Aloe allows <code>with</code> targeting a <strong>type name</strong>.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <ul>
      <li><code>TypeName</code> must resolve to a <code>class</code>, <code>struct</code>, <code>enum</code>, or <code>bitfield enum</code>.</li>
      <li>The expression inside <code>(...)</code> is not evaluated at runtime; it is resolved as a type at compile time.</li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>, where <code>Member</code> must be:
            <ul>
              <li>static field</li>
              <li>static method</li>
              <li>enum/bitfield enum enumerator</li>
            </ul>
          </li>
          <li><code>_</code> behaves as a pseudo object representing the static context; <code>_.Member</code> equals <code>TypeName.Member</code>.</li>
          <li>Accessing instance members from type-based with is a compile-time error.</li>
        </ul>
      </li>
      <li>Ambiguity rules are the same: ambiguous resolution is a compile-time error.</li>
    </ul>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>Variable type is inferred from the RHS expression.</li>
      <li><code>var x = 1;</code> is <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is <code>float</code>.</li>
      <li><code>valid</code>/<code>invalid</code> cannot be used as assignable expressions.</li>
      <li>If RHS is <code>any</code>, inferred type is <code>any</code>.</li>
    </ul>

<pre><code>function SomeFunc(): any {
    return 123;
}

function main(args: string[]): int {
    var x = 1;            // int
    var a = 123;          // int
    var v = SomeFunc();   // any
    return 0;
}
</code></pre>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>
    <ul>
      <li><code>let x: Foo = invalid;</code> is a compile-time error.</li>
    </ul>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>

    <hr>

    <h2 id="ch6">6. Fields</h2>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK in constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>

    <h4>Struct layout annotations: @StructLayout / @FieldOffset</h4>
<pre><code>@StructLayout("Explicit")
struct NativePoint {
    @FieldOffset(0) field X: int;
    @FieldOffset(4) field Y: int;
}
</code></pre>

    <h4>7.2.1 Generic annotation mechanism (annotation definition)</h4>
<pre><code>annotation MyAnnotation {
    text:   "Annotation text";
    target: TargetKind;
    params: map&lt;string/any&gt;;

    build:  function (ctx: AnnotationBuildContext): void {
        // compiler hook
    }
}
</code></pre>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying trait with with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello();
</code></pre>

    <h4>Non-destructive add / remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;
var obj3 = obj2 - Trait_A;
</code></pre>

    <h4>Alias via as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello();
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define the same member, the right-most trait wins.</li>
      <li>If a class member conflicts with a trait member, the last-applied trait wins.</li>
      <li>To avoid conflicts, use <code>as</code> alias and access through the alias namespace.</li>
    </ul>

    <h4>Trait expects clause</h4>
<pre><code>interface IHasId {
    method GetId(): int;
}

trait HasIdFormatting expects IHasId {
    method PrintId(): void {
        print("ID = " + this.GetId());
    }
}

class User implements IHasId {
    field Id: int;
    method GetId(): int { return this.Id; }
}
</code></pre>

    <hr>

    <h2 id="ch8">8. delete &amp; valid/invalid</h2>

    <h3 id="valid-invalid">8.1 valid / invalid (special literals)</h3>
    <ul>
      <li><code>valid</code> and <code>invalid</code> are special literals used only for validity checks.</li>
      <li><strong>They cannot be assigned.</strong> Examples such as <code>x = invalid;</code> or <code>var x = invalid;</code> are compile-time errors.</li>
      <li>They may be used only with the <code>is</code> operator (and its negated form if supported) as described in Chapter 9.</li>
      <li>At the VM level, <code>invalid</code> corresponds to an invalid reference state (null-like), but <code>null</code> must not appear in source.</li>
    </ul>

<pre><code>var obj = new FizzBuzz();
delete obj;  // VM-level equivalent: obj becomes invalid
</code></pre>
    <ul>
      <li><code>delete obj;</code> marks the reference variable <code>obj</code> as invalid.</li>
      <li>VM-level semantics: <code>delete obj;</code> is equivalent to setting the reference to an invalid state.</li>
      <li><code>delete</code> affects only the reference variable, not other references to the same object.</li>
      <li>If <code>obj</code> is already invalid, <code>delete obj;</code> is a no-op and must not throw.</li>
      <li>Accessing members through an invalid reference causes a runtime <code>NullPointerException</code> (or equivalent).</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied
}

if (obj is valid) {
    // true if obj is a valid reference
}

if (obj is invalid) {
    // true if obj is invalid
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime checks for types, interfaces, and traits.</li>
      <li><strong><code>is valid</code> and <code>is invalid</code> are validity checks for reference values.</strong></li>
      <li>The left operand of <code>is</code> must be an expression (a value). Type names cannot appear on the left.</li>
      <li>Using <code>valid</code>/<code>invalid</code> outside <code>is</code> is a compile-time error.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,
}
</code></pre>

    <hr>

    <h2 id="ch12">12. main Block (entry point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0;
}
</code></pre>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;
    return 0;
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // first assignment determines the type of _
}
</code></pre>
    <ul>
      <li><code>_</code> can be used without explicit declaration inside any block.</li>
      <li>In non-main blocks, the first assignment determines the type of <code>_</code>.</li>
      <li>Inside a <code>with</code> block, <code>_</code> additionally refers to the with-target (Chapter 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a);
print(b);
</code></pre>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (high to low)</h3>
    <ol>
      <li>Member/call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Mul/div: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Add/sub: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bit AND: <code>&amp;</code></li>
      <li>Bit XOR: <code>^</code></li>
      <li>Bit OR: <code>|</code> (pipeline statement uses a different meaning)</li>
      <li>Logical AND: <code>&amp;&amp;</code> (alias: <code>and</code>)</li>
      <li>Logical OR: <code>||</code> (alias: <code>or</code>)</li>
      <li>Assignment: <code>=</code></li>
    </ol>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>Other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Standard exception overview</h3>
<pre><code>Exception
+- SystemException
|  +- NullPointerException
|  +- IndexOutOfBoundsException
|  +- OverflowException
|  +- ZeroDivisionException
|  +- InvalidOperationException
|  +- NotImplementedException
|  +- TimeoutException
|  +- ArgumentException
|  |  +- ArgumentNullException
|  |  +- ArgumentOutOfRangeException
|  +- FormatException
+- IOException
   +- FileNotFoundException
   +- EndOfStreamException
   +- IOException (general)
</code></pre>

    <h3>16.2 Compile-time error vs runtime exception boundary (selected rules)</h3>
    <ul>
      <li><strong>Compile-time errors:</strong>
        <ul>
          <li>Assigning or initializing with <code>valid</code>/<code>invalid</code> (e.g., <code>x = invalid;</code>)</li>
          <li>Violating required return type of <code>bound</code> in <code>filter</code>/<code>producer</code>/<code>consumer</code> (must return <code>Result</code>)</li>
          <li>Ambiguous name resolution (e.g., ambiguous <code>with</code> member resolution, ambiguous imports)</li>
          <li>Template <code>map</code> forbidden usages (see Chapter 18.7)</li>
        </ul>
      </li>
      <li><strong>Runtime exceptions:</strong>
        <ul>
          <li>Dereferencing an invalid reference: <code>NullPointerException</code></li>
          <li>Invalid <code>Result</code> access (reading <code>Value</code> when <code>Success == false</code>, etc.): <code>InvalidOperationException</code></li>
        </ul>
      </li>
      <li><strong>Note:</strong> some runtime errors may be diagnosed by the compiler when statically obvious, but the language rules above define the minimum required behavior.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>

    <h3>17.1 Module</h3>
    <p>
      A “module” corresponds to one source file. Package layout and build system behavior are out of scope.
    </p>

    <h3>17.2 File structure constraints</h3>
<pre><code>import Foo.Bar;
import Aloe.Core.Logging;
import Aloe.Json.*;
import MyCompany.Project.Module;

namespace My.App {
    // declarations only
}
</code></pre>

    <h3>17.3 namespace rules</h3>
    <ul>
      <li>Exactly one <code>namespace</code> per module.</li>
      <li>No nested namespace blocks.</li>
      <li>Only declarations inside namespace; no top-level executable statements.</li>
    </ul>

    <h3>17.4 import rules</h3>
    <ul>
      <li><code>import</code> must appear only at the beginning of a file.</li>
      <li>No relative import.</li>
      <li>Wildcard import introduces public symbols under the specified namespace; ambiguity is a compile-time error.</li>
    </ul>

    <h3>17.5 Name resolution priority (overview)</h3>
    <ol>
      <li>Local scope</li>
      <li>Current type members</li>
      <li>Current namespace declarations</li>
      <li>Imported public members</li>
    </ol>
    <p><strong>If resolution is ambiguous, it is a compile-time error.</strong></p>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to build streaming pipelines for CLI/server/Web apps.
    </p>

    <h3>18.1 pipe&lt;T&gt; basics</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of elements of type T.</li>
      <li>Shared-nothing model is recommended; pipes are the main communication mechanism.</li>
    </ul>

    <h3 id="result-boundary">18.2 Result boundary (where Result is required)</h3>
    <ul>
      <li><strong>Only inside pipe constructs</strong> (<code>filter</code>, <code>producer</code>, <code>consumer</code>) is <code>Result</code> required.</li>
      <li>A <code>filter</code>/<code>producer</code>/<code>consumer</code> <code>bound</code> must return <code>Result&lt;T&gt;</code> (or its specialized form such as <code>Result&lt;void&gt;</code>).</li>
      <li>If <code>bound</code> returns a non-<code>Result</code> type (including <code>void</code>), it is a <strong>compile-time error</strong>.</li>
      <li>Normal functions and methods are free to return any type; failures may throw exceptions as defined by the function/method contract.</li>
    </ul>

    <h3>18.3 Result&lt;T&gt; and ROP overview</h3>
<pre><code>class Result&lt;T&gt; {
    field Success: bool;
    field Value: T;
    field ErrorMessage: string;

    static method Ok(value: T): Result&lt;T&gt;;
    static method Error(message: string): Result&lt;T&gt;;
}
</code></pre>
    <ul>
      <li>If <code>Success == true</code>, <code>Value</code> is valid.</li>
      <li>If <code>Success == false</code>, <code>ErrorMessage</code> is valid and reading <code>Value</code> is invalid.</li>
      <li>Invalid access raises <code>InvalidOperationException</code> at runtime.</li>
      <li><code>Result&lt;void&gt;.Ok()</code> (no arguments) is allowed to represent “success with no value”.</li>
    </ul>

    <h3>18.4 Filter definition</h3>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    options: LineSplitOptions;

    field _buffer: string = "";

    constructor(opts: LineSplitOptions) {
    }

    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Result&lt;void&gt;.Ok();
    }
}
</code></pre>

    <h3>18.5 Filter options</h3>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>

    <h3>18.6 Pipeline statement and <code>|</code> / pipe-with operator <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>

    <h4>18.6.1 Pipe-with operator <span class="operator">|&gt;</span> (conditional filter shortcut)</h4>
<pre><code>users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>

    <h3>18.7 map for collections (template map)</h3>
<pre><code>customers = users | map Customer {
    Name    = "FixedName";
    Created = now();
    BaseUrl = base.ApiEndpoint;
};
</code></pre>
    <ul>
      <li>Template <code>map</code> constructs new instances for each element and assigns fields using the template body.</li>
      <li><strong>Forbidden items in template map are compile-time errors</strong>, including:
        <ul>
          <li>Referencing the current element directly (e.g., <code>u.Name</code>)</li>
          <li>Calling functions that depend on the current element as an argument</li>
          <li>Any dynamic per-element computation beyond fixed values / fixed external calls</li>
        </ul>
      </li>
      <li>External context must be provided explicitly (e.g., via <code>base</code>), and its detailed semantics are context-defined.</li>
    </ul>

    <h3>18.8 close and EOF propagation</h3>
    <ul>
      <li>Writing after <code>close()</code> is invalid and may be an error.</li>
      <li>Filters should close output when input EOF is detected.</li>
    </ul>

    <hr>

    <h2 id="editor-notes">Appendix: Editing policy for generative AI (not part of the spec body)</h2>
    <p class="note">
      <strong>Shared editing policy (Aloe Language Spec / AloeVM Spec):</strong><br>
      - Apply the same editing policy to both documents.<br>
      - Japanese and English versions must always match in structure and meaning; do not arbitrarily simplify/expand only one side.<br>
      - <code>edit-version</code> must be shared between JP/EN and must be incremented only when the spec body (including examples) changes. Never decrement or roll back.<br>
      - <code>edit-date</code> must be the exact Asia/Tokyo timestamp at the moment the edit is applied, in ISO 8601 format (YYYY-MM-DDThh:mm:ss+09:00). Do not guess or use other time zones.<br>
      - Do not modify unrelated sections. Even if meaning is unchanged, do not “improve” names, wording, or formatting without instruction.<br>
      - If a new feature or semantics-changing edit is desired, consult the user and obtain agreement before applying it.<br>
      - Treat the most recent full HTML provided by the user as canonical, and apply only the minimum necessary diffs.<br>
      - If the canonical latest HTML cannot be reconstructed reliably, stop editing and ask the user to provide the latest full HTML again.<br>
      - Do not use emoji or non-standard glyphs. Japanese text (when present) must be limited to JIS level 1 and 2 characters.<br>
    </p>

  </main>
</div>
</body>
</html>
