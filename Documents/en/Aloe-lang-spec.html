<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English)</title>
  <meta name="edit-version" content="6">
  <meta name="edit-date" content="2025-12-03T08:00:00+09:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • English version + with extension</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
        <li><a href="#using-blocks">4.3 using blocks</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English)</h1>
    <p class="note">
      This document is the English draft of the Aloe language specification.<br>
      On top of the original English spec at
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>,
      it adds an extension to <strong>4.2 with-blocks</strong>:
      <strong>type-based with for class / struct / enum (shortcuts for static members / enum members)</strong>.<br>
      Apart from that, the specification content is kept as close as possible to the original.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language, aiming for simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and has the following main goals:
    </p>
    <ul>
      <li>Easy to read and write for education and small applications</li>
      <li>Runs on C# runtimes and WebAssembly (WASM) environments</li>
      <li>Allows static-typed control of I/O and concurrency via <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Features:</p>
    <ul>
      <li>Static typing
        <ul>
          <li><code>var</code> for type inference</li>
          <li><code>let</code> for explicit type annotations</li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> … value type</li>
          <li><code>class</code> … reference type</li>
        </ul>
      </li>
      <li>GC-based memory management (concrete algorithm is VM-implementation dependent)</li>
      <li>No direct <code>= null</code> in source code
        <ul>
          <li>Reference types can be null internally, but are handled via the <code>delete</code> syntactic sugar.</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> oriented dataflow design</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> to end of line is a line comment.</li>
      <li><code>/*</code> ～ <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assumed not supported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Cannot use the same spelling as a keyword.</li>
      <li>Identifiers starting with <code>_</code> are treated as “private by convention” (not to be referenced from outside).</li>
      <li>Unicode letters are allowed (excluding whitespace and delimiters).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
null
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
using
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> is not used; <code>namespace</code> is used instead.</li>
      <li><code>final</code> is removed; use <code>sealed</code> to prevent extension.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checks.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>floating point literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>decimal literals: <code>10.12345678901234567890:d</code> etc.</li>
      <li>boolean: <code>true</code>, <code>false</code></li>
      <li>string: <code>"Hello, World!"</code></li>
      <li>char: <code>'A'</code>, <code>'z'</code>, etc.</li>
      <li>null literal: <code>null</code></li>
      <li>array literal: <code>[1, 2, 3]</code></li>
      <li>list literal: <code>(1, 2, 3)</code></li>
      <li>set literal: <code>{1, 2, 3}</code></li>
      <li>map literal: <code>["key1": 10, "key2": 20]</code></li>
      <li>enum literal: <code>EnumType.Value1</code></li>
      <li>struct literal: <code>Point { x: 0, y: 1 }</code></li>
      <li>object creation: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>Every statement is terminated by a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion by newline.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines act as token separators.</li>
      <li>Multiple consecutive whitespace characters are treated as a single separator.</li>
      <li>Indentation has no semantic meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase (except <code>Result</code>).</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe has the following 7 primitive types:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – boolean value</li>
      <li><code>int</code> / <code>integer</code> – signed integer</li>
      <li><code>float</code> – floating point number</li>
      <li><code>decimal</code> – high-precision decimal</li>
      <li><code>string</code> – string (internally Unicode)</li>
      <li><code>null</code> – special type/value representing “no value”</li>
      <li><code>void</code> – used only as a return type for methods that return no value</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported by the language but are treated as value types described
      separately in chapter 3 (Numbers &amp; Conversions), not as primitive types in this list.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>array: <code>T[]</code></li>
      <li>list: <code>T()</code></li>
      <li>set: <code>T{}</code></li>
      <li>map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>asynchronous task: <code>task</code></li>
      <li>pipe: <code>pipe&lt;T&gt;</code> (see chapter 18)</li>
      <li>result type: <code>Result&lt;T&gt;</code> (see chapter 18)</li>
    </ul>
    <p><code>any</code> type does not exist and dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implementation-wise a reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>struct fields may only contain primitive types and other structs.</li>
      <li>They cannot contain fields of reference types such as class.</li>
      <li>Assignment of struct values always copies the value.</li>
      <li>No specification-level limit is imposed on maximum size, etc.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>class can have struct fields.</li>
      <li>Assigning a class instance to another variable copies the reference (the underlying object is shared).</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> result in <code>float</code>.
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision base-10 type.</li>
      <li>Expressions mixing <code>int</code> / <code>float</code> may be promoted to <code>decimal</code> as needed.</li>
      <li>Overflow / underflow / precision issues are treated as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Both implicit and explicit conversions between enum and int are forbidden.</li>
      <li>Expressions mixing enum and numeric types are compile-time errors (except bitwise operations for bitfield enums).</li>
      <li>Internally, enum / bitfield enum are always represented as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Arithmetic between bytes is allowed but out-of-range values may cause errors.</li>
          <li>Expressions mixing byte and int are promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic on chars is not allowed.</li>
          <li>Comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are allowed only between chars.</li>
          <li>No implicit conversions to or from numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Overflow / underflow in numeric operations are treated as exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block</li>
      <li>class definition blocks</li>
      <li>method definition blocks</li>
      <li>arbitrary <code>{ ... }</code> blocks</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadows the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>If an inner block declares a variable with the same name, it shadows the outer variable.</li>
      <li>When a field name conflicts with a local variable name, the local variable wins.
        Use <code>this.</code> to refer to the field.</li>
    </ul>

    <h3 id="with-blocks">4.2 with blocks (shorthand for member access)</h3>
    <p>
      Aloe has a <code>with</code> block to make repetitive member access on the same object concise.
    </p>
<pre><code>with (user) {
    .Name = "Alice";
    .Age = .Age + 1;
    print(.Name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated only once at the beginning of the block and stored in an internal temporary variable.</li>
          <li>A special temporary variable <code>_</code> refers to the “with target object”.
            <ul>
              <li>You can pass it around, e.g. <code>log(_);</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>The inner <code>with</code> shadows the resolution of <code>.</code> and the meaning of <code>_</code>.</li>
          <li>You can still access outer objects via their variable names.</li>
        </ul>
      </li>
      <li>Like C#'s <code>using</code>, you can place multiple <code>with</code> targets in a single block:</li>
    </ul>
<pre><code>with (user), (profile) {
    .Name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The resolution order of which object supplies the member is implementation dependent.</li>
      <li>If resolution is ambiguous (multiple objects have the same member), it is a compile-time error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar; semantically, everything can be rewritten
      into explicit <code>obj.Member</code> calls before type checking and code generation.
    </p>
    <p>
      Note that <code>with</code> guarantees only (1) short member access and (2) that the with-target object
      will not be deleted during the block, but it does <strong>not</strong> handle resource management like
      calling <code>Dispose</code>. Resource management is the responsibility of <code>using</code> (see 4.3).
    </p>

    <h4 id="with-type">4.2.1 Type-based with (shortcuts for class / struct / enum static members and enum values)</h4>
    <p>
      In addition to <code>with (expr)</code>, Aloe supports a <strong>type-based</strong> <code>with</code> whose
      target is a type name.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here, <code>TypeName</code> is one of the following:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>In this case, <code>with</code> is interpreted as a “type-context with”:</p>
    <ul>
      <li>The expression inside <code>()</code> is <strong>not</strong> evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; no instance is created.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>The target <code>Member</code> can be:
                <ul>
                  <li>static fields</li>
                  <li>static methods</li>
                  <li>enum / bitfield enum members</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The temporary <code>_</code> behaves as a pseudo-object representing the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members inside a type-based with is a compile-time error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even in a type-based with, local variables and outer-scope variables with the same name take precedence.
      To refer to enum members or static members explicitly, use either <code>TypeName.Member</code> or
      <code>.Member</code> / <code>_.Member</code>.
    </p>

    <h5>Example: static access for class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(a: int, b: int): int {
        if (a &gt; b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = DegToRad(90.0);  // AngleUtil.DegToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = Max(10, 20);       // MathUtil.Max(10, 20)
        print(m);
    }
    return 0;
}
</code></pre>

    <h5>Example: enum member access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      A type-based <code>with</code> can be mixed with other with targets:
    </p>
<pre><code>with (user), (Color) {
    .Name = "Alice"; // user.Name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      Again, the resolution order is implementation dependent; if ambiguous, it must be a compile-time error.
    </p>

    <h3 id="using-blocks">4.3 using blocks (resource management)</h3>
    <p>
      Aloe provides a <code>using</code> block to automate resource cleanup.
      Similar to C#'s <code>using</code> statement, it automatically calls the target object's
      <code>Dispose</code> method when leaving the block.
    </p>
<pre><code>using (file) {
    .WriteLine("Hello, Aloe!");
} // file.Dispose() is implicitly called here
</code></pre>
    <ul>
      <li>Inside <code>using (expr) { ... }</code>:
        <ul>
          <li><code>expr</code> is evaluated only once at the beginning of the block and stored in a hidden local variable.</li>
          <li>Whether the block exits normally or by an exception, <code>Dispose()</code> is always called.</li>
          <li><code>Dispose</code> must be a method with no parameters and return type <code>void</code>, and the target object
              must expose such a method to be usable in <code>using</code>.</li>
        </ul>
      </li>
      <li>You can list multiple resources like in C#:</li>
    </ul>
<pre><code>using (file1), (file2) {
    file1.WriteLine("A");
    file2.WriteLine("B");
} // file2.Dispose() → file1.Dispose() (order is implementation-dependent, but all are called)
</code></pre>
    <ul>
      <li>The order in which <code>Dispose</code> is called for multiple resources is implementation dependent,
          but each target is guaranteed to have <code>Dispose</code> called exactly once.</li>
      <li>The behavior when a target object is <code>delete</code>d inside a <code>using</code> block is undefined;
          it will be explicitly forbidden or defined in a future version.</li>
      <li>While <code>with</code> handles only member access shorthand and lifetime guarantee within the block,
          <code>using</code> is specifically responsible for resource cleanup via <code>Dispose</code>.</li>
    </ul>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The variable type is inferred from the expression on the right-hand side.</li>
      <li><code>var x = 1;</code> is always <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile-time error (type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables cannot be reassigned.</li>
      <li>Type annotations are mandatory for <code>const</code>.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields of class / struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field Count: int = 0;
    field Name: string = "default";

    readonly field Id: int;

    construct(id: int) {
        this.Id = id; // OK: inside the constructor
    }
    method Change(): void {
        this.Count = this.Count + 1; // OK
        // this.Id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … regular field.</li>
      <li><code>readonly field</code> … can only be assigned inside constructors; read-only afterwards.</li>
      <li>Same meaning for both struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name: string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended via <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(x: int, y: int) {
        this.X = x;
        this.Y = y;
    }
}
</code></pre>
    <ul>
      <li>struct is a value type.</li>
      <li>Fields are limited to primitive types and other structs (no reference-type fields).</li>
      <li>struct copying is always by value.</li>
      <li>struct inheritance is not supported (<code>sealed struct</code> is just a “non-extendable” marker).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li>Use <code>implements</code> keyword to implement interfaces.</li>
      <li>Use <code>is</code> operator to check if an object implements an interface.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method Hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying trait with with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.Hello(); // method supplied by Trait_A (if no conflicts)
</code></pre>

    <h4>Non-destructive add / remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj remains unchanged; obj2 has Trait_A
var obj3 = obj2 - Trait_A;     // obj3 is obj2 without Trait_A
</code></pre>

    <h4>Alias with as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.Hello(); // OK

// obj2.Hello(); // NG: members are not flattened; must use alias
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define fields/methods with the same name, it's a compile-time error.</li>
      <li>Traits applied with an alias (<code>as a</code>) are excluded from conflict checks.</li>
      <li>How to treat conflicts between class members and trait members will be defined in a future version.</li>
    </ul>

    <h3>7.6 abstract / virtual / override</h3>
    <p>
      To express polymorphism within an inheritance hierarchy, Aloe uses three keywords:
      <code>abstract</code>, <code>virtual</code>, and <code>override</code>.
    </p>

    <h4>abstract class / abstract method</h4>
<pre><code>abstract class Animal {
    method SayName(): void {
        print("Unknown");
    }

    abstract method Speak(): void; // abstract method without body
}
</code></pre>
    <ul>
      <li>When <code>abstract</code> is placed before <code>class</code>, that class becomes an abstract class.</li>
      <li>Abstract classes cannot be instantiated directly (<code>new Animal()</code> is a compile-time error).</li>
      <li><code>abstract method</code> declares a method without a body (no method block).</li>
      <li>A class with at least one abstract method must be marked <code>abstract class</code>.</li>
    </ul>

<pre><code>class Dog extends Animal {
    override method Speak(): void {
        print("Bowwow");
    }
}
</code></pre>
    <ul>
      <li>Abstract methods must be implemented with <code>override</code> in concrete (non-abstract) classes.</li>
    </ul>

    <h4>virtual method and override</h4>
<pre><code>class BaseLogger {
    virtual method Log(message: string): void {
        print("[Base] " + message);
    }
}

class FileLogger extends BaseLogger {
    override method Log(message: string): void {
        print("[File] " + message);
    }
}
</code></pre>
    <ul>
      <li><code>virtual</code> marks a method that can be overridden in derived classes with <code>override</code>.</li>
      <li><code>virtual</code> methods have a body (unlike abstract methods).</li>
      <li>Overridden methods in derived classes must be marked with <code>override</code>.</li>
      <li>The signature (name, parameters, return type) of an <code>override</code> method must match the base abstract/virtual method.</li>
      <li>Using <code>override</code> without a corresponding base abstract/virtual method is a compile-time error.</li>
    </ul>

    <h4>Call behavior</h4>
<pre><code>BaseLogger logger = new FileLogger();
logger.Log("Hello");  // calls FileLogger.Log based on runtime type (virtual call)

FileLogger fl = new FileLogger();
fl.Log("Hello");      // obviously calls FileLogger.Log
</code></pre>
    <ul>
      <li>virtual / override methods are resolved based on the runtime type, not the static type of the variable.</li>
      <li>To call the base implementation explicitly, a syntax like <code>super.Log(...)</code> (future extension) is assumed.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> is equivalent to <code>obj = null</code> at the VM level.</li>
      <li>You cannot write <code>obj = null;</code> directly in source code.</li>
      <li>Reference types can be null internally, but the type system does not track nullability.</li>
      <li>Accessing null may cause a <code>NullReferenceException</code> at runtime.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks.</li>
      <li>It respects inheritance (Derived is also Base for <code>is</code> checks).</li>
      <li>It can be used for interfaces and traits as well.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Array / List / Set / Map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // map&lt;int&gt; is an alias of map&lt;string/int&gt;
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>The internal representation is always int32.</li>
      <li>Changing the underlying type (e.g. <code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code>) is not allowed.</li>
      <li>Enums can be used as type-based with targets; inside <code>with (Color) { ... }</code> you can access its members via short names like <code>Red</code>.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that member.</li>
      <li><code>bitfield enum</code> can use up to 32 bits (n in 0–31).</li>
      <li>Multiple members may share the same bit; this is only a warning, not an error.</li>
      <li>The underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code> is a compile-time error.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (entry point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.Run();
    return 0; // process exit code
}
</code></pre>
    <ul>
      <li>The entry point of the program.</li>
      <li><code>args</code> is the command-line arguments.</li>
      <li>The <code>main</code> block must be declared as <code>function main(args: string[]): int</code>,
          and must return an <code>int</code> with a <code>return</code> statement.</li>
      <li>There is no special specification for a temporary variable <code>_</code> in <code>main</code>;
          it behaves like a normal variable.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;   // here _ is treated as a normal local variable
    return 0;
}

method Foo(): void {
    var x = 10;
    _ = x + 5;   // the type of _ is the type of the first assigned expression in this block
}
</code></pre>
    <ul>
      <li><code>_</code> can be used in any block without explicit declaration as a special temporary variable.</li>
      <li>In <code>main</code>, <code>_</code> has no special meaning and is treated as a normal variable.</li>
      <li>In blocks other than <code>main</code>, the type of <code>_</code> is determined by the type of the first expression assigned to it in that block.</li>
      <li>Inside a <code>with</code> block, <code>_</code> additionally refers to the current with-target object (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of <code>x</code> and <code>y</code>.</li>
      <li>The compiler checks whether <code>swap</code> is valid at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (higher first)</h3>
    <ol>
      <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Additive: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (has a different meaning in pipeline statements)</li>
      <li>Logical AND: <code>&amp;&amp;</code> (alias: <code>and</code>)</li>
      <li>Logical OR: <code>||</code> (alias: <code>or</code>)</li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignments (like <code>+=</code>) are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
      <li>Parsing / formatting errors are <code>FormatException</code>.</li>
      <li><code>InvalidOperationException</code> is used for invalid operations in the current state
          (for example, property access on <code>Result</code> inconsistent with its state).</li>
      <li>Other fatal VM-level errors are implementation dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> introduces references to other namespaces / symbols.</li>
      <li>Details like file layouts and handling of circular imports are defined in the module specification.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to build streaming processing
      for servers / CLI / web applications.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of T elements.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte stream from stdin, sockets, etc.</li>
      <li><code>pipe&lt;string&gt;</code> … string stream.</li>
      <li>Pipes assume value copying rather than shared mutable memory.</li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3>18.2 Result&lt;T&gt; and an overview of ROP (Railway Oriented Programming)</h3>
    <p>
      In Aloe, error handling and branching in pipelines and filters are handled
      using the <strong>Result&lt;T&gt;</strong> type and the concept of
      <strong>Railway Oriented Programming (ROP)</strong>.
    </p>
    <ul>
      <li><code>Result&lt;T&gt;</code> is a built-in generic type representing either “success (Success = true)” or
          “failure (Success = false)”.</li>
      <li>Filters and pipes typically return <code>Result&lt;T&gt;</code> to explicitly model success/failure.</li>
    </ul>

    <h4>18.2.1 Type specification of Result&lt;T&gt; (overview)</h4>
<pre><code>// Conceptual pseudocode (syntax is still draft)
class Result&lt;T&gt; {
    // State:
    // When Success == true: Value is valid
    // When Success == false: ErrorMessage is valid
    field Success: bool;
    field Value: T;
    field ErrorMessage: string;

    // Factory methods (language built-in)
    static method Ok(value: T): Result&lt;T&gt;;
    static method Error(message: string): Result&lt;T&gt;;
}
</code></pre>
    <ul>
      <li>When <code>Success</code> is <code>true</code>:
        <ul>
          <li><code>Value</code> holds the valid value.</li>
          <li><code>ErrorMessage</code> is an empty string or an implementation-dependent value, but may be read.</li>
        </ul>
      </li>
      <li>When <code>Success</code> is <code>false</code>:
        <ul>
          <li><code>ErrorMessage</code> holds the error message (or part of it).</li>
          <li><code>Value</code> is treated as “no value” and reading it is an invalid operation.</li>
        </ul>
      </li>
      <li>Accessing a property inconsistent with the state (for example, reading <code>Value</code> when
          <code>Success == false</code>) is an invalid operation at runtime and must throw
          <code>InvalidOperationException</code> (the compiler may also detect some such cases statically and
          report them as compile-time errors).</li>
      <li>For <code>Result&lt;void&gt;</code>, a special <code>Result&lt;void&gt;.Ok()</code> factory method without
          arguments is allowed to represent success without a value:
        <ul>
          <li>This still sets <code>Success == true</code>, and <code>ErrorMessage</code> is typically empty.</li>
          <li>Attempting to read <code>Value</code> on <code>Result&lt;void&gt;</code> is always invalid and must
              throw <code>InvalidOperationException</code>.</li>
        </ul>
      </li>
    </ul>
    <p>
      The above is a logical model; actual field names and implementation details may be adjusted in the VM/runtime
      specification. However, the contract that “you must only read properties consistent with the Success flag”
      is guaranteed by the language specification.
    </p>

    <h4>18.2.2 Intuition of ROP (Railway Oriented Programming)</h4>
    <p>
      ROP can be imagined as two parallel tracks, “success track” and “failure track”.
      Each step (filter) returns a <code>Result&lt;T&gt;</code>, and once an error occurs,
      subsequent steps are skipped.
    </p>
<pre><code>Input
  ├─&gt; [ Filter A ] ──&gt; [ Filter B ] ──&gt; [ Filter C ] ──&gt; Output
  │         │               │               │
  │         └─&gt; Error ──────┴───────────────┴───&gt; Error track
  │
  └─&gt; (other branches, logging, etc.)
</code></pre>
    <p>
      Filters in Aloe are designed to limit side effects as much as possible and aim to be
      “quasi-idempotent” in the sense that they return the same output for the same input.
    </p>

    <h4>18.2.3 Exception handling in pipelines</h4>
    <p>
      When an exception is thrown inside a filter or pipe during pipeline execution,
      the pipeline framework automatically catches that exception and treats the corresponding stage's result
      as an <strong>Error</strong> state of <code>Result&lt;T&gt;</code>.
    </p>
    <ul>
      <li>Exceptions are caught by the framework's internal <code>catch</code> blocks.</li>
      <li>The logical return value of that stage is treated as <code>Result&lt;T&gt;.Error(message)</code>.</li>
      <li>The <code>message</code> stored in <code>ErrorMessage</code> is obtained from the caught exception
          (typically the exception's message string).</li>
      <li>This Error state becomes the target of <code>match</code> or <code>is</code>-based branching in subsequent pipeline steps.</li>
      <li>How to treat “fatal” exceptions that the pipeline framework does not catch
          (such as VM internal errors) is VM-implementation dependent.</li>
    </ul>

    <h3>18.3 Basics and definition of filter(...)</h3>
    <p><code>filter(F)</code> is an intermediate transformation stage in a pipeline.</p>

    <h4>18.3.1 Filter definition (filter definition statement)</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // Type for options (optional)
    options: LineSplitOptions;

    // Field definitions (optional, but should be minimal for side-effect reasons)
    field _Buffer: string = "";

    // Constructor (optional)
    constructor(opts: LineSplitOptions) {
        // Initialize according to options, etc.
    }

    // Body that pushes data from input pipe to output pipe
    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.Split("\n");
            foreach (line in lines) {
                output.Write(line);
            }
        }
        output.Close();
        return Result&lt;void&gt;.Ok(); // indicates success
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> specify the types of input / output pipes.</li>
      <li><code>options</code> specifies an option type associated with this filter (typically a <code>bitfield enum</code> etc.).</li>
      <li><code>field</code> can be used to hold filter-internal state, but from an ROP perspective,
          it is recommended to minimize stateful side effects so the filter returns the same output for the same input.</li>
      <li><code>constructor</code> can optionally be defined to initialize the filter with options or external parameters.</li>
      <li><code>bound(input, output): Result&lt;void&gt;</code> is the main execution body of the filter;
          it returns <code>Result&lt;void&gt;.Ok()</code> on success or <code>Result&lt;void&gt;.Error(...)</code> on failure.</li>
    </ul>

    <h4>18.3.2 Filter options (filter option specification)</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Options are specified after <code>:</code>, separated by <code>|</code>.</li>
      <li>Each filter has its own option type (bitfield enum, etc.).</li>
      <li>If a filter definition specifies <code>options: JsonOptions;</code>, then when using that filter in a pipeline,
          you may omit the <code>JsonOptions.</code> prefix and just use the member names:</li>
    </ul>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
    <p>
      This is equivalent to <code>JsonOptions.PrettyPrint | JsonOptions.IncludeNulls</code>, and the compiler verifies
      that these options belong to the class designated in the filter's <code>options</code> clause.
    </p>

    <h3>18.4 Pipeline statements, <code>|</code>, and the pipe-with operator <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li><code>A | B | C;</code> connects A's output to B, and B's output to C.</li>
      <li>Type checks ensure consistency between in/out types of each stage.</li>
      <li>The pipeline statement itself does not return a value (it only sets up the connections).</li>
    </ul>

    <h4>18.4.1 Pipe-with operator <span class="operator">|&gt;</span> (shortcut for filter(if))</h4>
    <p>
      The operator <span class="operator">|&gt;</span> is defined as a shortcut for conditional filtering using
      <code>filter(if)</code>.
    </p>
<pre><code>// Full form
users
    | filter(if : .Age &gt;= 20 and .Gender == Gender.Male);

// Shortcut form (equivalent)
users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>
    <ul>
      <li>The right side of <span class="operator">|&gt;</span> is a condition expression that uses an implicit
          “current element” context (similar to <code>.</code> in <code>with</code>).</li>
      <li>In this example, only “users who are 20 or older and male” pass through the filter.</li>
      <li><span class="operator">|&gt;</span> is internally expanded to <code>filter(if : ...)</code>,
          so an implementation only needs to implement a single filter for <code>if</code>.</li>
    </ul>

    <h3>18.5 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> is internally equivalent to calling <code>p.Next()</code> until EOF.</li>
      <li>When the writer side calls <code>Close()</code>, the reader detects EOF and terminates the loop.</li>
    </ul>

    <h3>18.6 Element transformation with map</h3>
    <p>
      Applying <code>map</code> to a pipe applies a function (or lambda) to each element
      and produces a new stream of (possibly different) type.
    </p>
<pre><code>// map using a function
function ToName(u: User): string {
    return u.Name;
}

var names = users | map(ToName);

// Lambda-like notation (syntax is draft)
var names2 = users | map (u) =&gt; u.Name;
</code></pre>
    <ul>
      <li><code>map</code> is defined as a built-in higher-order operation.</li>
      <li>The result of <code>map</code> is also <code>pipe&lt;T&gt;</code> and can be connected to further filters.</li>
    </ul>

    <h3>18.7 Template map over collection pipes</h3>
    <p>
      A template-style <code>map</code> can be used on collections (e.g. <code>User()</code>, <code>User{}</code>).
    </p>
<pre><code>users as u | map Customer {
    Name    = u.Name,
    Address = u.Address
}
</code></pre>
    <ul>
      <li><code>as u</code> introduces an alias for each element.</li>
      <li><code>map Customer { ... }</code> is treated as creating a new <code>Customer</code> object,
          with field assignments inside the block specifying the mapping.</li>
      <li>The result is a collection of the same kind (e.g. <code>Customer()</code>) as the original collection.</li>
    </ul>

    <h3>18.8 close and EOF propagation</h3>
    <ul>
      <li>Calling <code>Write()</code> on a pipe after <code>Close()</code> is invalid and may cause an error.</li>
      <li>Filters must call <code>Close()</code> on the output when they detect EOF on the input.</li>
    </ul>

    <h3>18.9 Concurrency model with pipes</h3>
    <ul>
      <li>Pipes (<code>pipe&lt;T&gt;</code>) are the primary communication mechanism between tasks.</li>
      <li>A shared-nothing model is assumed; shared mutable data structures are discouraged.</li>
    </ul>

    <h3>18.10 Branching for pipelines using match (branching over Result&lt;T&gt;)</h3>
    <p>
      For pipes and filters returning <code>Result&lt;T&gt;</code>, you can use <code>match</code> to branch.
    </p>
<pre><code>stdin
    | filter(parseUser)
    | match {
        case Ok(u):
            // success pipeline
            | filter(saveUser)
            | filter(logSuccess);
        case Error(e):
            // error pipeline
            | filter(logError);
        default:
            // in case nothing matches (reserved for future use)
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... }</code> branches on the <code>Result&lt;T&gt;</code> produced by the previous stage.</li>
      <li>Immediately after <code>case pattern:</code>, you can continue writing a pipeline such as <code>| filter(...)</code>.</li>
      <li><code>default:</code> is optional and acts as a fallback when no <code>case</code> matches.</li>
    </ul>
<pre><code>| match {
    case condition1:
        | filter(handleCase1);
    case condition2:
        | filter(handleCase2);
    default:
        | filter(handleDefault);
}
</code></pre>
    <p>
      The condition part may use <code>is</code> or Result patterns like <code>Ok(...)</code>, <code>Error(...)</code>.
    </p>

    <h3>18.11 Example: Simple REST-like pipeline</h3>
<pre><code>class User {
    field Id: int;
    field Name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.Create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.Next();
    if (u is User) {
        print("User: " + u.Name);
    }

    return 0;
}
</code></pre>
    <p class="note">
      <strong>Editing policy memo:</strong><br>
      • This document is based on the English spec, and the content (structure and meaning) of the English and Japanese versions must always match.<br>
      • <code>edit-version</code> is shared across English and Japanese versions and is incremented only when the content of the Japanese/English specification changes (never decremented).<br>
      • <code>edit-date</code> records the timestamp (YYYY-MM-DD hh:mm:ss) when each version was output.<br>
      • Do not change unrelated parts. Even if something “looks nicer”, do not change wording or variable names arbitrarily if the meaning is the same.<br>
      • If you feel “this other place should also be fixed”, stop editing, consult the user, and then reflect the changes.<br>
      • Always treat the last full HTML that was output as the “correct” baseline, and restrict subsequent edits to the minimal necessary diff against that baseline.<br>
      • If the previous HTML (the latest “correct” version) can no longer be seen or reconstructed, stop editing and consult the user first.<br>
    </p>

  </main>
</div>
</body>
</html>
