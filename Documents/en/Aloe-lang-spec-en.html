```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English)</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • English version + with / ROP extensions</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
        <li><a href="#result-type">18.3 Result&lt;T&gt; &amp; ROP</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English)</h1>
    <p class="note">
      This document is an English draft of the Aloe language specification,
      based on the original English spec at
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>.<br>
      On top of that, it adds <strong>type-based with blocks</strong> and
      a <strong>Result&lt;T&gt;-based Railway Oriented Programming (ROP) style pipeline</strong>.<br>
      Other parts try to stay as close as possible to the original specification.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language with simple, intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and has the following main goals:
    </p>
    <ul>
      <li>Easy to read and write for education and small applications</li>
      <li>Runs both on a C# runtime and in WebAssembly (WASM) environments</li>
      <li>Controls I/O and concurrency in a statically typed way using <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Characteristics:</p>
    <ul>
      <li>Static typing
        <ul>
          <li>Type inference via <code>var</code></li>
          <li>Explicit type annotation via <code>let</code></li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> … value type</li>
          <li><code>class</code> … reference type</li>
        </ul>
      </li>
      <li>GC-based memory management (actual algorithm is VM-implementation dependent)</li>
      <li>No direct <code>= null</code> in source code
        <ul>
          <li>Reference types may internally be null, but source code uses <code>delete</code> as syntactic sugar.</li>
        </ul>
      </li>
      <li>Dataflow-style design centered around <code>pipe</code> / <code>filter</code></li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> to end of line is a line comment.</li>
      <li><code>/*</code> to <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assumed not supported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
      <li>First character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Cannot use the same spelling as a keyword.</li>
      <li>Identifiers starting with <code>_</code> are treated as “private” by convention.</li>
      <li>Unicode letters may be used (excluding whitespace and separators).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
    <ul>
      <li>Use <code>namespace</code> instead of <code>package</code>.</li>
      <li><code>final</code> is removed; use <code>sealed</code> to forbid inheritance.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checks.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>Floating literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code>, etc.</li>
      <li>Decimal literals: <code>10.12345678901234567890:d</code> etc.</li>
      <li>Booleans: <code>true</code>, <code>false</code></li>
      <li>Strings: <code>"Hello, World!"</code></li>
      <li>Chars: <code>'A'</code>, <code>'z'</code>, etc.</li>
      <li>Null literal: <code>null</code></li>
      <li>Array literals: <code>[1, 2, 3]</code></li>
      <li>List literals: <code>(1, 2, 3)</code></li>
      <li>Set literals: <code>{1, 2, 3}</code></li>
      <li>Map literals: <code>["key1": 10, "key2": 20]</code></li>
      <li>enum literals: <code>EnumType.Value1</code></li>
      <li>struct literals: <code>Point { X: 0, Y: 1 }</code></li>
      <li>Object construction: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>Every statement ends with a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines are treated as token separators.</li>
      <li>Multiple consecutive whitespace characters are treated as a single separator.</li>
      <li>Indentation has no semantic meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe defines the following seven primitive types:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – Boolean values.</li>
      <li><code>int</code> / <code>integer</code> – signed integers.</li>
      <li><code>float</code> – floating point numbers.</li>
      <li><code>decimal</code> – high-precision decimal numbers.</li>
      <li><code>string</code> – character strings (internally Unicode).</li>
      <li><code>null</code> – special “no value” type/value.</li>
      <li><code>void</code> – used only as a method return type.</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported as language types, but
      are treated separately from “primitive types” and described in Chapter 3.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Async task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see Chapter 18)</li>
    </ul>
    <p>There is no <code>any</code> type; dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implemented as a reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Struct fields may only be primitive types or other structs.</li>
      <li>Structs may not have reference type fields (such as classes).</li>
      <li>Assignment of structs always copies the value.</li>
      <li>No explicit size limit is specified at the language level.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>Classes can have struct fields.</li>
      <li>Assigning a class instance to another variable copies the reference; the object itself is shared.</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> result in <code>float</code>.
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision decimal number type.</li>
      <li>Expressions mixing <code>decimal</code> with <code>int</code> / <code>float</code>
        may be promoted to <code>decimal</code> when necessary.</li>
      <li>Overflow / underflow / precision issues are treated as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Implicit or explicit conversion between enum and int is forbidden.</li>
      <li>Expressions mixing enum and numeric types are compile errors
        (except bit operations on bitfield enums).</li>
      <li>Internally, both enum and bitfield enum are represented as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Arithmetic between bytes is allowed, but out-of-range results may be errors.</li>
          <li>Expressions mixing byte and int are promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic on chars is forbidden.</li>
          <li>Comparisons (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are allowed only between chars.</li>
          <li>No implicit conversion to numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow is treated as an exception, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block (<code>function main(...)</code>)</li>
      <li>Class definition blocks</li>
      <li>Method definition blocks</li>
      <li>Arbitrary <code>{ ... }</code> blocks</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field Value: int = 1;
    method Foo(): void {
        var Value = 2;        // shadows the field
        print(Value);         // 2
        print(this.Value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe has static (lexical) scoping.</li>
      <li>Declaring a variable with the same name in an inner block shadows the outer one.</li>
      <li>If a field name and a local variable name conflict, the local variable wins.
        Fields can be accessed as <code>this.Field</code>.</li>
    </ul>

    <h3 id="with-blocks">4.2 with blocks (member access shorthand)</h3>
    <p>
      Aloe provides <code>with</code> blocks to write repeated member accesses to the same object concisely.
    </p>
<pre><code>with (user) {
    .Name = "Alice";
    .Age = .Age + 1;
    print(.Name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated exactly once at the beginning and stored
              in an internal temporary variable.</li>
          <li>Special temporary variable <code>_</code> refers to the “with target object”.
            <ul>
              <li>You can pass it around, e.g., <code>Log(_);</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>An inner <code>with</code> shadows <code>.</code> resolution and <code>_</code> from outer blocks.</li>
          <li>You can still access outer objects through their normal variable names.</li>
        </ul>
      </li>
      <li>Multiple <code>with</code> targets are allowed, similar to C#’s <code>using</code> style:
    </ul>
<pre><code>with (user), (profile) {
    .Name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The order in which objects are considered for member resolution is implementation-dependent.</li>
      <li>However, if resolution is ambiguous (multiple objects have the same member), it is a compile-time error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar. Semantically, you can think of
      transforming everything into explicit <code>obj.Member</code> accesses
      and then doing type checking and code generation.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enum member shortcuts)</h4>
    <p>
      In addition to <code>with (expr)</code>, Aloe allows <code>with</code> blocks
      whose target is a <strong>type name</strong>.
    </p>
<pre><code>with (AngleUtil) {
    .DegToRad(90.0);
    .Pi = 3.14159;
}
</code></pre>
    <p>Here <code>TypeName</code> can be:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>In this case, <code>with</code> is interpreted as a “type-context with”:</p>
    <ul>
      <li>The expression inside <code>()</code> is not evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; no instance is created.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>Allowed members:
                <ul>
                  <li>static fields</li>
                  <li>static methods</li>
                  <li>enum / bitfield enum members</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Temporary <code>_</code> behaves like a pseudo-object representing
              the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members in a type-based with is a compile-time error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even with type-based <code>with</code>, if there is a local or outer-scope variable
      with the same name, it takes precedence. If you want to refer explicitly
      to enum members or static members, use <code>TypeName.Member</code> or <code>.Member</code> / <code>_.Member</code>.
    </p>

    <h5>Example: static access on class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = DegToRad(90.0);  // AngleUtil.DegToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = Max(10, 20);       // MathUtil.Max(10, 20)
        print(m);
    }

    return 0;
}
</code></pre>

    <h5>Example: enum member access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        let c1: Color = Red;   // Color.Red
        let c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      Type-based <code>with</code> can also be mixed with multiple targets:
    </p>
<pre><code>with (user), (Color) {
    .Name = "Alice"; // user.Name
    let c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      Resolution order is still implementation-dependent, but ambiguity must be
      reported as a compile-time error.
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>Type of a variable is inferred from the right-hand expression.</li>
      <li><code>var x = 1;</code> always gives type <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile-time error (type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li>Variables declared with <code>const</code> cannot be reassigned.</li>
      <li>Const variables must have an explicit type annotation.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields of classes / structs are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field Count: int = 0;
    field Name: string = "default";

    readonly field Id: int;

    construct(Id: int) {
        this.Id = Id; // OK: inside the constructor
    }
    method Change(): void {
        this.Count = this.Count + 1; // OK
        // this.Id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … normal field.</li>
      <li><code>readonly field</code> … may only be assigned in the constructor, read-only afterwards.</li>
      <li>Same semantics for both struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name: string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>A class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended with <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(X: int, Y: int) {
        this.X = X;
        this.Y = Y;
    }
}
</code></pre>
    <ul>
      <li>A struct is a value type.</li>
      <li>Fields must be primitive types or other structs (reference type fields are forbidden).</li>
      <li>Assigning a struct always copies the value.</li>
      <li>Struct inheritance is not supported (<code>sealed struct</code> acts as a “no extension” marker only).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li>Use <code>implements</code> to implement interfaces.</li>
      <li>The <code>is</code> operator checks whether a value implements an interface.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method Hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>7.5.1 Applying traits with with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.Hello(); // method from Trait_A (if there are no conflicts)
</code></pre>

    <h4>7.5.2 Non-destructive add/remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj unchanged; obj2 has Trait_A
var obj3 = obj2 - Trait_A;     // obj3 is obj2 without Trait_A
</code></pre>

    <h4>7.5.3 Alias application with as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.Hello(); // OK: access Trait_A members via alias a

// obj2.Hello(); // NG: alias only; no flat member injection
</code></pre>

    <h4>7.5.4 Trait conflicts</h4>
    <ul>
      <li>If multiple traits define the same field / method name, it is a compile-time error.</li>
      <li>Applications using <code>as a</code> aliases are exempt from conflict checks.</li>
      <li>Behavior for conflicts between class body members and trait members will be specified in a future version.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> is equivalent to <code>obj = null</code> at the VM level.</li>
      <li>Writing <code>obj = null;</code> directly in source is not allowed.</li>
      <li>Reference types may internally be null, but the type system does not track nullability.</li>
      <li>Accessing a null reference may cause <code>NullReferenceException</code>.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks.</li>
      <li>Inheritance is considered (Derived is also a Base).</li>
      <li><code>is</code> also works for interfaces and traits.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Array / List / Set / Map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // default key type is string
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>Internal representation is always int32.</li>
      <li>Changing the underlying type, such as <code>enum&lt;byte&gt;</code> or <code>enum&lt;string&gt;</code>,
        is not allowed.</li>
      <li>Enums can be used in type-based <code>with</code>, e.g., <code>with (Color) { Red; }</code>
        to access members concisely.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that enum member.</li>
      <li><code>bitfield enum</code> may use at most 32 bits (n is 0–31).</li>
      <li>Sharing the same bit among multiple members is allowed but may generate a warning.</li>
      <li>The underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code> etc. are compile errors.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (entry point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.Run();
    return 0; // process exit code (int)
}
</code></pre>
    <ul>
      <li>The program entry point.</li>
      <li><code>args</code> holds the command-line arguments.</li>
      <li><code>main</code> must return <code>int</code>, and a <code>return</code> statement
        specifies the process exit code.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>method Foo(): void {
    var x = 10;
    _ = x + 5;   // a temporary variable used only in this block
}
</code></pre>
    <ul>
      <li><code>_</code> is a special temporary variable that can be used without declaration in any block.</li>
      <li>Each block has its own <code>_</code>; its type is determined by the first assignment in that block.</li>
      <li>In <code>main</code>, <code>_</code> is just a normal temporary (the exit code is determined by <code>return</code>).</li>
      <li>Inside <code>with</code> blocks, <code>_</code> additionally refers to the current with target object (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of <code>x</code> and <code>y</code>.</li>
      <li>Whether <code>swap</code> is allowed is checked at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (higher to lower)</h3>
    <ol>
      <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiply/divide: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Add/subtract: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (distinct from pipeline <code>|</code> syntax)</li>
      <li>Logical AND: <code>&amp;&amp;</code></li>
      <li>Logical OR: <code>||</code></li>
      <li>Pipeline operators: <code>|</code>, <code>|&gt;</code>
        <ul>
          <li>These are used only in pipeline statements and are parsed at the syntax level,
              separately from normal expression precedence.</li>
        </ul>
      </li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignment operators (<code>+=</code>, etc.) are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
      <li>Pipeline statements like <code>A | B | C</code> are interpreted as left-associative
        (see Chapter 18 for details).</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
      <li>Parsing / formatting errors use <code>FormatException</code>.</li>
      <li>Other fatal VM-level errors are implementation-dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> brings other namespaces / symbols into scope.</li>
      <li>Details like file layout and circular imports are specified by a separate module system spec.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to build streaming
      pipelines for servers, CLI tools, web applications, etc.
      This chapter also describes a <code>Result&lt;T&gt;</code>-based
      Railway Oriented Programming (ROP) style model.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of elements of type <code>T</code>.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte stream, e.g., stdin or sockets.</li>
      <li><code>pipe&lt;string&gt;</code> … string stream.</li>
      <li>Pipes are designed around value copy, not shared mutable memory.</li>
      <li>Pipes are created via static members of <code>pipe&lt;T&gt;</code>:
<pre><code>let p: pipe&lt;int&gt; = pipe&lt;int&gt;.create();
</code></pre>
      </li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3 id="result-type">18.3 Result&lt;T&gt; and Railway Oriented Programming (ROP)</h3>
    <p>
      Aloe encourages using <code>Result&lt;T&gt;</code> to represent failure as a value
      rather than exceptions in pipelines.
    </p>
    <h4>18.3.1 Semantics of Result&lt;T&gt;</h4>
    <ul>
      <li><code>Result&lt;T&gt;</code> is a container that is either “success” or “failure”.</li>
      <li>Conceptually:
<pre><code>// Pseudo-structure (actual definition is part of the standard library)
struct Result&lt;T&gt; {
    field IsOk: bool;
    field Value: T;              // valid when IsOk == true
    field Error: Exception;      // valid when IsOk == false
}
</code></pre>
      </li>
      <li>Helpers like <code>Result.Ok(value)</code> and <code>Result.Error(error)</code>
        are assumed to be provided by the standard library.</li>
    </ul>

    <h4>18.3.2 Railway Oriented Programming (ROP) image</h4>
    <p>
      In ROP, the “success track” and “failure track” are separated.
      A filter takes a <code>Result&lt;T&gt;</code>, and if it is success, it continues to the next step;
      if it is failure, it flows along the failure track.
    </p>
<pre><code>Input
  ──&gt; [ Validate ] ──&gt; [ Transform ] ──&gt; [ Save ] ──&gt; Result&lt;Ok&gt;
           │                │                │
           └─× Error        └─× Error        └─× Error
           (once it fails, Result&lt;Error&gt; keeps flowing right)
</code></pre>
    <p>
      ROP-style filters should, as far as possible, be referentially transparent:
      for a given input <code>Result</code>, they always return the same output <code>Result</code>
      and avoid side effects.
    </p>

    <h3>18.2 Basics of filter(...)</h3>
    <p><code>filter(F)</code> represents an intermediate transformation stage in a pipeline.</p>

    <h4>18.2.1 Filter definition</h4>
<pre><code>filter LineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // Option class (see 18.2.2)
    options: LineSplitOptions;

    // Filters may have fields (but see the ROP note below)
    field Separator: string = "\n";

    construct(sep: string) {
        this.Separator = sep;
    }

    bound(input: pipe&lt;string&gt;, output: pipe&lt;string&gt;): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split(this.Separator);
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Result.Ok();   // success
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> specify the input pipe type and output pipe type.</li>
      <li><code>options</code> specifies the option class this filter accepts.</li>
      <li><code>field</code> allows a filter to hold internal state.
        However, from an ROP (Railway Oriented Programming) standpoint,
        stateful filters may break idempotency and referential transparency,
        so having fields is <strong>not recommended</strong>.
        Whenever possible, pass state via arguments, Result, or options instead.</li>
      <li><code>construct(...)</code> defines a constructor, which is called when the filter is instantiated.</li>
      <li><code>bound(input, output)</code> is the main body of the filter and returns <code>Result&lt;T&gt;</code>
        (here <code>Result&lt;void&gt;</code>).
        By returning a Result instead of throwing exceptions, the entire pipeline can be built in ROP style.</li>
    </ul>

    <h4>18.2.2 Filter options</h4>
<pre><code>bitfield enum JsonOptions {
    None        : b(0),
    PrettyPrint : b(1),
    IncludeNulls: b(2),
}
</code></pre>
    <p>
      Options are specified after <code>filter(json&lt;User&gt;: ...)</code> using <code>:</code>
      followed by values joined with <code>|</code>.
    </p>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Each filter typically defines its own option type (often a bitfield enum).</li>
      <li>Inside a filter definition:
<pre><code>filter JsonSerializer {
    in:  pipe&lt;User&gt;;
    out: pipe&lt;string&gt;;

    options: JsonOptions; // specify option class
    ...
}
</code></pre>
        If <code>options: JsonOptions;</code> is declared, the calling side can omit
        the class name when specifying options:
<pre><code>// Because the filter declares options: JsonOptions;
// you can omit the JsonOptions. prefix:
filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
      </li>
      <li>If a different option class is needed, specify it explicitly using <code>options</code> in the filter definition.</li>
    </ul>

    <h3>18.4 Pipeline statements with <code>|</code> / pipeline-with operator <code>|&gt;</code></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li><code>A | B | C;</code> connects the output of A to B, and B to C.</li>
      <li>Type checking ensures that the input/output types of each stage match.</li>
      <li>The pipeline statement itself does not return a value; it only creates connections as a side effect.</li>
    </ul>
    <p>
      The pipeline-with operator <code>|&gt;</code> is reserved for future extensions,
      such as feeding the same input into multiple branches. In this draft,
      only the syntax is reserved; semantics will be defined in a separate ROP extension spec.
    </p>

    <h3>18.5 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> conceptually calls <code>p.next()</code> until EOF.</li>
      <li>When the writer calls <code>close()</code>, readers detect EOF and terminate the loop.</li>
    </ul>

    <h3>18.6 map for element-wise pipe transformation</h3>
    <p>
      Aloe’s pipes support a built-in <code>map</code> operation that applies a function
      to each element (conceptually):
    </p>
<pre><code>// Conceptual signature
method pipe&lt;T&gt;.map&lt;U&gt;(f: T -&gt; U): pipe&lt;U&gt;
</code></pre>
    <p>Example usage:</p>
<pre><code>stdin
    | filter(utf8)
    | map (s: string -&gt; s.trim())      // trim whitespace
    | map (s: string -&gt; s.toUpper())   // to upper-case
    | filter(lineSink);
</code></pre>
    <ul>
      <li><code>map</code> may be implemented as a kind of filter or as a method on <code>pipe&lt;T&gt;</code>
        (implementation-dependent).</li>
      <li>When combined with ROP, you typically pass a function of type
        <code>Result&lt;T&gt; -&gt; Result&lt;U&gt;</code>, so failures stay on the track
        without being dropped.</li>
    </ul>

    <h4>18.6.1 Template-style map for collection pipes</h4>
    <p>
      For pipes whose elements are objects, Aloe can express a template syntax
      to build a collection of another type.
    </p>
<pre><code>// Transform users: pipe&lt;User&gt; into a sequence of Customer
users as u | map Customer {
    Name    = u.Name,
    Address = u.Address
}
</code></pre>
    <ul>
      <li><code>users as u</code> introduces <code>u</code> as an alias for each element.</li>
      <li><code>map Customer { ... }</code> constructs a new <code>Customer</code> object
        and creates a new pipe / collection of these.</li>
      <li>This is syntactic sugar; an implementation may translate it into
        something like <code>map (u -&gt; new Customer { ... })</code>.</li>
    </ul>

    <h3>18.8 Branching with match (Result&lt;T&gt;)</h3>
    <p>
      In ROP style, <code>Result&lt;T&gt;</code> pipelines can branch based on success,
      failure, or other conditions using the <code>match</code> syntax.
    </p>
    <h4>18.8.1 Basic match syntax</h4>
<pre><code>| match {
    case condition1:
        break;
    case condition2:
        break;
    default:
        break;
}
</code></pre>
    <ul>
      <li><code>| match { ... }</code> branches based on the result of the preceding pipeline.</li>
      <li>Conditions after <code>case</code> may use patterns/predicates assuming
        a <code>Result&lt;T&gt;</code> (e.g., <code>result.IsOk</code>).</li>
      <li><code>break;</code> terminates that branch of the pipeline.</li>
      <li><code>default:</code> is executed when no <code>case</code> matches.</li>
    </ul>

    <h4>18.8.2 Attaching downstream pipelines to case branches</h4>
    <p>
      Inside a <code>case</code> block you can attach further pipelines.
    </p>
<pre><code>stdin
    | filter(utf8)
    | filter(ParseUser)            // returns Result&lt;User&gt;
    | match {
        case result.IsOk:
            | filter(HandleUser)   // only for successful results
        case result.IsOk == false:
            | filter(HandleError)  // only for failures
        default:
            break;
    };
</code></pre>
    <ul>
      <li>The <code>| filter(...)</code> inside each <code>case</code> is treated as
        a branch that receives only data matching that condition.</li>
      <li>Formally, the syntax is:
<pre><code>case condition:
    | ...;
</code></pre>
        Details of type checking and evaluation order are defined by
        the VM / compiler specification.</li>
    </ul>

    <h3>18.6 Using pipes for concurrency</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is the main communication channel between tasks.</li>
      <li>Aloe assumes a shared-nothing model and discourages shared mutable data structures.</li>
    </ul>

    <h3>18.7 Example: simple ROP-style validation pipeline</h3>
<pre><code>filter ValidateUser {
    in:  pipe&lt;User&gt;;
    out: pipe&lt;Result&lt;User&gt;&gt;;

    bound(input: pipe&lt;User&gt;, output: pipe&lt;Result&lt;User&gt;&gt;): Result&lt;void&gt; {
        foreach (u in input) {
            if (u.Name == "") {
                output.write(Result.Error(new ArgumentException("Name is empty")));
            }
            else {
                output.write(Result.Ok(u));
            }
        }
        output.close();
        return Result.Ok();
    }
}

filter SaveUser {
    in:  pipe&lt;Result&lt;User&gt;&gt;;
    out: pipe&lt;Result&lt;User&gt;&gt;;

    bound(input: pipe&lt;Result&lt;User&gt;&gt;, output: pipe&lt;Result&lt;User&gt;&gt;): Result&lt;void&gt; {
        foreach (r in input) {
            if (r.IsOk) {
                // save to DB, etc.
                output.write(r);
            }
            else {
                // propagate failure unchanged
                output.write(r);
            }
        }
        output.close();
        return Result.Ok();
    }
}
</code></pre>

    <h3>18.10 Example: simple REST-like pipeline</h3>
<pre><code>class User {
    field Id: int;
    field Name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.Name);
    }

    return 0;
}
</code></pre>
    <p class="note">
      Built-in filters such as <code>utf8</code> and <code>json&lt;T&gt;</code>
      are defined in a separate “standard filter library” specification, not in this core language spec.
    </p>

    <hr>
    <p class="note">
      This concludes the Aloe Language Specification (Draft, English) with
      type-based <code>with</code>, Result&lt;T&gt; / ROP, <code>match</code>, <code>map</code>, and related extensions.
      The intention is to match the current Japanese draft in content while using English wording.
    </p>

  </main>
</div>
</body>
</html>
```
