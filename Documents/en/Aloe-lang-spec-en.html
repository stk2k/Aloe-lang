
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – pipe/filter/producer/consumer + delete/with/lock/class inheritance/generics/event)</title>
  <meta name="last-updated" content="2025-11-30T13:00:00+09:00" />
  <style>
    /* Minimal layout; leave fonts to browser defaults */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / Pipe, Filter, Producer, Consumer + delete/with/lock/class inheritance/generics/event</div>
    <div class="updated">Last updated: 2025-11-30 13:00:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#functions-methods">5. Methods and Functions</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-Related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>

      <div class="section-title">Syntactic Extensions</div>
      <a href="#with">7. with Statement</a>
      <a href="#delete">8. delete Statement</a>
      <a href="#lock">9. lock Statement and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model and Memory Management</a>

      <div class="section-title">Events</div>
      <a href="#event">13. event Syntax and Event Model</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Directions</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing, a simple syntax,
        and a stack-based virtual machine (AloeVM).
        It is designed with a strong focus on <strong>pipe / filter style data flow</strong>
        and interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type checking is performed at compile time).</li>
        <li>Syntax looks C-like, but the feature set is intentionally kept small.</li>
        <li>Emphasis on writing <br />“flows and transformations of data”
          comfortably for tasks like text processing, REST calls, and logging.</li>
        <li>Assumes a stack-based VM (AloeVM) and a future WebAssembly backend.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft of the language specification</strong>.<br />
        There may be differences from the actual compiler / VM implementation.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: the specification itself should be pleasant to read as documentation.</li>
        <li><strong>Ease of implementation</strong>: implementable with a small compiler and VM.</li>
        <li><strong>Consistency of pipe / filter</strong>: type-safe representation of data flow.</li>
        <li><strong>Bridge to Wasm</strong>: easy to connect to future WebAssembly component models.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Becoming an “everything is possible” general-purpose language.</li>
        <li>Competing in performance with highly optimized JIT compilers.</li>
        <li>Complex metaprogramming (macros, etc.) is out of scope for now.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source files</h3>
      <ul>
        <li>Source files are assumed to be UTF-8 encoded.</li>
        <li>Single-line comment: <code>// comment</code></li>
        <li>Multi-line comment: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifiers: first character is a letter or <code>_</code>, followed by letters, digits, or <code>_</code>.</li>
        <li>Keywords are reserved words and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td>
        </tr>
        <tr>
          <td>Functions</td>
          <td><code>method</code></td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are delimited by <code>{ ... }</code>.</li>
        <li>Conditions in control structures must have type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation-dependent; assume 32 bits here).</td></tr>
        <tr><td><code>Float</code></td><td>Floating point value (32 or 64 bits, implementation-dependent).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-dependent).</td></tr>
      </table>

      <h3>4.2 Arrays and collections</h3>
      <ul>
        <li>Fixed-length array: <code>T[]</code></li>
        <li>Variable-length, lazily evaluated sequences are represented by <code>Pipe&lt;T&gt;</code> (see Section 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignment performs a value copy.</li>
        <li>The copy is shallow; sharing of nested reference-type fields is VM-dependent.</li>
        <li>A <code>struct</code> may inherit from at most one other struct (single inheritance for structs).</li>
        <li>A <code>struct</code> is <strong>not allowed</strong> to implement an <code>interface</code>.
          (How it interacts with traits and generic constraints will be specified later.)
        </li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as an <strong><code>Int</code></strong>.</li>
        <li>“Generic enums” such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are
          <strong>forbidden</strong>.
        </li>
        <li>Enums intended for bit flags are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed)</h2>

      <h3>4.5.1 Basics of classes</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignment performs a <strong>copy of the reference (shallow copy)</strong>.</li>
        <li>The <code>clone</code> keyword creates a shallow copy of an object and returns a new reference.</li>
        <li>All classes are considered <strong>cloneable</strong>. There is no language-level mechanism
          to declare a class “non-cloneable”.<br />
          If cloning needs to be discouraged, this should be expressed by API design or coding guidelines.
        </li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // Reference copy (A and B refer to the same instance)

var C: User = clone A;  // Returns a new instance which is a shallow copy of A</code></pre>

      <p class="note">
        A <strong>shallow copy</strong> means that field values are copied as-is.<br />
        If a field itself is a reference type, that reference value is copied.
        Types that require deep copies or custom cloning logic can provide user-defined APIs such as
        a <code>Clone</code> method on top of <code>clone</code>.
      </p>

      <h3>4.5.2 Common base class Object, ToString, and Dump</h3>
      <p>
        Conceptually, all <code>class</code> types in Aloe implicitly inherit from a common base class
        <code>Object</code>. This base class defines the following methods:
      </p>
      <pre><code>class Object {
  method ToString(): String { ... }
  method Dump(): String { ... }
}</code></pre>
      <ul>
        <li><code>ToString()</code> returns a human-oriented textual representation, suitable for
          displaying to end users or for simple logging.</li>
        <li><code>Dump()</code> returns a more detailed textual representation for debugging,
          including internal state as appropriate.</li>
        <li>Every user-defined class implicitly inherits <code>ToString()</code> and <code>Dump()</code>
          from <code>Object</code> and may override them:
        </li>
      </ul>
      <pre><code>class User {
  Name: String;
  Age: Int;

  method ToString(): String {
    return "User(" + Name + ")";
  }

  method Dump(): String {
    return "User { Name = " + Name + ", Age = " + Age.ToString() + " }";
  }
}</code></pre>
      <p class="note">
        Value types (<code>struct</code> / <code>enum</code>) may also have standard library support
        to generate <code>ToString</code> / <code>Dump</code>-like behavior, but the language-level rule
        is that all <strong>class</strong> types share the common base class <code>Object</code> and inherit
        its default implementations.
      </p>

      <h3>4.5.3 Class inheritance (single inheritance)</h3>
      <p>
        In Aloe, a <code>class</code> supports <strong>single inheritance</strong> only.<br />
        That is, a class can specify exactly one base class.
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// The following is a compile error (multiple inheritance of classes is forbidden)
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>Class hierarchies are trees (or chains); diamond inheritance does not occur.</li>
        <li>Class inheritance is a mechanism for reusing state and behavior.</li>
      </ul>

      <h3>4.5.4 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance of classes, Aloe uses
        <strong>interface</strong> and <strong>trait</strong> to compose behavior.
      </p>

      <ul>
        <li><code>interface</code> defines method signatures but has no implementation
          (whether default implementations are allowed is a future design topic).</li>
        <li><code>trait</code> is a mixin unit that can contain method implementations and is used
          to add behavior to existing classes.</li>
        <li>A class has <strong>one base class</strong>, can implement multiple <code>interface</code>s,
          and can apply multiple <code>trait</code>s via <code>with</code>.
        </li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose();
}

trait Printable {
  method PrintSelf() {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose() {
    // Resource releasing logic
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        The detailed syntax and rules for <code>interface</code> and <code>trait</code>
        (inheritance among them, conflict resolution when multiple traits define the same method, etc.)
        are not fully specified in this draft. Only the general direction is outlined here.
      </p>

      <h3>4.5.5 sealed classes</h3>
      <p>
        To prohibit inheritance from a specific class, Aloe provides the <code>sealed</code> modifier.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// Compile error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li>A <code>sealed class</code> cannot be used as a base class.</li>
        <li>Even if a class is <code>sealed</code>, it may still implement interfaces and apply traits via <code>with</code>.</li>
        <li>In the future, we may combine sealed classes with union types and pattern matching
          to support exhaustiveness checking.</li>
      </ul>

      <h3>4.5.6 readonly and classes</h3>
      <ul>
        <li>Fields of a class are mutable by default.</li>
        <li>A field marked with <code>readonly</code> becomes immutable:
          <ul>
            <li>Assignment to that field is only allowed in
              <strong>field initializers</strong> or
              <strong>within constructors of the same class</strong>.
            </li>
            <li>Any other write to that field is a compile-time error.</li>
          </ul>
        </li>
        <li><code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are implicitly treated as <code>readonly</code>.</li>
            <li>Assignment to fields is only allowed in field initializers and
              constructors of that class.</li>
            <li>After the constructor completes, no code is allowed to modify
              fields of that instance.</li>
          </ul>
        </li>
        <li><code>readonly</code> and <code>clone</code> are orthogonal:
          even a <code>readonly class</code> can be cloned.
          The clone result is another instance with the same immutable state.</li>
      </ul>

      <p class="small">
        This section defines a high-level policy in which:
        classes are heap-based reference types with single inheritance;
        multiple behaviors are composed with interface + trait;
        <code>sealed</code> expresses non-inheritable classes; and
        <code>readonly</code> expresses immutability at the field or class level.<br />
        Details such as method resolution order and trait conflict resolution
        are to be specified separately.
      </p>
    </section>

    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, functions, methods,
        and pipe-related declarations.<br />
        The purpose is to enable type-safe reuse of collections and pipe/filter constructs,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // Implementation omitted
}</code></pre>

      <h3>4.6.2 Generic type parameters</h3>
      <ul>
        <li>Types, structs, classes, interfaces, traits, methods, and
          producer/filter/consumer declarations may take type parameters with <code>&lt;T, U, ...&gt;</code>.
        </li>
        <li>Type parameter names are recommended to start with uppercase
          (e.g., <code>T</code>, <code>TItem</code>, <code>TKey</code>).</li>
        <li>Type arguments are bound to concrete types at the usage site.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // Implementation omitted
}</code></pre>

      <h3>4.6.3 where constraints (overview)</h3>
      <p>
        Aloe generics support arbitrary type constraints via a <code>where</code> clause.<br />
        The default is unconstrained, but version 0.1 supports a small set of basic constraints.
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Summation specialized for Int
}</code></pre>

      <p class="note">
        Here, <code>where</code> is purely for <strong>compile-time type checking</strong>.<br />
        The runtime representation (monomorphization vs shared code with type tags, etc.) is left to the VM.
      </p>

      <h3>4.6.4 Supported kinds of constraints</h3>
      <p>
        Version 0.1 supports the following constraint types:
      </p>

      <ul>
        <li><strong>Value type / reference type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive type constraints</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>, etc.,
              may directly name primitive types.</li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – types implementing trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – exactly type <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – exactly type <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Arbitrary concrete types</strong>
          <ul>
            <li>Any existing concrete type may be specified (e.g. <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Generic restricted to value types
method Zero&lt;T&gt;(): T
  where T: struct
{
  // Implementation omitted
}

// Pipe specialized for Int
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // Implementation omitted
}

// Restricted to a specific struct type
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // Implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior on constraint violations</h3>
      <ul>
        <li>If a type argument supplied to a generic function/type does not satisfy its
          <code>where</code> constraints, it is a compile-time error.</li>
        <li>When multiple constraints are specified, they must all be satisfied simultaneously.</li>
        <li>Cyclic constraints and advanced typeclass-like structures are not supported at this time.</li>
      </ul>

      <pre><code>// Example of a compile error:

// where T: Int, so T cannot be String
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization, shared code with type tags, etc.)
        is defined by AloeVM.<br />
        This language specification focuses on type-safe reuse and behavior of constraints using <code>where</code>.
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. Methods and Functions</h2>

      <h3>5.1 method declaration</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> defines top-level functions or methods bound to a type.</li>
        <li>If the return type is omitted, the method is treated as “no return value” (void).</li>
        <li>Aloe has no <code>Unit</code> type; lack of return value is not represented as a type.</li>
      </ul>

      <h3>5.2 Method binding via bound</h3>
      <p>
        In Aloe, <code>bound</code> is used to add methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // Internal representation is VM-dependent
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; {
    // Implementation omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, methods declared inside a <code>bound</code> block are subject to specific
        <strong>constraints</strong> regarding their return types (see Section 6.2).
      </p>

      <h3>5.3 Function types (Func&lt;...:...&gt;)</h3>
      <p>
        In Aloe, all function types are expressed using the <code>Func&lt;...:...&gt;</code> notation.
        Function-type syntax using <code>-&gt;</code> does not exist in the language.
      </p>
      <ul>
        <li><code>Func&lt;T:U&gt;</code> represents a function that takes argument <code>T</code> and returns <code>U</code>.</li>
        <li><code>Func&lt;A, B:R&gt;</code> represents a function that takes arguments <code>A</code> and <code>B</code>, and returns <code>R</code>.</li>
        <li>A function with no return value (void) can be written as <code>Func&lt;T:&gt;</code> or <code>Func&lt;T:void&gt;</code>.</li>
      </ul>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is that it can represent
        <strong>pipe / filter style data flow</strong>
        in a type-safe and consistent manner.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, the above is equivalent to the following nested calls:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>The Aloe <code>|&gt;</code> operator is syntactic sugar for such function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe,
          corresponding to lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents a pipe through which elements of type <code>T</code> flow.</li>
          <li>The internal representation (iterator chains, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers / transformers / consumers using <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // Internal fields are implementation-dependent
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the space of functions and objects that accept and/or return
          <code>Pipe&lt;T&gt;</code> (producers, transformers, consumers).<br />
          Consumers are the exit from the pipe world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the pipe / filter model, functions and objects are categorized into the following
          three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>:
            entities whose return type is <code>Pipe&lt;*&gt;</code> and that appear at the head
            of a pipeline.
          </li>
          <li><strong>Role</strong>:
            read data from the outside world (files, HTTP, arrays, etc.) and inject it into
            the pipe world (<code>Pipe&lt;T&gt;</code>).
          </li>
          <li><strong>Type</strong>:
            of the form <code>Func&lt;X:Pipe&lt;T&gt;&gt;</code>.
            Producers are always designed to output some <code>Pipe&lt;*&gt;</code>.
          </li>
        </ul>

        <h4>6.2.2 Transformer (intermediate filters)</h4>
        <ul>
          <li><strong>Definition</strong>:
            functions/methods of type <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>.</li>
          <li><strong>Role</strong>:
            transform, filter, or sort data inside the pipe world, without stepping outside it.</li>
        </ul>

        <p>
          In Aloe, methods declared inside <strong><code>bound Pipe&lt;T&gt;</code></strong> are
          by default restricted to behave as transformers.
        </p>

        <div class="note">
          <strong>Restriction:</strong><br />
          Methods declared in a <code>bound Pipe&lt;T&gt;</code> block must<br />
          return <strong>some <code>Pipe&lt;*&gt;</code></strong> as their result.<br />
          In other words, their type must be <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; { ... }

  // OK: changes element type
  method Map&lt;U&gt;(Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; { ... }

  // NG: return type is not Pipe, so this should be a compile error
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer (terminal filters)</h4>

        <ul>
          <li><strong>Definition</strong>:
            functions/objects of type <code>Func&lt;Pipe&lt;T&gt;:R&gt;</code> where <code>R</code>
            is not a <code>Pipe&lt;*&gt;</code>.</li>
          <li><strong>Role</strong>:
            serve as the exit from the pipe world, consuming a pipe completely and converting it to
            arrays, scalars, or external I/O.</li>
          <li><strong>Return type</strong>:
            as long as <code>R</code> is not <code>Pipe&lt;*&gt;</code>, there are no restrictions.
            It may be <code>T[]</code>, <code>Int</code>, <code>Unit</code>, <code>Bool</code>, etc.</li>
        </ul>

        <pre><code>// Consumer that materializes a pipe into an array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer that counts the number of elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-Related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms for building components of the pipe/filter model:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of these are treated as “objects with constructors” and their <code>bound</code> blocks are executed
          when they are connected into a pipeline.
        </p>

        <h4>6.3.1 producer declarations</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when the producer is connected to a pipeline
    // Reads from external resources and writes to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the name of the producer.</li>
          <li><code>out</code> specifies the <strong>output type</strong> in the pipe world.
            It must be a <code>Pipe&lt;*&gt;</code> type.</li>
          <li><code>bound(output)</code> defines behavior when the producer is plugged into a pipeline.
            The type of <code>output</code> is the type declared in <code>out</code> (e.g. <code>Pipe&lt;T&gt;</code>).</li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are accessible from inside the <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo-code:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe declarations</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connects pipes and performs transfer / transformation
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the name of the pipe.</li>
          <li><code>in</code> is the type flowing in from upstream.</li>
          <li><code>out</code> is the type flowing downstream.</li>
          <li><code>bound(input, output)</code> describes the transformation from <code>input</code> to <code>output</code>.</li>
        </ul>

        <p class="note">
          <code>pipe</code> declarations are intended as bridges between different stream types
          (text → JSON, etc.) or between streams and external resources such as sockets or HTTP.
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // decoded object

  bound(input, output) {
    // Pseudo-code:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter declarations</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Defines how elements flow from input to output
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> is the name of the filter.</li>
          <li><code>in</code> / <code>out</code> specify input and output types.</li>
          <li>In pipeline use, both <code>in</code> and <code>out</code> are typically
            <code>Pipe&lt;*&gt;</code>.</li>
          <li><code>bound(input, output)</code> describes the transformation between them.</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer declarations</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Executed at the end of a pipeline
    // Consumes input and returns a value
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the name of the consumer.</li>
          <li><code>in</code> specifies the input type.
            In the pipe/filter model, this is usually <strong><code>Pipe&lt;T&gt;</code></strong>.</li>
          <li><code>bound(input)</code> is executed at the end of the pipeline,
            completely consumes <code>input</code>, and returns a value of any type <code>R</code>.</li>
          <li><code>R</code> may be <code>T[]</code>, <code>Int</code>, <code>Bool</code>, <code>Unit</code>, etc.,
            but <strong>must not be <code>Pipe&lt;*&gt;</code></strong>.</li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo-code:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo-code:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, the roles of pipe-related declarations are:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code> (always outputs a <code>Pipe</code>)</li>
            <li><strong>pipe</strong>: bridging different stream types and external I/O</li>
            <li><strong>filter</strong>: typically <code>Pipe&lt;T&gt;</code> → <code>Pipe&lt;U&gt;</code> transformations</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → non-<code>Pipe</code> type (exit from the pipe world)</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level definition</h4>
        <p>
          In Aloe, <code>|&gt;</code> is defined as syntactic sugar for
          <strong>simple function composition</strong>.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>Func&lt;A:B&gt;</code> and <code>G</code> has type <code>Func&lt;B:C&gt;</code>,
            then <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.</li>
          <li>This operator can be applied to any types; it is not restricted to <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Thus, from the type system’s viewpoint, “the return type changing in the middle of a pipeline”
          is not a problem in itself.<br />
          Restrictions in the pipe/filter model are provided by
          <strong>the design of <code>Pipe&lt;T&gt;</code> and pipe-related declarations in the library</strong>,
          not by the operator itself.
        </div>

        <h4>6.4.2 Using Pipe&lt;T&gt; with <code>|&gt;</code></h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>Func&lt;String:Pipe&lt;String&gt;&gt;</code>)</li>
          <li><code>Where</code> / <code>Map</code>: transformers (<code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>)</li>
          <li><code>ToArray</code>: consumer (<code>Func&lt;Pipe&lt;User&gt;:User[]&gt;</code>)</li>
          <li>The type of the entire pipeline expression is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          At the language level, it is valid to chain another <code>|&gt;</code> after a consumer, but stylistically
          this is discouraged.<br />
          For example, patterns like <code>ToArray() |&gt; ToArray()</code> should be avoided.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters and Producers</h3>

        <h4>6.5.1 Representative transformers (filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Representative producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Representative consumers (including dump)</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // Returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // Returns Int
}</code></pre>

        <p>
          In addition to the above, Aloe defines a built-in consumer <strong><code>dump</code></strong> for debugging.
          It is used as the terminal stage of a pipeline:
        </p>
        <pre><code>Expr |&gt; dump;</code></pre>
        <p>
          The <code>dump</code> consumer behaves as follows:
        </p>
        <ul>
          <li>If the pipeline value is a single object, it calls that object’s <code>Dump()</code>
            (inherited or overridden from <code>Object</code>) and outputs the result.</li>
          <li>If the value is a collection, it iterates through all elements and calls each element’s
            <code>Dump()</code> in order.</li>
          <li>If the value is a tree-like structure, it traverses the nodes and calls <code>Dump()</code>
            for each node in traversal order.</li>
        </ul>
        <p>
          For <strong>cyclic references</strong>, <code>dump</code> detects cycles and behaves like this:
        </p>
        <ul>
          <li>When traversing a tree-like structure, if a cycle is detected at some node,
            dumping of elements <em>below that node</em> is skipped.</li>
          <li>For collections, if a particular element participates in a cycle, dumping that element
            can be cut off at the point of detection, but dumping of the <strong>next elements</strong>
            continues.</li>
          <li>Implementations are expected to maintain a set of already visited nodes/objects to detect cycles.</li>
        </ul>
        <p class="note">
          The <code>dump</code> consumer is a typical example of a <strong>terminal filter (consumer)</strong> in the
          pipe/filter model. It does not return a value; it is intended to be used at the end of a pipeline to
          inspect the current contents via <code>Dump()</code>.
        </p>

        <h4>6.5.4 Usage example</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with Statement</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> statement is syntactic sugar for repeatedly assigning properties
        and calling methods on the same target object.<br />
        In Aloe, it also has the role of a <strong>“lifetime lock”</strong> that keeps
        the target object alive during the block.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The <code>with</code> block above is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> evaluates <code>Expr</code> <strong>exactly once</strong>.</li>
        <li>In the block, simple assignments to identifiers are interpreted as member accesses on the target object.</li>
      </ul>

      <h3>7.3 Lifetime lock (GC root behavior)</h3>
      <p>
        AloeVM assumes a memory management model using reference counting combined with sliding compaction.<br />
        In this model, a <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The result of evaluating <code>with (Expr)</code> is stored in a hidden variable (a GC root).</li>
        <li>This hidden variable keeps the object alive until the end of the block,
          guaranteeing that <strong>the object is not freed during the block</strong>.</li>
        <li>Thus, while the block is executing, the object is guaranteed to remain alive.</li>
      </ul>

      <h3>7.4 Relationship between with and delete</h3>
      <ul>
        <li>Within a <code>with</code> block that targets a given variable, it is a compile-time error
          to apply <code>delete</code> to that same variable.</li>
        <li>This is because <code>with</code> expresses the intent “this object should stay alive here”,
          which conflicts with <code>delete</code>.</li>
        <li>However, it is allowed to <code>delete</code> a <em>different variable</em> that points to the
          same object. The GC root created by <code>with</code> remains, so the object continues to live.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is protected by with and is guaranteed to be alive within this block

  delete Alias;   // OK: only removes the Alias reference
  Url = "https://example.com/api";  // Still usable
}

// After the with block ends, the GC root is removed.
// If no other references remain, the object may eventually be freed.</code></pre>

      <p class="note">
        In summary, <code>with</code> is both a
        <strong>“syntactic sugar for member access”</strong> and a
        <strong>“mechanism to temporarily keep the target object as a GC root”</strong>.<br />
        When you want to protect the same target using both with and lock, you can use the
        <code>lock with</code> syntax described in Section 9.3.
      </p>
    </section>

    <section id="delete">
      <h2>8. delete Statement</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> does <strong>not</strong> directly destroy objects.<br />
        Instead, it is a construct for <strong>removing references from variables</strong>.
      </p>
      <ul>
        <li>Actual object destruction (memory freeing, finalizers, etc.) is performed by the
          <strong>runtime (AloeVM) using reference counting + GC</strong>.</li>
        <li><code>delete</code> is a type-safe way to express “this variable no longer points to this object”,
          and is used in place of assigning null.</li>
      </ul>

      <h3>8.2 Syntax</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static rules (compile time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After a <code>delete</code>, any read, member access, or method call using that variable
          is a compile-time error</strong>.</li>
        <li>However, assigning a new value to that variable is allowed.
          Conceptually, <code>delete</code> returns the variable to an “uninitialized” state.</li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Use Buf
DoSomething(Buf);

delete Buf;

// From here on, reading Buf or Buf.Length is a compile error

Buf = NewBuffer();  // Reassignment makes it usable again</code></pre>

      <h3>8.4 Runtime semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>Decrements the reference count of the object currently referenced by <code>Var</code>
          (assuming reference counting).</li>
        <li>Marks <code>Var</code> itself as “uninitialized / deleted”.</li>
        <li>When the object’s reference count becomes 0, it is freed at the discretion of the GC.<br />
          <strong>In other words, the object is not necessarily destroyed at the exact moment
          <code>delete</code> is executed.</strong></li>
      </ul>

      <p class="note">
        This language specification leaves the timing of object destruction to the VM/runtime.<br />
        <code>delete</code> only removes one reference from one variable to the object.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>As described in Section 7.4, within a <code>with</code> block targeting a given variable,
          applying <code>delete</code> to that variable is a compile-time error.</li>
        <li>It is allowed to apply <code>delete</code> to another variable that refers to the same object.
          Because the GC root created by <code>with</code> remains, the object itself continues to live.</li>
      </ul>

      <p class="note">
        If Aloe introduces “owned resource types” or an ownership model in the future,
        <code>delete</code> may be integrated into that model.<br />
        In this draft, we describe behavior under the assumption that
        <strong>no ownership model exists</strong>.
      </p>
    </section>

    <section id="lock">
      <h2>9. lock Statement and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> statement acquires a lock on a specific object and guarantees
        exclusive access to that object as well as optimizations for read barriers during the block.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> acquires a lock on the object denoted by <code>Expr</code>
          and guarantees exclusive access within <code>Body</code>.</li>
        <li>The acquisition and release of locks is implemented by the VM.</li>
        <li>Updates to data shared between threads should generally be confined to <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM assumes memory management with sliding compaction.<br />
        Within a <code>lock</code> block, the VM may optimize read barriers and reduce checks on each object
        to as few times as possible.
      </p>

      <h3>9.3 lock with Statement (lock + with combination)</h3>
      <p>
        For situations where you want to apply both “exclusive lock” and “lifetime lock (with)” to the
        same target object at once, Aloe provides the <code>lock with</code> statement.
      </p>

      <pre><code>lock with (Conn) {
  // Here:
  //   - Conn is protected by an exclusive lock
  //   - Conn is kept alive as a GC root by with
  //   - Conn's members can be referred to without repeating Conn.
}</code></pre>

      <h4>9.3.1 Syntax</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <p>
        <code>lock with (Expr) { Body }</code> is a composite construct that evaluates <code>Expr</code>
        exactly once and treats the result as the target for both <code>lock</code> and <code>with</code>.
      </p>

      <h4>9.3.2 Desugaring (semantically equivalent code)</h4>
      <p>
        Semantically, <code>lock with (Expr) { Body }</code> is equivalent to:
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> is evaluated exactly once, and the result is bound to a temporary variable <code>__tmp</code>.</li>
        <li>Then, <code>lock</code> and <code>with</code> are nested and applied to <code>__tmp</code>.</li>
        <li>During the execution of <code>Body</code>:
          <ul>
            <li>Exclusive access to the target object is guaranteed (<code>lock</code> semantics).</li>
            <li>The target object is kept alive as a GC root via <code>with</code>.</li>
            <li>Members of the target object can be accessed concisely as in a normal <code>with</code> block.</li>
          </ul>
        </li>
      </ul>

      <h4>9.3.3 Style and restrictions</h4>
      <ul>
        <li><code>lock with</code> is sugar for expressing the intention
          “operate on a specific resource under both exclusive and lifetime protection”
          with a single construct.</li>
        <li>Alternative notations like <code>with lock (Expr)</code> or <code>lock &amp; with (Expr)</code>
          are not part of the language.<br />
          For this purpose, <code>lock with</code> must be used.</li>
        <li>Behavior inside a <code>lock with</code> block is interpreted as the combination of
          <code>lock</code> rules from Section 9.2 and <code>with</code> rules from Section 7.3.</li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// At this point, the lock is released and the with lifetime lock is also released.</code></pre>
    </section>

    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside the <code>try</code> block can be caught by a corresponding <code>catch</code>.</li>
        <li>The <code>finally</code> block is always executed, regardless of whether an exception was thrown.</li>
        <li>Details of exception types and hierarchies are specified in the VM specification.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. Execution Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode VM.</li>
        <li>Function calls push frames onto a call stack.</li>
        <li>GC is assumed to use reference counting plus sliding compaction.</li>
      </ul>

      <h3>11.2 Memory management (overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>When certain conditions are met, GC runs, slides live objects, and compacts memory.</li>
        <li><code>with</code> acts as a temporary GC root that keeps objects alive, and in combination with
          <code>lock</code> enables optimization of read barriers.</li>
        <li>Typically, you do not need to call <code>delete</code> for memory management.
          Only use <code>delete</code> when you explicitly want to drop a reference.</li>
      </ul>

      <p class="small">
        A detailed opcode list and GC implementation details are provided in the AloeVM specification.
      </p>
    </section>

    <section id="limits">
      <h2>12. Limitations and Future Directions</h2>

      <h3>12.1 Current limitations</h3>
      <ul>
        <li>The expressive power of generics is minimal; typeclasses and higher-kinded generics are not defined.</li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>12.2 Future directions</h3>
      <ul>
        <li>Parallelization and fusion optimizations of pipe/filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Introduction of error handling mechanisms such as a <code>Result</code> type in addition to exceptions.</li>
        <li>Expansion of the standard library for distributed processing and streaming.</li>
        <li>Integration of ownership-based resource types with <code>delete</code> where needed.</li>
        <li>Integration of trait / interface / sealed / readonly with pattern matching and exhaustiveness checking.</li>
      </ul>

      <p class="note">
        This draft particularly focuses on:<br />
        <strong>clarifying the relationships among Pipe / Filter and Producer / Transformer / Consumer / Pipe / Consumer</strong>,<br />
        and on<br />
        <strong>clarifying the relationships among with / delete / lock / class inheritance / readonly / clone / generics and the AloeVM memory model</strong>.
      </p>
    </section>

    <section id="event">
      <h2>13. event Syntax and Event Model</h2>

      <h3>13.1 Purpose and position</h3>
      <p>
        The <code>event</code> syntax in Aloe is used to express, at the language level, the contract that
        “this is a notification point where external code may register handlers”.
      </p>
      <ul>
        <li>External code can register and unregister handlers (callbacks) to events.</li>
        <li>Firing (raising) an event is, in principle, restricted to the side that declares the event.</li>
      </ul>
      <p>
        At the implementation level, <code>event</code> is treated as syntactic sugar for the standard library type
        <code>Event&lt;TArgs&gt;</code>.
      </p>
      <ul>
        <li><code>event Clicked&lt;ClickedArgs&gt;;</code> is equivalent to having a field of type
          <code>Event&lt;ClickedArgs&gt;</code>.</li>
        <li>However, unlike normal fields, reassignment from external code or direct calls to <code>Raise</code>
          are forbidden (compile-time errors).</li>
      </ul>

      <h3>13.2 Event&lt;TArgs&gt; and handler type</h3>

      <h4>13.2.1 Handler type</h4>
      <p>
        The function type for event handlers is defined as a standard type alias:
      </p>
      <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>
      <ul>
        <li>Argument: <code>TArgs</code> (type of the event arguments).</li>
        <li>Return value: <code>Task</code>.<br />
          To naturally support asynchronous handlers, event handlers are modeled as functions
          returning a <code>Task</code> that represents completion.</li>
      </ul>
      <p class="note">
        In the future, we may consider <code>Event&lt;TArgs, TResult&gt;</code>
        with handler type <code>Func&lt;TArgs:Task&lt;TResult&gt;&gt;</code> where each handler returns a result,
        but version 0.1 assumes <code>Task</code>-returning handlers as the basic model.
      </p>

      <h4>13.2.2 Role of Event&lt;TArgs&gt; (conceptual)</h4>
      <p>
        <code>Event&lt;TArgs&gt;</code> is a type that holds a set of event handlers and the logic to invoke them.
      </p>
      <pre><code>type Event&lt;TArgs&gt; {
  Handlers: List&lt;EventHandler&lt;TArgs&gt;&gt;;
}

bound Event&lt;TArgs&gt; {
  method Add(Handler: EventHandler&lt;TArgs&gt;): Task {
    Handlers.Add(Handler);
  }

  method Remove(Handler: EventHandler&lt;TArgs&gt;): Task {
    // Details of handler identity comparison are left to the VM / runtime
    Handlers.Remove(Handler);
  }

  method Raise(Args: TArgs): Task {
    // Await all handlers in order and return when all have completed
    foreach (H in Handlers) {
      await H(Args);
    }
  }
}</code></pre>
      <p class="note">
        At the language level, the key point is that
        <code>Event&lt;TArgs&gt;</code> is the underlying “event set”,
        and <code>event</code> syntax is sugar plus access rules over such a field.
      </p>

      <h3>13.3 event declaration syntax</h3>

      <h4>13.3.1 Declaration locations</h4>
      <p><code>event</code> may be declared in:</p>
      <ul>
        <li><code>struct</code> bodies</li>
        <li><code>class</code> bodies</li>
        <li><code>interface</code> bodies</li>
      </ul>
      <p>
        Top-level (file scope) and <code>trait</code> event declarations are not part of version 0.1.
      </p>

      <h4>13.3.2 Syntax (overview)</h4>
      <pre><code>EventDeclaration ::=
    'event' Identifier '&lt;' Type '&gt;' ';'</code></pre>
      <p>Example:</p>
      <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        Semantically, the above is equivalent to the following field declaration:
      </p>
      <pre><code>struct Button {
  private Clicked: Event&lt;ClickedArgs&gt;;
}</code></pre>
      <p>However, the following additional restrictions apply:</p>
      <ul>
        <li>External code may not reassign <code>Clicked</code> (compile-time error).</li>
        <li>External code may not call <code>Clicked.Raise(...)</code> directly.</li>
        <li>External code may not perform <code>delete Clicked;</code>.</li>
      </ul>

      <h3>13.4 Subscription / unsubscription syntax (<code>+=</code> / <code>-=</code>)</h3>

      <h4>13.4.1 Syntax</h4>
      <pre><code>EventAddStatement    ::= PrimaryExpression '.' Identifier '+=' EventHandlerExpression ';'
EventRemoveStatement ::= PrimaryExpression '.' Identifier '-=' EventHandlerExpression ';'</code></pre>
      <ul>
        <li><code>PrimaryExpression.Identifier</code> must be a member declared with <code>event</code>.</li>
        <li><code>EventHandlerExpression</code> must be an expression implicitly convertible to
          <code>Func&lt;TArgs:Task&gt;</code>.</li>
      </ul>

      <h4>13.4.2 Type rules</h4>
      <p>
        Given an <code>event X&lt;TArgs&gt;;</code> declaration:
      </p>
      <ul>
        <li><code>Target.X</code> has type <code>Event&lt;TArgs&gt;</code>.</li>
        <li><code>Target.X += H;</code> is allowed only when <code>H</code> has type
          <code>Func&lt;TArgs:Task&gt;</code> (or is implicitly convertible to it).</li>
        <li>The same restriction applies to <code>Target.X -= H;</code>.</li>
      </ul>

      <h4>13.4.3 Desugaring (semantically equivalent code)</h4>
      <p>Semantically, the following holds:</p>
      <pre><code>Target.X += H;
// is equivalent to:
await Target.X.Add(H);</code></pre>
      <pre><code>Target.X -= H;
// is equivalent to:
await Target.X.Remove(H);</code></pre>
      <p class="note">
        By giving <code>Add</code> / <code>Remove</code> a <code>Task</code> return type,
        subscription and unsubscription via <code>+=</code> / <code>-=</code> can be treated
        as asynchronous statements. In future versions, fire-and-forget variants may also be considered.
      </p>

      <h3>13.5 Rules for raising events</h3>

      <h4>13.5.1 Raising allowed only on definition side</h4>
      <p>
        Calls to <code>Raise</code> on an <code>event</code> member are allowed only from:
      </p>
      <ul>
        <li>Methods of the <code>struct</code> / <code>class</code> that declares the event.</li>
        <li>Methods inside <code>bound</code> blocks for that same type.</li>
      </ul>
      <p>
        Any other code (external modules, other classes, etc.) calling
        <code>Target.X.Raise(...)</code> is a compile-time error.
      </p>
      <p class="note">
        This ensures a clear separation of responsibility:
        only the side exposing an event has authority to fire it.
      </p>

      <h4>13.5.2 Basic firing pattern</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>

      <h3>13.6 event in interfaces and implementation</h3>
      <p><code>interface</code> can also declare <code>event</code>s.</p>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

interface IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        In this case, any <code>struct</code> / <code>class</code> implementing <code>IButton</code>
        must declare the corresponding <code>event</code>.
      </p>
      <pre><code>struct Button implements IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <ul>
        <li>If the event name <code>Clicked</code> does not match, or</li>
        <li>If the type argument <code>ClickedArgs</code> differs,</li>
      </ul>
      <p>then this is a compile-time error due to incorrect interface implementation.</p>

      <h3>13.7 Usage examples</h3>

      <h4>13.7.1 Button and Clicked event</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}

method SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  // Register asynchronous handler
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  // Register another handler
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Log("button clicked");
  };
}</code></pre>

      <h4>13.7.2 Unsubscription</h4>
      <pre><code>method SetupAndTearDown(Btn: Button): Task {
  let Handler: Func&lt;ClickedArgs:Task&gt; =
    async (Args: ClickedArgs): Task {
      Print("temp handler");
    };

  // Subscribe
  Btn.Clicked += Handler;

  // ... some processing ...

  // Unsubscribe
  Btn.Clicked -= Handler;
}</code></pre>

      <h3>13.8 Combining with with / lock and Event&lt;TArgs&gt; (reference)</h3>
      <p>
        Since <code>Event&lt;TArgs&gt;</code> is also a normal reference type, you can combine it with
        <code>with</code> or <code>lock with</code> to safely fire events in a thread-safe way when needed.
      </p>
      <pre><code>struct Hub {
  event MessageReceived&lt;String&gt;;
}

bound Hub {
  method RaiseMessage(Msg: String): Task {
    lock with (MessageReceived) {
      await MessageReceived.Raise(Msg);
    }
  }
}</code></pre>

      <h3>13.9 Summary</h3>
      <ul>
        <li><code>event</code> provides syntax sugar and access rules over <code>Event&lt;TArgs&gt;</code>.</li>
        <li>External code can only subscribe/unsubscribe handlers via <code>+=</code> / <code>-=</code>;
          firing events or replacing their underlying <code>Event&lt;TArgs&gt;</code> is not allowed.</li>
        <li>Handlers are uniformly of type <code>Func&lt;TArgs:Task&gt;</code>, providing an
          asynchronous event model.</li>
        <li><code>event</code> can also appear in interfaces, allowing event contracts to be
          expressed at the type level.</li>
        <li>This design provides a similar usage experience to C#’s <code>event</code>,
          without introducing a dedicated <code>delegate</code> type into the language, and instead
          using Aloe’s function types and <code>Task</code> directly.</li>
      </ul>
    </section>

  </main>
</div>
</body>
</html>

