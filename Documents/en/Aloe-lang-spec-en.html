<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft, with with-extension)</title>
  <style>
    /* Layout only; fonts are left mostly to browser defaults */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1rem;
    }
    .sidebar h2 {
      font-size: 0.8rem;
      margin: 0.8rem 0 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.85rem;
    }
    .sidebar nav li {
      margin: 0.1rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.2rem 0.35rem;
      border-radius: 0.3rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar a.active {
      background: #1d4ed8;
      color: #e5e7eb;
    }
    .chapter-index {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.3rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 1.8rem 2.4rem;
      box-sizing: border-box;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.4em;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #f3f4f6;
      padding: 0.7rem 0.9rem;
      border-radius: 0.4rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 1.8rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }

    .chapter {
      display: none;
    }
    .chapter.active {
      display: block;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Left menu -->
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="subtitle">
      Draft / English version + <code>with</code> extension
    </div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a class="nav-link active" data-target="ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a class="nav-link" data-target="ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a class="nav-link" data-target="ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a class="nav-link" data-target="ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a class="nav-link" data-target="ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a class="nav-link" data-target="ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a class="nav-link" data-target="ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a class="nav-link" data-target="ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a class="nav-link" data-target="ch8"><span class="chapter-index">8.</span>delete and null</a></li>
        <li><a class="nav-link" data-target="ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a class="nav-link" data-target="ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a class="nav-link" data-target="ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a class="nav-link" data-target="ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a class="nav-link" data-target="ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a class="nav-link" data-target="ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a class="nav-link" data-target="ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a class="nav-link" data-target="ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a class="nav-link" data-target="ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a class="nav-link" data-target="ch18"><span class="chapter-index">18.</span>Pipes and Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a class="nav-link" data-target="ch4">4.2 with-blocks</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Right content -->
  <main class="content">
    <h1>Aloe Language Specification (Draft)</h1>
    <p class="note">
      Base document: <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>.<br />
      This is an English draft based on the original spec, with an additional extension in
      <strong>4.2 with-blocks</strong>: “dot-less” with-blocks + <strong>type-based with</strong> (class/struct/enum static members and enum constants shortcut).<br />
      Also, in the examples, <strong>method names, property names, and field names are written in PascalCase (leading uppercase)</strong>, according to the current naming guideline.
    </p>

    <!-- 0. Overview -->
    <section class="chapter active" id="ch0">
      <hr />
      <h2>0. Overview</h2>
      <p>
        Aloe is a statically-typed scripting language with simple and intuitive syntax,
        running on a stack-based virtual machine (AloeVM).
      </p>
      <ul>
        <li>Easy to read and write for educational use and small applications.</li>
        <li>Targets C# runtime and WASM environments.</li>
        <li>Controls I/O and concurrency using <code>pipe</code> and <code>filter</code> in a statically typed manner.</li>
      </ul>
      <p>Main characteristics:</p>
      <ul>
        <li>Static typing
          <ul>
            <li><code>var</code> for type inference.</li>
            <li><code>let</code> for explicit type annotations.</li>
          </ul>
        </li>
        <li>Value types vs reference types
          <ul>
            <li><code>struct</code> … value type</li>
            <li><code>class</code> … reference type</li>
          </ul>
        </li>
        <li>GC-based memory management (actual algorithm is VM-dependent).</li>
        <li>No explicit <code>= null</code> in source code (use <code>delete</code> instead).</li>
        <li>Data-flow oriented design with <code>pipe</code> and <code>filter</code>.</li>
      </ul>
    </section>

    <!-- 1. Basic Syntax -->
    <section class="chapter" id="ch1">
      <hr />
      <h2>1. Basic Syntax</h2>

      <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
      <ul>
        <li><code>//</code> to end-of-line is a line comment.</li>
        <li><code>/* ... */</code> is a multi-line comment.</li>
        <li>Nested <code>/* */</code> is unspecified (not supported).</li>
      </ul>

      <h3>1.2 Identifiers</h3>
      <ul>
        <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
        <li>First character must be a letter or <code>_</code>.</li>
        <li>Case-sensitive.</li>
        <li>Keywords cannot be used as identifiers.</li>
        <li>Identifiers starting with <code>_</code> are considered “private” by convention.</li>
        <li>Certain Unicode letters may be allowed (whitespace and punctuation are excluded).</li>
      </ul>

      <h3>1.3 Keywords</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
      <ul>
        <li>Use <code>namespace</code> instead of <code>package</code>.</li>
        <li><code>final</code> is removed; use <code>sealed</code> instead.</li>
        <li><code>instanceof</code> is removed; use <code>is</code> instead.</li>
      </ul>

      <h3>1.4 Literals</h3>
      <ul>
        <li>Integer: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
        <li>Float: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code>.</li>
        <li>Decimal: <code>10.12345678901234567890:d</code>, etc.</li>
        <li>Boolean: <code>true</code>, <code>false</code>.</li>
        <li>String: <code>"Hello, World!"</code>.</li>
        <li>Char: <code>'A'</code>, <code>'z'</code>, etc.</li>
        <li>Null literal: <code>null</code> (exists as a literal but is not used in assignments directly).</li>
        <li>Array literal: <code>[1, 2, 3]</code>.</li>
        <li>List literal: <code>(1, 2, 3)</code>.</li>
        <li>Set literal: <code>{1, 2, 3}</code>.</li>
        <li>Map literal: <code>["key1": 10, "key2": 20]</code>.</li>
        <li>Enum literal: <code>EnumType.Value1</code>.</li>
        <li>Struct literal: <code>Point { X: 0, Y: 1 }</code>.</li>
        <li>Object creation: <code>new ClassName()</code>.</li>
      </ul>

      <h3>1.5 Statement terminator</h3>
<pre><code>var X = 10;
X = X + 1;
Print(X);
</code></pre>
      <ul>
        <li>All statements end with <code>;</code>.</li>
        <li>No automatic semicolon insertion based on line breaks.</li>
      </ul>

      <h3>1.6 Whitespace / 1.7 Case sensitivity</h3>
      <ul>
        <li>Spaces, tabs, and line breaks act as token delimiters.</li>
        <li>Multiple whitespace characters are treated as a single delimiter.</li>
        <li>Indentation has no semantic meaning.</li>
        <li>Identifiers and keywords are case-sensitive.</li>
        <li>All keywords are lowercase.</li>
      </ul>
    </section>

    <!-- 2. Type System -->
    <section class="chapter" id="ch2">
      <hr />
      <h2>2. Type System</h2>

      <h3>2.1 Primitive types</h3>
      <ul>
        <li><code>int</code> / <code>integer</code></li>
        <li><code>float</code></li>
        <li><code>bool</code> / <code>boolean</code></li>
        <li><code>decimal</code></li>
        <li><code>string</code></li>
        <li><code>char</code></li>
        <li><code>byte</code></li>
        <li><code>void</code></li>
        <li><code>null</code> (literal)</li>
      </ul>

      <h3>2.2 Composite / user-defined types</h3>
      <ul>
        <li>Array: <code>T[]</code>.</li>
        <li>List: <code>T()</code>.</li>
        <li>Set: <code>T{}</code>.</li>
        <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code>.</li>
        <li><code>struct</code>, <code>class</code>, <code>enum</code>, <code>bitfield enum</code>.</li>
        <li><code>task</code>, <code>pipe&lt;T&gt;</code>.</li>
      </ul>

      <h3>2.3 Value vs reference types</h3>
      <ul>
        <li>Value types: primitives + struct + enum/bitfield enum.</li>
        <li>Reference types: class, string, task, pipe, etc.</li>
      </ul>
      <h4>Struct restrictions</h4>
      <ul>
        <li>Struct fields can be only primitives or other structs.</li>
        <li>Reference-type fields (class, etc.) are not allowed.</li>
        <li>Struct assignment always copies by value.</li>
      </ul>
    </section>

    <!-- 3. Numbers & Conversions -->
    <section class="chapter" id="ch3">
      <hr />
      <h2>3. Numbers &amp; Conversions</h2>

      <h3>3.1 int / float</h3>
      <ul>
        <li>Mixed integer/float expressions are promoted to <code>float</code>.</li>
      </ul>

      <h3>3.2 decimal</h3>
      <ul>
        <li>High-precision base-10 numeric type.</li>
        <li>Overflow and underflow are treated as <code>OverflowException</code>.</li>
      </ul>

      <h3>3.3 enum and int</h3>
      <ul>
        <li>No cast syntax.</li>
        <li>enum &lt;=&gt; int implicit/explicit conversions are forbidden.</li>
      </ul>

      <h3>3.4 byte / char</h3>
      <ul>
        <li><code>byte</code>: 0–255. Mixed with int is promoted to <code>int</code>.</li>
        <li><code>char</code>: arithmetic is not allowed; comparison is allowed only between chars.</li>
      </ul>

      <h3>3.5 NaN / Infinity</h3>
      <ul>
        <li>Overflow/underflow are not represented by NaN/Infinity but by exceptions.</li>
        <li>Division by zero is represented by <code>ZeroDivisionException</code>.</li>
        <li>Helpers such as <code>IsNaN</code>, <code>IsInfinity</code> are considered standard-library functions (PascalCase) if provided.</li>
      </ul>
    </section>

    <!-- 4. Blocks & Scope + with -->
    <section class="chapter" id="ch4">
      <hr />
      <h2>4. Blocks &amp; Scope</h2>

      <h3>4.1 Static scope and shadowing</h3>
<pre><code>class Sample {
    field Value: int = 1;

    method Foo(): void {
        var Value = 2;        // shadows the field
        Print(Value);         // 2
        Print(this.Value);    // 1
    }
}
</code></pre>
      <ul>
        <li>Aloe uses static (lexical) scoping.</li>
        <li>A variable declared in an inner block shadows outer ones.</li>
        <li>When a field name conflicts with a local variable, the local is preferred; the field must be accessed via <code>this.</code>.</li>
      </ul>

      <h3>4.2 with-blocks (member shortcut syntax)</h3>
      <p>with-blocks provide a concise way to access members of one or more objects.</p>
<pre><code>with (User) {
    Name = "Alice";
    Age  = Age + 1;
    Print(Name);
}
</code></pre>
      <ul>
        <li>Syntax: <code>with (Expr1)</code> or <code>with (Expr1), (Expr2), ...</code>.</li>
        <li>Each Expr is evaluated only once at the start of the block and stored in an internal temporary.</li>
        <li>Name resolution for a simple identifier inside a with-block:
          <ol>
            <li>Locals and parameters declared in that block.</li>
            <li>Members (fields/properties/methods) of the with-targets (from left to right).</li>
            <li>Outer scopes (outer blocks, class fields, imported symbols, etc.).</li>
          </ol>
        </li>
        <li>If multiple with-targets have the same member name, it is ambiguous and a compile-time error.</li>
        <li>A special temporary <code>_</code> refers to the first with-target (<code>Expr1</code>):
          <ul>
            <li>You can pass it as <code>Log(_)</code>, etc.</li>
          </ul>
        </li>
      </ul>

      <h4>4.2.1 Multiple with-targets</h4>
<pre><code>with (User), (Profile) {
    Name = "Alice";          // resolved on User.Name or Profile.Name
    UpdateProfile();         // resolved on User.UpdateProfile() or Profile.UpdateProfile()
}
</code></pre>
      <ul>
        <li>Resolution order is from left to right: Expr1, then Expr2, ...</li>
        <li>If more than one target defines the same member, it is ambiguous and a compile-time error.</li>
      </ul>

      <h4>4.2.2 Nested with-blocks</h4>
<pre><code>with (User) {
    Name = "Alice";

    with (Address) {
        City = "Tokyo";   // Address.City
        Print(Name);      // resolved to User.Name or a local Name
    }
}
</code></pre>
      <ul>
        <li>Inner with-blocks have their own resolution rules.</li>
        <li>If a name cannot be resolved inside the inner with, lookup falls back to outer scopes, including outer with-blocks.</li>
      </ul>

      <h4>4.2.3 Type-based with (class / struct / enum)</h4>
      <p>
        If you specify a <strong>type name</strong> instead of an expression in a with-block,
        you can use it as a shortcut to static members (for classes/structs) or enum constants.
      </p>
<pre><code>with (AngleUtil) {
    var Rad  = DegToRad(90.0);   // AngleUtil.DegToRad(90.0)
    var Rad2 = DegToRad(45.0);
    Print(Pi);                   // AngleUtil.Pi
}
</code></pre>
      <ul>
        <li>Allowed type targets:
          <ul>
            <li>class types</li>
            <li>struct types</li>
            <li>enum / bitfield enum types</li>
          </ul>
        </li>
        <li>In a type-based with:
          <ol>
            <li>Locals and parameters.</li>
            <li>Static fields, static methods, and enum constants of the target type(s).</li>
            <li>Outer scopes.</li>
          </ol>
        </li>
        <li>Accessing instance members in a type-based with is a compile-time error.</li>
        <li>The special <code>_</code> can be treated as a pseudo-object representing the first type target's static context; <code>_.Member</code> is equivalent to simply <code>Member</code>.</li>
      </ul>

      <h5>Example: struct / class</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(Deg: float): float {
        return Deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(A: int, B: int): int {
        if (A > B) return A;
        return B;
    }
}

main(Args: string[]) {
    with (AngleUtil) {
        var Rad  = DegToRad(90.0);
        var Rad2 = DegToRad(45.0);
        Print(Pi);
    }

    with (MathUtil) {
        var M = Max(10, 20);
        Print(M);
    }
}
</code></pre>

      <h5>Example: enum</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

main(Args: string[]) {
    with (Color) {
        var C1: Color = Red;   // Color.Red
        var C2: Color = Blue;  // Color.Blue
        Print(C1);
        Print(C2);
    }
}
</code></pre>

      <h5>Mixing value-based and type-based with</h5>
<pre><code>with (User), (Color) {
    Name = "Alice";      // User.Name
    var C: Color = Red;  // Color.Red
}
</code></pre>
      <p class="note">
        Value-based and type-based with-targets form a combined “candidate set” for member resolution.
        If multiple candidates exist for the same identifier, it is considered ambiguous and a compile-time error.
      </p>
    </section>

    <!-- 5. Variables & Constants -->
    <section class="chapter" id="ch5">
      <hr />
      <h2>5. Variables &amp; Constants</h2>

      <h3>5.1 var (type inference)</h3>
<pre><code>var I   = 10;
var F   = 10.5;
var S   = "Hello";
var C   = 'A';
var B   = 255;
var Arr = [1, 2, 3];
var Lst = (1, 2, 3);
var St  = {1, 2, 3};
var Fb  = new FizzBuzz();
</code></pre>

      <h3>5.2 let (explicit type)</h3>
<pre><code>let I: int = 10;
let F: float = 10.5;
let D: decimal = 10.12345678901234567890:d;
let S: string = "Hello, Aloe!";
let C: char = 'A';
let B: byte = 255;

let Arr: int[] = [1, 2, 3];
let Lst: int() = (1, 2, 3);
let St : int{} = {1, 2, 3};
let Mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

      <h3>5.3 const</h3>
<pre><code>const MaxCount: int = 100;
const PiConst : float = 3.14159;
const AppName : string = "Aloe VM";
</code></pre>
    </section>

    <!-- 6. Fields -->
    <section class="chapter" id="ch6">
      <hr />
      <h2>6. Fields</h2>
<pre><code>class Sample {
    field Count: int = 0;
    field Name : string = "default";

    readonly field Id: int;

    construct(Id: int) {
        this.Id = Id; // OK
    }

    method Change(): void {
        this.Count = this.Count + 1;
        // this.Id = 2; // NG (readonly)
    }
}
</code></pre>
    </section>

    <!-- 7. Class / Struct / Interface / Trait -->
    <section class="chapter" id="ch7">
      <hr />
      <h2>7. Class / Struct / Interface / Trait</h2>

      <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name : string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var I = 1;
        while (I &lt;= 100) {
            // ...
            I = I + 1;
        }
    }
}
</code></pre>

      <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(X: int, Y: int) {
        this.X = X;
        this.Y = Y;
    }
}
</code></pre>

      <h3>7.3 Inheritance / sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
}
</code></pre>

      <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(Msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(Msg: string): void {
        Print(Msg);
    }
}
</code></pre>

      <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method Hello(): void {
        Print("Hello from Trait_A");
    }
}
</code></pre>

      <h4>Applying traits via with</h4>
<pre><code>var Obj = new SomeClass() with Trait_A;
Obj.Hello();
</code></pre>

      <h4>Non-destructive add/remove</h4>
<pre><code>var Obj2 = Obj + Trait_A;
var Obj3 = Obj2 - Trait_A;
</code></pre>

      <h4>Alias with as</h4>
<pre><code>var Obj2 = Obj + Trait_A as A;
Obj2.A.Hello();
// Obj2.Hello(); // NG: only through alias
</code></pre>
    </section>

    <!-- 8. delete & null -->
    <section class="chapter" id="ch8">
      <hr />
      <h2>8. delete and null</h2>
<pre><code>var Obj = new FizzBuzz();
delete Obj;   // at VM level, equivalent to Obj = null
</code></pre>
      <ul>
        <li>You cannot write <code>Obj = null;</code> directly in source code.</li>
        <li>Reference types may be null internally, but the type system does not track nullability.</li>
        <li>Accessing a null reference may cause a <code>NullReferenceException</code>.</li>
      </ul>
    </section>

    <!-- 9. is -->
    <section class="chapter" id="ch9">
      <hr />
      <h2>9. is Operator (type check)</h2>
<pre><code>if (Obj is FizzBuzz) {
}

if (Obj is ILogger) {
}

if (Obj is Trait_A) {
}
</code></pre>
      <ul>
        <li><code>is</code> checks runtime type.</li>
        <li>Respects inheritance (derived is also base).</li>
        <li>Can be used with interfaces and traits.</li>
      </ul>
    </section>

    <!-- 10. Collections -->
    <section class="chapter" id="ch10">
      <hr />
      <h2>10. Collections (Array / List / Set / Map)</h2>
<pre><code>var Arr: int[] = [1, 2, 3];
var Matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];

var Lst: int() = (1, 2, 3);
var ObjLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());

var St: int{} = {1, 2, 3};
var StructSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};

var Mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var Mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var ObjMp: map&lt;FizzBuzz&gt; = ["Obj1": new FizzBuzz(), "Obj2": new FizzBuzz()];
</code></pre>
    </section>

    <!-- 11. enum -->
    <section class="chapter" id="ch11">
      <hr />
      <h2>11. enum / bitfield enum</h2>

      <h3>11.1 enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
      <ul>
        <li>Underlying representation is always int32.</li>
        <li><code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code> etc. are not allowed.</li>
        <li>Enum types can be used as type-based with targets: <code>with (Color) { Red; }</code> is a shortcut for <code>Color.Red</code>.</li>
      </ul>

      <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

      <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // Here it becomes b(4)
}
</code></pre>
      <ul>
        <li><code>b(n)</code> means bit n (i.e. <code>1 &lt;&lt; n</code>).</li>
        <li><code>Name : b(n)</code> assigns that bit to the enumerator.</li>
        <li>Usable bits are at most 32 (n = 0–31).</li>
        <li>Multiple enumerators can share the same bit; this may be a warning but not necessarily an error.</li>
        <li>Underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code>, etc. are compile-time errors.</li>
      </ul>
    </section>

    <!-- 12. main -->
    <section class="chapter" id="ch12">
      <hr />
      <h2>12. main Block (entry point)</h2>
<pre><code>main(Args: string[]) {
    var Fb = new FizzBuzz();
    Fb.Run();

    _ = 0;   // process exit code
}
</code></pre>
      <ul>
        <li><code>main</code> is the program entry point.</li>
        <li><code>Args</code> is the command-line argument array.</li>
        <li>In <code>main</code>, <code>_</code> is always an <code>int</code> representing the process exit code.</li>
      </ul>
    </section>

    <!-- 13. temp variable _ -->
    <section class="chapter" id="ch13">
      <hr />
      <h2>13. Temp Variable <code>_</code></h2>
<pre><code>method Foo(): void {
    var X = 10;
    _ = X + 5;   // temporary result in this block
}
</code></pre>
      <p class="note">
        In <code>main</code>, <code>_</code> is always <code>int</code> (exit code). In other blocks,
        the type of <code>_</code> is inferred from the first assignment to it.<br />
        For the special use of <code>_</code> in with-blocks, see section 4.2.
      </p>
    </section>

    <!-- 14. swap -->
    <section class="chapter" id="ch14">
      <hr />
      <h2>14. swap Keyword</h2>
<pre><code>var A = 10;
var B = 20;
swap (A, B);
</code></pre>
      <ul>
        <li><code>swap(A, B)</code> exchanges the values (or references) of <code>A</code> and <code>B</code>.</li>
        <li>Validity of swap is checked at compile time.</li>
      </ul>
    </section>

    <!-- 15. Operators -->
    <section class="chapter" id="ch15">
      <hr />
      <h2>15. Operators</h2>
      <p>Precedence and associativity follow the original English spec (summarized below).</p>

      <h3>15.1 Precedence (high to low)</h3>
      <ol>
        <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
        <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
        <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li>
        <li>Additive: <code>+</code>, <code>-</code></li>
        <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
        <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
        <li>Equality: <code>==</code>, <code>!=</code></li>
        <li>Bitwise AND: <code>&amp;</code></li>
        <li>Bitwise XOR: <code>^</code></li>
        <li>Bitwise OR: <code>|</code> (different meaning from pipeline <code>|</code> in pipe/filter syntax)</li>
        <li>Logical AND: <code>&amp;&amp;</code></li>
        <li>Logical OR: <code>||</code></li>
        <li>Assignment: <code>=</code></li>
      </ol>
      <p>Compound assignments like <code>+=</code> are not yet specified.</p>

      <h3>15.2 Associativity</h3>
      <ul>
        <li>Unary operators: right-associative.</li>
        <li>Assignment: right-associative.</li>
        <li>All other binary operators: left-associative.</li>
      </ul>
    </section>

    <!-- 16. Exceptions -->
    <section class="chapter" id="ch16">
      <hr />
      <h2>16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (E) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

      <h3>16.1 Standard exception hierarchy (simplified)</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
      <ul>
        <li><code>OverflowException</code> covers both overflow and underflow.</li>
        <li><code>ZeroDivisionException</code> is thrown for division by zero (including 0.0).</li>
        <li>Parsing/format issues are represented by <code>FormatException</code>.</li>
        <li>Other fatal VM-level errors are implementation-dependent.</li>
      </ul>
    </section>

    <!-- 17. Modules -->
    <section class="chapter" id="ch17">
      <hr />
      <h2>17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
    }
}
</code></pre>
      <ul>
        <li><code>namespace</code> declares logical namespaces.</li>
        <li><code>import</code> brings names from other namespaces into scope.</li>
        <li>File layout, circular imports, etc. are defined in a separate module system spec.</li>
      </ul>
    </section>

    <!-- 18. Pipes & Filters -->
    <section class="chapter" id="ch18">
      <hr />
      <h2>18. Pipes &amp; Filters</h2>

      <h3>18.1 pipe&lt;T&gt;</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> represents a stream of <code>T</code>.</li>
        <li>Built-in pipes such as <code>stdin</code>, <code>stdout</code>, etc. are assumed.</li>
      </ul>

      <h3>18.2 Defining filters</h3>
<pre><code>filter LineSplit {
    in : pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(Input, Output) {
        foreach (Chunk in Input) {
            let Lines = Chunk.Split("\n");
            foreach (Line in Lines) {
                Output.Write(Line);
            }
        }
        Output.Close();
    }
}
</code></pre>

      <h3>18.3 Pipeline statement</h3>
<pre><code>stdin
    | filter(Utf8)
    | filter(Json&lt;User&gt;)
    | Users;
</code></pre>
      <ul>
        <li><code>A | B | C;</code> connects the output of A to the input of B, and B to C.</li>
        <li>Type checking ensures compatibility of input/output types between stages.</li>
        <li>A pipeline statement itself does not return a value; it only establishes connections.</li>
      </ul>

      <h3>18.4 foreach / EOF</h3>
<pre><code>foreach (Line in Lines) {
    Print(Line);
}
</code></pre>
      <ul>
        <li><code>foreach (X in P)</code> repeatedly calls <code>P.Next()</code> until EOF.</li>
        <li>When the writer calls <code>Close()</code>, the reader sees EOF and stops the loop.</li>
      </ul>

      <h3>18.5 close and EOF propagation</h3>
      <ul>
        <li>Calling <code>Write()</code> on a closed pipe is invalid and may cause an error.</li>
        <li>Filters should close their output pipe when they detect EOF on their input.</li>
      </ul>

      <h3>18.6 Concurrency model with pipes</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> is the primary communication mechanism between tasks.</li>
        <li>Aloe encourages a “shared-nothing” model; shared mutable data structures are discouraged.</li>
      </ul>

      <h3>18.7 Example: simple REST-ish pipeline</h3>
<pre><code>class User {
    field Id  : int;
    field Name: string;
}

main(Args: string[]) {
    let Req  : pipe&lt;byte&gt; = pipe&lt;byte&gt;.Create();
    let Users: pipe&lt;User&gt; = pipe&lt;User&gt;.Create();

    stdin
        | filter(Utf8)
        | filter(Json&lt;User&gt;)
        | Users;

    let U: User? = Users.Next();
    if (U is User) {
        Print("User: " + U.Name);
    }

    _ = 0;
}
</code></pre>

      <p class="note">
        Details of standard filters such as <code>Utf8</code> and <code>Json&lt;T&gt;</code> belong to a separate “standard filter library” spec, not the core language spec.
      </p>

      <hr />
      <p class="note">
        This completes the English version of the Aloe language specification, based on the original English spec,
        with the extended <strong>with-block</strong> design (dot-less, value- and type-based)
        and the current PascalCase naming guideline for methods/properties/fields.
        Save this file and open it in a browser to use the left navigation menu to switch chapters.
      </p>
    </section>

  </main>
</div>

<script>
  (function() {
    var links = document.querySelectorAll('.nav-link');
    var chapters = document.querySelectorAll('.chapter');

    function showChapter(id) {
      chapters.forEach(function(ch) {
        ch.classList.toggle('active', ch.id === id);
      });
      links.forEach(function(a) {
        a.classList.toggle('active', a.getAttribute('data-target') === id);
      });
    }

    links.forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        var target = this.getAttribute('data-target');
        if (!target) return;
        showChapter(target);
        if (history.replaceState) {
          history.replaceState(null, '', '#' + target);
        }
      });
    });

    var hash = window.location.hash.replace('#', '');
    if (hash && document.getElementById(hash)) {
      showChapter(hash);
    }
  })();
</script>
</body>
</html>
