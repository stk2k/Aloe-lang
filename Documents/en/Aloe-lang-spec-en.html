<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft, English + with Extension + Collection Pipelines)</title>
  <style>
    /* Minimal layout only. Let the browser choose the fonts. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1rem;
    }
    .sidebar h2 {
      font-size: 0.8rem;
      margin: 0.8rem 0 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.85rem;
    }
    .sidebar nav li {
      margin: 0.1rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.2rem 0.35rem;
      border-radius: 0.3rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar a.active {
      background: #1d4ed8;
      color: #e5e7eb;
    }
    .chapter-index {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.3rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 1.8rem 2.4rem;
      box-sizing: border-box;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.4em;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #f3f4f6;
      padding: 0.7rem 0.9rem;
      border-radius: 0.4rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 1.8rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }

    .chapter {
      display: none;
    }
    .chapter.active {
      display: block;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Left menu -->
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="subtitle">
      Draft / English + <code>with</code> Extension + Collection Pipeline DSL
    </div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a class="nav-link active" data-target="ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a class="nav-link" data-target="ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a class="nav-link" data-target="ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a class="nav-link" data-target="ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a class="nav-link" data-target="ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a class="nav-link" data-target="ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a class="nav-link" data-target="ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a class="nav-link" data-target="ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a class="nav-link" data-target="ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a class="nav-link" data-target="ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a class="nav-link" data-target="ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a class="nav-link" data-target="ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a class="nav-link" data-target="ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a class="nav-link" data-target="ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a class="nav-link" data-target="ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a class="nav-link" data-target="ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a class="nav-link" data-target="ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a class="nav-link" data-target="ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a class="nav-link" data-target="ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
        <li><a class="nav-link" data-target="ch19"><span class="chapter-index">19.</span>Collection Pipeline DSL</a></li>
      </ul>
    </nav>

    <h2>Key Sections</h2>
    <nav>
      <ul>
        <li><a class="nav-link" data-target="ch4">4.2 with-blocks</a></li>
        <li><a class="nav-link" data-target="ch19">19. Collection Pipeline DSL</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Right content -->
  <main class="content">
    <h1>Aloe Language Specification (Draft, English)</h1>
    <p class="note">
      Based on the original document: <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>,<br />
      with the following extensions:
      <br />
      <strong>4.2 with-blocks</strong> is extended with “dot-elision + type-based with (static / enum shortcut for class/struct/enum)”.<br />
      All method / property / field names in samples are aligned to <strong>PascalCase</strong> (leading uppercase).<br />
      In addition, this draft adds <strong>Chapter 19: Collection Pipeline DSL</strong>
      (<code>|:</code> / <code>| map</code> /
      <code>| sort</code> / <code>| union</code> / <code>as</code> / <code>with(Alias) where(...)</code>).
    </p>

    <!-- 0. Overview -->
    <section class="chapter active" id="ch0">
      <hr />
      <h2>0. Overview</h2>
      <p>
        Aloe is a statically typed scripting language with simple and intuitive syntax,
        running on a stack-based virtual machine (AloeVM).
      </p>
      <ul>
        <li>Easy to read and write for education and small applications.</li>
        <li>Targets both C# runtime and WASM environments.</li>
        <li>Provides static-typed control over I/O and concurrency via <code>pipe</code> and <code>filter</code>.</li>
      </ul>
      <p>Main features:</p>
      <ul>
        <li>Static typing
          <ul>
            <li><code>var</code> for type inference.</li>
            <li><code>let</code> for explicit type annotation.</li>
          </ul>
        </li>
        <li>Value types / Reference types
          <ul>
            <li><code>struct</code> … value type</li>
            <li><code>class</code> … reference type</li>
          </ul>
        </li>
        <li>GC-based memory management (algorithm is VM implementation–dependent).</li>
        <li>No explicit <code>= null</code> in code (use <code>delete</code> instead).</li>
        <li>Dataflow-oriented design using <code>pipe</code> / <code>filter</code>.</li>
      </ul>
    </section>

    <!-- 1. Basic Syntax -->
    <section class="chapter" id="ch1">
      <hr />
      <h2>1. Basic Syntax</h2>

      <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
      <ul>
        <li><code>//</code> to end of line is a line comment.</li>
        <li><code>/* ... */</code> is a multi-line comment.</li>
        <li>Nested <code>/* */</code> is undefined (not supported).</li>
      </ul>

      <h3>1.2 Identifiers</h3>
      <ul>
        <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
        <li>First character must be a letter or <code>_</code>.</li>
        <li>Case-sensitive.</li>
        <li>Cannot use keywords as identifiers.</li>
        <li>Identifiers starting with <code>_</code> are conventionally “private”.</li>
        <li>Some Unicode characters can be used (excluding whitespace and punctuation separators).</li>
      </ul>

      <h3>1.3 Keywords</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
      <ul>
        <li>Use <code>namespace</code> instead of <code>package</code>.</li>
        <li><code>final</code> is removed; use <code>sealed</code> instead.</li>
        <li><code>instanceof</code> is removed; use <code>is</code> instead.</li>
      </ul>

      <h3>1.4 Literals</h3>
      <ul>
        <li>Integers: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
        <li>Floating point: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
        <li>Decimal: <code>10.12345678901234567890:d</code> etc.</li>
        <li>Boolean: <code>true</code>, <code>false</code></li>
        <li>String: <code>"Hello, World!"</code></li>
        <li>Char: <code>'A'</code>, <code>'z'</code>, etc.</li>
        <li>null literal: <code>null</code> (not used directly in assignments)</li>
        <li>Array literal: <code>[1, 2, 3]</code></li>
        <li>List literal: <code>(1, 2, 3)</code></li>
        <li>Set literal: <code>{1, 2, 3}</code></li>
        <li>Map literal: <code>["key1": 10, "key2": 20]</code></li>
        <li>enum literal: <code>EnumType.Value1</code></li>
        <li>struct literal: <code>Point { X: 0, Y: 1 }</code></li>
        <li>Object creation: <code>new ClassName()</code></li>
      </ul>

      <h3>1.5 Statement terminator</h3>
<pre><code>var X = 10;
X = X + 1;
Print(X);
</code></pre>
      <ul>
        <li>Every statement ends with <code>;</code>.</li>
        <li>No automatic semicolon insertion based on newlines.</li>
      </ul>

      <h3>1.6 Whitespace / 1.7 Case sensitivity</h3>
      <ul>
        <li>Whitespace, tabs, and newlines separate tokens.</li>
        <li>Multiple whitespace characters are treated as a single separator.</li>
        <li>Indentation has no semantic meaning.</li>
        <li>Identifiers and keywords are case-sensitive.</li>
        <li>All keywords are lowercase.</li>
      </ul>
    </section>

    <!-- 2. Type System -->
    <section class="chapter" id="ch2">
      <hr />
      <h2>2. Type System</h2>

      <h3>2.1 Primitive types</h3>
      <ul>
        <li><code>int</code> / <code>integer</code></li>
        <li><code>float</code></li>
        <li><code>bool</code> / <code>boolean</code></li>
        <li><code>decimal</code></li>
        <li><code>string</code></li>
        <li><code>char</code></li>
        <li><code>byte</code></li>
        <li><code>void</code></li>
        <li><code>null</code> (literal)</li>
      </ul>

      <h3>2.2 Composite / user-defined types</h3>
      <ul>
        <li>Array: <code>T[]</code></li>
        <li>List: <code>T()</code></li>
        <li>Set: <code>T{}</code></li>
        <li>Map: <code>map&lt;T&gt;</code> / <code>map&lt;K/V&gt;</code></li>
        <li><code>struct</code>, <code>class</code>, <code>enum</code>, <code>bitfield enum</code></li>
        <li><code>task</code>, <code>pipe&lt;T&gt;</code></li>
      </ul>

      <h3>2.3 Value / reference types</h3>
      <ul>
        <li>Value types: primitives + struct + enum / bitfield enum.</li>
        <li>
          Reference types: class, string,
          collection types such as arrays / lists / sets / maps,
          task, pipe, etc.
        </li>
      </ul>
      <h4>Struct restrictions</h4>
      <ul>
        <li>Struct fields may only be primitives or other struct types.</li>
        <li>
          Collection types such as arrays / lists / sets / maps and other reference types
          such as class are not allowed as struct fields.
        </li>
        <li>Struct assignment is by value copy.</li>
      </ul>
    </section>

    <!-- 3. Numbers & Conversions -->
    <section class="chapter" id="ch3">
      <hr />
      <h2>3. Numbers &amp; Conversions</h2>

      <h3>3.1 int / float</h3>
      <ul>
        <li>When mixed in expressions, values are promoted to <code>float</code>.</li>
      </ul>

      <h3>3.2 decimal</h3>
      <ul>
        <li>High-precision decimal type. Overflow etc. result in <code>OverflowException</code>.</li>
      </ul>

      <h3>3.3 enum and int</h3>
      <ul>
        <li>No cast syntax.</li>
        <li>No implicit or explicit conversion between enum and int.</li>
      </ul>

      <h3>3.4 byte / char</h3>
      <ul>
        <li><code>byte</code>: 0–255. Mixed with <code>int</code> promotes to <code>int</code>.</li>
        <li><code>char</code>: no arithmetic. Comparisons only between chars.</li>
      </ul>

      <h3>3.5 NaN / Infinity</h3>
      <ul>
        <li>NaN/Infinity are handled via exceptions rather than values.</li>
        <li><code>ZeroDivisionException</code> represents division by zero.</li>
        <li>
          Helpers such as <code>IsNaN</code>, <code>IsInfinity</code> can be provided as standard library functions,
          and should be written in PascalCase.
        </li>
      </ul>
    </section>

    <!-- 4. Blocks & Scope + with -->
    <section class="chapter" id="ch4">
      <hr />
      <h2>4. Blocks &amp; Scope</h2>

      <h3>4.1 Static scope and shadowing</h3>
<pre><code>class Sample {
    field Value: int = 1;

    method Foo(): void {
        var Value = 2;        // Shadows the field
        Print(Value);         // 2
        Print(this.Value);    // 1
    }
}
</code></pre>
      <ul>
        <li>Aloe uses static (lexical) scoping.</li>
        <li>A variable declared in an inner block shadows the outer one.</li>
        <li>When a field and a local share the same name, the local wins; fields are accessed as <code>this.Name</code>.</li>
      </ul>

      <h3>4.2 with-blocks (member access shorthand)</h3>
      <p>Syntax to simplify member access on objects.</p>
<pre><code>with (User) {
    Name = "Alice";
    Age  = Age + 1;
    Print(Name);
}
</code></pre>
      <ul>
        <li>Form: <code>with (Expr1)</code> or <code>with (Expr1), (Expr2), ...</code>.</li>
        <li>Each Expr is evaluated exactly once at the beginning of the block and bound to an internal temporary.</li>
        <li>Resolution order for simple identifiers inside a with-block:
          <ol>
            <li>Locals / parameters in the current block</li>
            <li>Members (fields / properties / methods) of with-targets from left to right</li>
            <li>Outer scopes (outer blocks, class fields, etc.)</li>
          </ol>
        </li>
        <li>If multiple targets have a member with the same name, it is ambiguous and a compile error.</li>
        <li>
          Special temporary <code>_</code> refers to the “first with-target (Expr1)”:
          <ul>
            <li>You can pass it like <code>Log(_)</code>.</li>
          </ul>
        </li>
      </ul>

      <h4>4.2.1 Multiple targets with</h4>
<pre><code>with (User), (Profile) {
    Name = "Alice";          // Resolves to User.Name or Profile.Name
    UpdateProfile();         // Resolves to User.UpdateProfile() or Profile.UpdateProfile()
}
</code></pre>
      <ul>
        <li>Resolution order is left to right.</li>
        <li>If multiple targets define the same member name, it is a compile error.</li>
      </ul>

      <h4>4.2.2 Nested with</h4>
<pre><code>with (User) {
    Name = "Alice";

    with (Address) {
        City = "Tokyo";   // Address.City
        Print(Name);      // Resolves to User.Name or a local Name
    }
}
</code></pre>
      <ul>
        <li>Inner with has its own resolution rules.</li>
        <li>Unresolved identifiers fall back to outer scopes.</li>
      </ul>

      <h4>4.2.3 Type-based with (class / struct / enum)</h4>
      <p>
        If a <strong>type name</strong> is given instead of an expression,
        the block can access that type’s <strong>static members / enum constants</strong> directly.
      </p>
<pre><code>with (AngleUtil) {
    var Rad  = DegToRad(90.0);   // AngleUtil.DegToRad(90.0)
    var Rad2 = DegToRad(45.0);
    Print(Pi);                   // AngleUtil.Pi
}
</code></pre>
      <ul>
        <li>Allowed as type-based with target:
          <ul>
            <li>class</li>
            <li>struct</li>
            <li>enum / bitfield enum</li>
          </ul>
        </li>
        <li>Resolution order for simple identifiers in type-based with:
          <ol>
            <li>Locals / parameters</li>
            <li>Static fields / static methods / enum constants of the target type</li>
            <li>Outer scopes</li>
          </ol>
        </li>
        <li>Accessing instance members is a compile error.</li>
        <li>
          Special <code>_</code> can be treated as a pseudo object representing
          the static context of the first type target
          (writing <code>_.Member</code> is allowed but equivalent to <code>Member</code>).
        </li>
      </ul>

      <h5>Example: struct / class</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(Deg: float): float {
        return Deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(A: int, B: int): int {
        if (A > B) return A;
        return B;
    }
}

main(Args: string[]) {
    with (AngleUtil) {
        var Rad  = DegToRad(90.0);
        var Rad2 = DegToRad(45.0);
        Print(Pi);
    }

    with (MathUtil) {
        var M = Max(10, 20);
        Print(M);
    }
}
</code></pre>

      <h5>Example: enum</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

main(Args: string[]) {
    with (Color) {
        var C1: Color = Red;   // Color.Red
        var C2: Color = Blue;  // Color.Blue
        Print(C1);
        Print(C2);
    }
}
</code></pre>

      <h5>Mixing value targets + type targets</h5>
<pre><code>with (User), (Color) {
    Name = "Alice";      // User.Name
    var C: Color = Red;  // Color.Red
}
</code></pre>
      <p class="note">
        Value targets and type targets are combined into one “candidate set of members”.
        If more than one candidate is found for the same identifier, it is a compile error.
      </p>
    </section>

    <!-- 5. Variables & Constants -->
    <section class="chapter" id="ch5">
      <hr />
      <h2>5. Variables &amp; Constants</h2>

      <h3>5.1 var (type inference)</h3>
<pre><code>var I = 10;
var F = 10.5;
var S = "Hello";
var C = 'A';
var B = 255;
var Arr = [1, 2, 3];
var Lst = (1, 2, 3);
var St  = {1, 2, 3};
var Fb  = new FizzBuzz();
</code></pre>

      <h3>5.2 let (explicit type)</h3>
<pre><code>let I: int = 10;
let F: float = 10.5;
let D: decimal = 10.12345678901234567890:d;
let S: string = "Hello, Aloe!";
let C: char = 'A';
let B: byte = 255;

let Arr: int[] = [1, 2, 3];
let Lst: int() = (1, 2, 3);
let St : int{} = {1, 2, 3};
let Mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

      <h3>5.3 const</h3>
<pre><code>const MaxCount: int = 100;
const PiConst : float = 3.14159;
const AppName : string = "Aloe VM";
</code></pre>
    </section>

    <!-- 6. Fields -->
    <section class="chapter" id="ch6">
      <hr />
      <h2>6. Fields</h2>
<pre><code>class Sample {
    field Count: int = 0;
    field Name : string = "default";

    readonly field Id: int;

    construct(Id: int) {
        this.Id = Id; // OK
    }

    method Change(): void {
        this.Count = this.Count + 1;
        // this.Id = 2; // NG
    }
}
</code></pre>
    </section>

    <!-- 7. Class / Struct / Interface / Trait -->
    <section class="chapter" id="ch7">
      <hr />
      <h2>7. Class / Struct / Interface / Trait</h2>

      <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name : string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var I = 1;
        while (I &lt;= 100) {
            // ...
            I = I + 1;
        }
    }
}
</code></pre>

      <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(X: int, Y: int) {
        this.X = X;
        this.Y = Y;
    }
}
</code></pre>

      <h3>7.3 Inheritance / sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
}
</code></pre>

      <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(Msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(Msg: string): void {
        Print(Msg);
    }
}
</code></pre>

      <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method Hello(): void {
        Print("Hello from Trait_A");
    }
}
</code></pre>

      <h4>Applying with with</h4>
<pre><code>var Obj = new SomeClass() with Trait_A;
Obj.Hello();
</code></pre>

      <h4>Non-destructive add/remove</h4>
<pre><code>var Obj2 = Obj + Trait_A;
var Obj3 = Obj2 - Trait_A;
</code></pre>

      <h4>Alias as</h4>
<pre><code>var Obj2 = Obj + Trait_A as A;
Obj2.A.Hello();
// Obj2.Hello(); // NG
</code></pre>
    </section>

    <!-- 8. delete & null -->
    <section class="chapter" id="ch8">
      <hr />
      <h2>8. delete &amp; null</h2>
<pre><code>var Obj = new FizzBuzz();
delete Obj;   // Equivalent to Obj = null at VM level
</code></pre>
    </section>

    <!-- 9. is -->
    <section class="chapter" id="ch9">
      <hr />
      <h2>9. is Operator (type check)</h2>
<pre><code>if (Obj is FizzBuzz) {
}

if (Obj is ILogger) {
}

if (Obj is Trait_A) {
}
</code></pre>
    </section>

    <!-- 10. Collections -->
    <section class="chapter" id="ch10">
      <hr />
      <h2>10. Collections (Array / List / Set / Map)</h2>
<pre><code>var Arr: int[] = [1, 2, 3];
var Matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];

var Lst: int() = (1, 2, 3);
var ObjLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());

var St: int{} = {1, 2, 3};
var StructSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};

var Mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var Mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var ObjMp: map&lt;FizzBuzz&gt; = ["Obj1": new FizzBuzz(), "Obj2": new FizzBuzz()];
</code></pre>
    </section>

    <!-- 11. enum -->
    <section class="chapter" id="ch11">
      <hr />
      <h2>11. enum / bitfield enum</h2>

      <h3>11.1 enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>

      <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

      <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // Here it is assigned b(4)
}
</code></pre>
    </section>

    <!-- 12. main -->
    <section class="chapter" id="ch12">
      <hr />
      <h2>12. main Block (entry point)</h2>
<pre><code>main(Args: string[]) {
    var Fb = new FizzBuzz();
    Fb.Run();

    _ = 0;   // Process exit code
}
</code></pre>
    </section>

    <!-- 13. temp variable _ -->
    <section class="chapter" id="ch13">
      <hr />
      <h2>13. Temp Variable <code>_</code></h2>
<pre><code>method Foo(): void {
    var X = 10;
    _ = X + 5;   // Temporary result within this block
}
</code></pre>
      <p class="note">
        In <code>main</code>, <code>_</code> is fixed to int (exit code).
        In other blocks, the type of <code>_</code> is determined by the first assignment.<br />
        For interaction with <code>with</code>, see section 4.2.
      </p>
    </section>

    <!-- 14. swap -->
    <section class="chapter" id="ch14">
      <hr />
      <h2>14. swap Keyword</h2>
<pre><code>var A = 10;
var B = 20;
swap (A, B);
</code></pre>
    </section>

    <!-- 15. Operators -->
    <section class="chapter" id="ch15">
      <hr />
      <h2>15. Operators</h2>
      <p>Precedence and associativity follow the original spec (omitted here).</p>
    </section>

    <!-- 16. Exceptions -->
    <section class="chapter" id="ch16">
      <hr />
      <h2>16. Exceptions</h2>
<pre><code>try {
    // ...
}
catch (E) {
}
finally {
}
</code></pre>
      <p>
        The hierarchy of standard exceptions (such as <code>NullReferenceException</code>,
        <code>OverflowException</code>, etc.) follows the original spec.
      </p>
    </section>

    <!-- 17. Modules -->
    <section class="chapter" id="ch17">
      <hr />
      <h2>17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
    }
}
</code></pre>
    </section>

    <!-- 18. Pipes & Filters -->
    <section class="chapter" id="ch18">
      <hr />
      <h2>18. Pipes &amp; Filters</h2>

      <h3>18.1 pipe&lt;T&gt;</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> is a stream of T.</li>
        <li><code>stdin</code>, <code>stdout</code> etc. are assumed as built-in pipes.</li>
      </ul>
      <p class="note">
        What flows through the pipeline is not the “context” itself, but always data of type T.<br />
        Required context (OrderId / UserId etc.) should be explicitly included as fields
        of the message struct / class that flows through the pipe.
      </p>
      <p class="note">
        In concrete implementations, the pipe can be backed by files / sockets / network streams, etc.,<br />
        or connected to filters running in other processes or even other nodes.<br />
        The distributed execution model itself is left to the AloeVM implementation.
      </p>

      <h3>18.2 Defining a filter</h3>
<pre><code>filter LineSplit {
    in : pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(Input, Output) {
        foreach (Chunk in Input) {
            let Lines = Chunk.Split("\n");
            foreach (Line in Lines) {
                Output.Write(Line);
            }
        }
        Output.Close();
    }
}
</code></pre>

      <h3>18.3 Pipeline statement</h3>
<pre><code>stdin
    | filter(Utf8)
    | filter(Json&lt;User&gt;)
    | Users;
</code></pre>

      <h3>18.4 foreach / EOF</h3>
<pre><code>foreach (Line in Lines) {
    Print(Line);
}
</code></pre>

      <p class="note">
        Detailed runtime behavior of pipe / filter is delegated to the AloeVM spec.
      </p>
    </section>

    <!-- 19. Collection Pipelines DSL -->
    <section class="chapter" id="ch19">
      <hr />
      <h2>19. Collection Pipelines (Collection Pipeline DSL)</h2>

      <p>
        This chapter defines a LINQ-like “query DSL” that targets <code>Iterable&lt;T&gt;</code>.<br />
        It is a different layer from chapter 18’s <code>pipe&lt;T&gt;</code> / <code>filter</code> stream processing,<br />
        and is mainly for describing filter / transform / sort / union operations on in-memory collections.
      </p>

      <h3>19.1 Basic syntax (pipeline as a whole)</h3>
<pre><code>PipelineExpr ::=
    Expr
    ( '|' PipeSegment )*

PipeSegment ::=
      ':' ConditionExpr          // |:
    | 'map' MapExpr              // | map ...
    | 'sort' SortKey [asc|desc]  // | sort ...
    | 'union' Expr               // | union ...
</code></pre>
      <ul>
        <li>The pipeline is evaluated from left to right.</li>
        <li>Each <code>PipeSegment</code> takes the previous result collection as input and returns a new collection.</li>
        <li>The result is an <code>Iterable&lt;...&gt;</code>-like collection (exact runtime type depends on VM / runtime implementation).</li>
      </ul>

      <h3>19.2 Collection alias: <code>as Alias</code></h3>
      <p>
        Appending <code>as Alias</code> right after a collection expression defines an explicit “element alias”
        that can be used in the rest of the pipeline.
      </p>
<pre><code>Orders as o
    |: Status == "Completed"
    | sort o.OrderDate desc;
</code></pre>
      <ul>
        <li><code>Orders as o</code> declares that each element of Orders is referred to as <code>o</code>.</li>
        <li>In the right-hand side of <code>|:</code>, <code>| map</code>, and <code>| sort</code>, identifiers use this alias for resolution.</li>
        <li>If no alias is specified, the rules of “implicit element” (see 19.3.2) are used.</li>
      </ul>

      <h3>19.3 Filter pipe: <code>|:</code></h3>

      <h4>19.3.1 Semantics</h4>
      <p><code>|:</code> is a filter pipe that keeps only elements matching the condition.</p>
<pre><code>Orders as o
    |: Status == "Completed"
    |: Total  >= 10000;
</code></pre>
      <p>Conceptually, the implementation may look like this (pseudo code):</p>
<pre><code>Filter(Orders, (o) =&gt; o.Status == "Completed")
    .Filter((o) =&gt; o.Total &gt;= 10000);
</code></pre>

      <h4>19.3.2 Identifier resolution inside filters</h4>
      <p>
        With <code>as Alias</code>, the resolution order for simple identifiers on the right-hand side of <code>|:</code> is:
      </p>
      <ol>
        <li>Locals / parameters</li>
        <li>Alias’s properties (<code>Alias.Property</code>)</li>
        <li>If still unresolved, it is a compile error.</li>
      </ol>
<pre><code>let MinScore = 80;

Orders as o
    |: Status == "Completed"   // = o.Status
    |: Total  >= MinScore;     // MinScore is a local variable
</code></pre>
      <p>You can always make the alias explicit:</p>
<pre><code>Orders as o
    |: o.Status == "Completed"
    |: o.Total  >= MinScore;
</code></pre>
      <p>
        Without an alias, identifiers are interpreted as properties of the implicit element.
      </p>
<pre><code>Orders
    |: Status == "Completed"   // implicitElement.Status
    |: Total  >= 10000;
</code></pre>

      <h3>19.4 Transform pipe: <code>| map</code></h3>
      <p><code>| map</code> returns a sequence where each element is mapped to another value / type.</p>
<pre><code>let UserNames =
    Users as u
        | map Name;      // = u.Name
</code></pre>
      <ul>
        <li>The result is an <code>Iterable&lt;...&gt;</code> whose element type is the type of the right-hand side expression.</li>
      </ul>
      <p>Combined with object initialization, this can be used to convert to DTO / ViewModel types:</p>
<pre><code>let UserDtos =
    Users as u
        | map UserDto {
              Id       = Id      // = u.Id
              Name     = Name
              Score    = Score
              IsActive = IsActive
          };
</code></pre>

      <h3>19.5 Sort pipe: <code>| sort</code></h3>
      <p><code>| sort KeyExpr [asc|desc]</code> sorts elements based on the key expression.</p>
<pre><code>let TopUsers =
    Users as u
        |: IsActive
        | sort Score desc
        | take 100;
</code></pre>
      <ul>
        <li><code>KeyExpr</code> is resolved with the same rules as 19.3.2.</li>
        <li><code>asc</code> (ascending) may be treated as the default and omitted (implementation-dependent).</li>
      </ul>

      <h3>19.6 Union pipe: <code>| union</code></h3>
      <p><code>| union</code> returns a collection that is the union of two collections.</p>
<pre><code>let AllOrders =
    myOrders
        | union yourOrders;
</code></pre>
      <ul>
        <li>Left-hand side: collection produced by the previous pipeline segments.</li>
        <li>Right-hand side: any collection expression <code>Expr</code>.</li>
        <li>
          Result: a collection combining elements from both sides
          (handling of duplicates / keys is delegated to library design).
        </li>
      </ul>
      <p>
        Because of the pipeline nature, in the following code:
      </p>
<pre><code>myOrders
    | union yourOrders
    |: Status == "Completed";
</code></pre>
      <p>
        <code>|:</code> always filters the result of <code>union(myOrders, yourOrders)</code>.<br />
        There is no ambiguity as to which source collection is filtered.
      </p>
      <p>
        When you also want to use another pipeline on the right-hand side expression,
        you must use parentheses for grouping.
      </p>
<pre><code>let MergedHighValue =
    myOrders
        | union (
            yourOrders
                |: Status == "Completed"
                |: Total  >= 10000
        )
        |: Total >= 10000;
</code></pre>
      <ul>
        <li>The right-hand side <code>(yourOrders |: ...)</code> is evaluated first, then unioned with <code>myOrders</code>.</li>
        <li>The trailing <code>|:</code> filters the union result.</li>
      </ul>

      <h3>19.7 Combining <code>as Alias</code> with <code>| union</code></h3>
<pre><code>let MergedWithOwner =
    (myOrders
        | map Order {
              Id        = Id
              Total     = Total
              OrderDate = OrderDate
              Owner     = "Me"
          })
    | union
      (yourOrders
        | map Order {
              Id        = Id
              Total     = Total
              OrderDate = OrderDate
              Owner     = "You"
          })
    as o
        |: Total >= 10000
        | sort o.OrderDate desc;
</code></pre>
      <ul>
        <li>Both sequences are mapped to the same <code>Order</code> type before union.</li>
        <li><code>as o</code> defines the alias for unioned elements, which is then used by <code>|:</code> and <code>| sort</code>.</li>
      </ul>

      <h3>19.8 Complex condition blocks with <code>with(Alias) where(...)</code></h3>
      <p>
        When conditions become long and you want to group them, you can use
        <code>with(Alias) where(...)</code> to write a “filter block bound to an alias”.
      </p>
<pre><code>let TopActiveUsersJP =
    Orders as o
        |: Status == "Completed"             // = o.Status
        | with(o) where(
              o.User.IsActive
              && o.User.Score   >= MinScore
              && o.User.Country == "JP"
          )
        | sort o.OrderDate desc
        | take 50
        | map UserSummary {
              UserId   = o.User.Id
              UserName = o.User.Name
              Total    = o.Total
          };
</code></pre>
      <ul>
        <li><code>| with(o) where(Condition)</code> is also a kind of filter pipe.</li>
        <li>
          <code>Condition</code> is an ordinary expression where you access element properties through
          the alias <code>o</code>.
        </li>
        <li>
          This is distinct from the <code>with</code> statement in chapter 4.2:
          it is “with as a pipeline filter”.
        </li>
      </ul>
      <p class="note">
        <code>with(Alias)</code> is intended for cases where you want to emphasize the alias and group
        the condition; for simple conditions, using <code>|:</code> is the recommended style.
      </p>

      <h3>19.9 Typical examples</h3>

      <h4>19.9.1 Simple filter + sort + map</h4>
<pre><code>let TopActiveUsersJP =
    Users as u
        |: IsActive
        |: Age >= 18
        |: Country == "JP"
        | sort Score desc
        | take 100
        | map UserSummary {
              Id    = Id
              Name  = Name
              Score = Score
          };
</code></pre>

      <h4>19.9.2 Conditions involving both Order and User</h4>
<pre><code>let TopActiveOrdersJP =
    Orders as o
        |: Status == "Completed"
        | with(o) where(
              o.User.IsActive
              && o.User.Score   >= MinScore
              && o.User.Country == "JP"
          )
        | sort o.OrderDate desc
        | take 50
        | map OrderSummary {
              OrderId   = o.Id
              UserId    = o.User.Id
              UserName  = o.User.Name
              Total     = o.Total
          };
</code></pre>

      <h4>19.9.3 myOrders / yourOrders with union + map</h4>
<pre><code>let MergedOrders =
    myOrders
        | union yourOrders;

let MergedWithOwner =
    (myOrders
        | map Order {
              Id        = Id
              Total     = Total
              OrderDate = OrderDate
              Owner     = "Me"
          })
    | union
      (yourOrders
        | map Order {
              Id        = Id
              Total     = Total
              OrderDate = OrderDate
              Owner     = "You"
          })
    as o
        | sort o.OrderDate desc;
</code></pre>

      <hr />
      <p class="note">
        The above defines the Collection Pipeline DSL (<code>|:</code> / <code>| map</code> /
        <code>| sort</code> / <code>| union</code> / <code>as</code> / <code>with(Alias) where(...)</code>).<br />
        Combined with chapter 18’s <code>pipe</code> / <code>filter</code> stream processing,
        Aloe source code can express both dataflow and query-like transformations concisely.
      </p>
    </section>

  </main>
</div>

<script>
  (function() {
    var links = document.querySelectorAll('.nav-link');
    var chapters = document.querySelectorAll('.chapter');

    function showChapter(id) {
      chapters.forEach(function(ch) {
        ch.classList.toggle('active', ch.id === id);
      });
      links.forEach(function(a) {
        a.classList.toggle('active', a.getAttribute('data-target') === id);
      });
    }

    links.forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        var target = this.getAttribute('data-target');
        if (!target) return;
        showChapter(target);
        if (history.replaceState) {
          history.replaceState(null, '', '#' + target);
        }
      });
    });

    var hash = window.location.hash.replace('#', '');
    if (hash && document.getElementById(hash)) {
      showChapter(hash);
    }
  })();
</script>
</body>
</html>
