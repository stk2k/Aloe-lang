Â§öÂàÜ„ÄÅlang="en" „Å´„Åó„Åü„Åõ„ÅÑ„Åß„Éñ„É©„Ç¶„Ç∂„Åå„ÄåËã±Ë™ûÁî®„Éï„Ç©„É≥„Éà„Äç„Å´Âàá„ÇäÊõø„Çè„Å£„Å¶„Çã„Åõ„ÅÑ„Å†„Å≠„ÄÇ
ÂÖÉ„ÅÆÊó•Êú¨Ë™ûÁâà„Å®Âêå„Åò„Éé„É™„Åß„Äå„Éï„Ç©„É≥„Éà„ÅØ„Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ‰ªª„Åõ„Äç„Å´Êàª„Åô„Å™„Çâ„ÄÅlang="ja" „Å´„Åó„Å¶„Åä„Åè„ÅÆ„Åå‰∏ÄÁï™Êâã„Å£Âèñ„ÇäÊó©„ÅÑ„ÄÇ

üí°„Å™„ÅÆ„Åß Â§âÊõ¥ÁÇπ„ÅØ 1 ÁÆáÊâÄ„Å†„ÅëÔºö

<html lang="en"> ‚Üí <html lang="ja">


„Åù„Çå‰ª•Â§ñ„ÅØ„Åù„ÅÆ„Åæ„Åæ„Åß„Åô„ÄÇÂÖ®ÈÉ®Ë≤º„Çã„Å≠„ÄÇ

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft, Pipe/Filter/Producer/Consumer)</title>
  <style>
    /* Keep layout minimal, leave fonts to browser defaults */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="tagline">Draft / Pipe¬∑Filter¬∑Producer¬∑Consumer</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#functions-methods">5. Functions &amp; Methods</a>

      <div class="section-title">Pipe / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>

      <div class="section-title">Syntax Extensions</div>
      <a href="#with">7. with Statement</a>
      <a href="#lock">8. lock Statement &amp; Sync</a>

      <div class="section-title">Control &amp; Runtime</div>
      <a href="#exceptions">9. Exceptions</a>
      <a href="#runtime">10. Runtime &amp; Memory</a>

      <div class="section-title">Misc</div>
      <a href="#limits">11. Limitations &amp; Future Work</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an <strong>experimental programming language</strong> with static typing,
        a small and simple syntax, and a stack-based virtual machine (AloeVM).
        It is especially designed around <strong>Pipe / Filter style dataflow</strong>
        and good affinity with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type-checked at compile time)</li>
        <li>C-like surface syntax with minimal feature set</li>
        <li>Optimized for ‚Äúflowing and transforming data‚Äù such as text processing,
          REST calls, log processing, etc.</li>
        <li>Implementation targets a small stack-based VM (AloeVM) with
          a future WebAssembly backend in mind</li>
      </ul>
      <p class="note">
        This document is a <strong>draft language specification</strong>.
        The actual compiler and VM implementation may diverge from this text.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readable</strong>: It should read like a language spec / documentation.</li>
        <li><strong>Implementable</strong>: A small compiler and VM should be enough.</li>
        <li><strong>Consistent Pipe / Filter</strong>: Type-safe expression of dataflow.</li>
        <li><strong>Wasm bridge</strong>: Easy to connect to WebAssembly component model in the future.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>‚ÄúDo everything‚Äù general-purpose language scope.</li>
        <li>Competing with JIT-optimized languages in raw performance.</li>
        <li>Complex metaprogramming (macros, etc.) for now.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source encoding is assumed to be UTF-8.</li>
        <li>Single-line comments: <code>// comment</code></li>
        <li>Multi-line comments: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifiers start with a letter or <code>_</code>, followed by letters or digits.</li>
        <li>Keywords are reserved and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr><td>Declarations</td><td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code></td></tr>
        <tr><td>Control</td><td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code></td></tr>
        <tr><td>Functions</td><td><code>method</code></td></tr>
        <tr><td>Helpers</td><td><code>with</code>, <code>lock</code></td></tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Statements usually end with a semicolon <code>;</code>.</li>
        <li>Blocks are surrounded by <code>{ ... }</code>.</li>
        <li>Conditions in control constructs must have type <code>Bool</code>.</li>
      </ul>

      <pre><code>// variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation-defined, 32-bit assumed).</td></tr>
        <tr><td><code>Float</code></td><td>Floating point (32 or 64-bit, implementation-defined).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-defined).</td></tr>
      </table>

      <h3>4.2 Arrays &amp; Collections</h3>
      <ul>
        <li>Fixed-length arrays: <code>T[]</code></li>
        <li>Variable or lazy collections are represented by <code>Pipe&lt;T&gt;</code> (see section 6).</li>
      </ul>

      <h3>4.3 Structs</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type, copied on assignment.</li>
        <li>Shallow copy semantics; sharing of nested reference types depends on the VM design.</li>
      </ul>

      <h3>4.4 Enums</h3>
      <ul>
        <li><code>enum</code> is always represented internally as <strong><code>Int</code></strong>.</li>
        <li>Generic enums such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are <strong>forbidden</strong>.</li>
        <li>For bitflag-style enums, the maximum number of flags is 32.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="functions-methods">
      <h2>5. Functions &amp; Methods</h2>

      <h3>5.1 method</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> declares a top-level function or a method bound to a type.</li>
        <li>If no return type is specified, it is treated as <code>Unit</code>.</li>
      </ul>

      <h3>5.2 bound for Method Binding</h3>
      <p>
        Aloe introduces <code>bound</code> to attach methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // internal representation is VM-dependent
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, methods defined inside <code>bound Pipe&lt;T&gt;</code>
        are subject to a <strong>return type restriction</strong> (see section 6.2).
      </p>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        The main feature of Aloe is that it makes <strong>Pipe / Filter style dataflow</strong>
        first-class and type-safe.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, this is equivalent to:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>The <code>|&gt;</code> operator is sugar for such function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the ‚Äúpipe world‚Äù in Aloe.
          It is similar to lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> is ‚Äúa pipe of elements of type <code>T</code>‚Äù.</li>
          <li>Internal representation (iterator chain, coroutine, etc.) is VM-dependent.</li>
          <li>The standard library is designed around <code>Pipe&lt;T&gt;</code>
            with producers / transformers / consumers.
          </li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // VM-dependent internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the space of functions and objects
          that take and return <code>Pipe&lt;T&gt;</code>.
          Consumers are the exit points from this world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, functions (or objects) are categorized
          into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>: A function or object whose return type is <code>Pipe&lt;*&gt;</code>,
            used at the beginning of a pipeline.</li>
          <li><strong>Role</strong>: Reads data from the outside world (files, HTTP, arrays, etc.)
            and injects it into the pipe world (<code>Pipe&lt;T&gt;</code>).</li>
          <li><strong>Type-level</strong>: Has the shape <code>X -&gt; Pipe&lt;T&gt;</code>.
            By design, <strong>anything declared as a Producer must always output a <code>Pipe&lt;*&gt;</code></strong>.
          </li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filter)</h4>
        <ul>
          <li><strong>Definition</strong>: A function or method with type <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.</li>
          <li><strong>Role</strong>: Performs mapping, filtering, sorting, etc. inside the pipe world,
            without leaving it.</li>
        </ul>

        <p>
          In Aloe, methods defined in <strong><code>bound Pipe&lt;T&gt;</code></strong>
          are considered transformers by default.
        </p>

        <div class="note">
          <strong>Restriction:</strong><br />
          Methods declared inside <code>bound Pipe&lt;T&gt;</code> must
          <strong>always return some <code>Pipe&lt;*&gt;</code></strong>.<br />
          That is, they must have the shape <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; { ... }

  // OK: transforms element type
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; { ... }

  // NG: Not returning Pipe -- should be a compile-time error
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer (Terminal Filter)</h4>

        <ul>
          <li><strong>Definition</strong>:
            A function or object of type <code>Pipe&lt;T&gt; -&gt; R</code>,
            where <code>R</code> is not a <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><strong>Role</strong>:
            Exit point of the pipe world. Consumes a pipe and materializes it
            into arrays, single values, external I/O, etc.
          </li>
          <li><strong>Return type restriction</strong>:
            There is <strong>no restriction</strong> on the return type <code>R</code>,
            as long as it is <strong>not</strong> <code>Pipe&lt;*&gt;</code>.
            It can be <code>T[]</code>, <code>Int</code>, <code>Unit</code>, etc.
          </li>
        </ul>

        <pre><code>// Pure consumer: materialize to array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer counting elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four kinds of declarations to structure the Pipe / Filter model:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.
          All of them are ‚Äúconstructors with a <code>bound</code> block‚Äù.
          The <code>bound</code> block is executed when the component is actually
          attached into a pipeline.
        </p>

        <h4>6.3.1 producer</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when attached at the head of a pipeline
    // Read from external resource and write to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the producer name.</li>
          <li><code>out</code> is the <strong>output type in the pipe world</strong>.
            It must always be <strong>a <code>Pipe&lt;*&gt;</code> type</strong>.
          </li>
          <li><code>bound(output)</code> defines what happens when this producer is
            placed at the head of a pipeline. The type of <code>output</code> is
            the same as <code>out</code> (i.e. <code>Pipe&lt;T&gt;</code>).</li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are available inside the
          <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Glue logic between upstream and downstream
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the pipe name.</li>
          <li><code>in</code> is the type of data received from upstream.</li>
          <li><code>out</code> is the type of data passed to downstream.</li>
          <li><code>bound(input, output)</code> describes how to move data from
            <code>input</code> to <code>output</code>.</li>
        </ul>

        <p class="note">
          Pipe declarations are intended to bridge external I/O (sockets, HTTP, etc.)
          and type translations (e.g. Text ‚Üí JSON).
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // decoded object

  bound(input, output) {
    // Pseudo:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Filter logic when attached to a pipeline
    // Describe how to flow elements from input to output
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> is the filter name.</li>
          <li><code>in</code> / <code>out</code> specify the input and output types.</li>
          <li>In the Pipe / Filter model, intermediate filters usually have both
            <code>in</code> and <code>out</code> of type <code>Pipe&lt;*&gt;</code>.</li>
          <li><code>bound(input, output)</code> implements the transformation logic
            from <code>input</code> to <code>output</code>.</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Logic executed at the end of the pipeline
    // Consume input and return some value
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the consumer name.</li>
          <li><code>in</code> is the input type. In the Pipe / Filter model,
            this is usually <strong><code>Pipe&lt;T&gt;</code></strong>.</li>
          <li><code>bound(input)</code> is executed when this consumer is attached
            as the terminal of a pipeline. It consumes <code>input</code> and
            returns a value of arbitrary type <code>R</code>.</li>
          <li><code>R</code> can be any type (<code>T[]</code>, <code>Int</code>,
            <code>Bool</code>, <code>Unit</code>, ...), but it must
            <strong>not</strong> be <code>Pipe&lt;*&gt;</code>.</li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          Summary of roles:
          <ul>
            <li><strong>producer</strong>: Outside world ‚Üí <code>Pipe&lt;*&gt;</code> (must always output a Pipe)</li>
            <li><strong>pipe</strong>: Bridges between different streams or external I/O</li>
            <li><strong>filter</strong>: Mostly <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> transformations</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> ‚Üí any non-Pipe type (exit from the pipe world)</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition</h4>
        <p>
          The <code>|&gt;</code> operator in Aloe is simply sugar for
          <strong>function composition</strong>.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>A -&gt; B</code> and
              <code>G</code> has type <code>B -&gt; C</code>, then
              <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.</li>
          <li>It is applicable to any type, not just <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Therefore, from the <strong>language type system</strong> perspective,<br />
          there is no problem in ‚Äúchanging return types along the pipeline‚Äù.<br />
          The constraints of the Pipe / Filter model are imposed by the
          <strong>library design</strong> around <code>Pipe&lt;T&gt;</code>
          and the declarations described above.
        </div>

        <h4>6.4.2 Pipe&lt;T&gt; Usage Example</h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: Producer (<code>String -&gt; Pipe&lt;String&gt;</code>)</li>
          <li><code>Where</code>, <code>Map</code>: Transformers (<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>)</li>
          <li><code>ToArray</code>: Consumer (<code>Pipe&lt;User&gt; -&gt; User[]</code>)</li>
          <li>The whole pipeline has type <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          While it is valid in the language to chain more <code>|&gt;</code> after a consumer,
          this is usually considered bad style, e.g. <code>ToArray() |&gt; ToArray()</code>.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters &amp; Producers</h3>

        <h4>6.5.1 Representative Transformers (filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Representative Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Representative Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns Int
}</code></pre>

        <h4>6.5.4 Example</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with Statement</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> statement is syntax sugar to simplify
        repeated property assignments and method calls on a single object.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The above <code>with</code> block is equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> evaluates <code>Expr</code> exactly once.</li>
        <li>Simple assignments to identifiers inside the block are treated
          as member accesses of the target object.</li>
      </ul>
    </section>

    <section id="lock">
      <h2>8. lock Statement &amp; Synchronization</h2>

      <h3>8.1 Overview</h3>
      <p>
        The <code>lock</code> statement locks a particular object and
        provides mutual exclusion and GC read barrier optimization within the block.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>8.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> guarantees exclusive access
          to the object denoted by <code>Expr</code> during <code>Body</code>.</li>
        <li>Lock acquisition and release are handled by the VM.</li>
        <li>Updates to shared data should generally be limited to <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM is assumed to use a sliding compaction GC.
        Inside a <code>lock</code> block, read barrier checks for the same object
        may be optimized to run at most once.
      </p>
    </section>

    <section id="exceptions">
      <h2>9. Exceptions</h2>

      <h3>9.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside <code>try</code> are caught by matching <code>catch</code> blocks.</li>
        <li>The <code>finally</code> block is always executed, regardless of exceptions.</li>
        <li>The hierarchy and details of exception types are defined by the VM specification.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>10. Runtime Model &amp; Memory Management</h2>

      <h3>10.1 AloeVM Overview</h3>
      <ul>
        <li>Stack-based bytecode virtual machine.</li>
        <li>Function calls are implemented via stack frames.</li>
        <li>GC is assumed to be a sliding compaction collector.</li>
      </ul>

      <h3>10.2 Memory Management (Summary)</h3>
      <ul>
        <li>Objects are allocated on a heap.</li>
        <li>GC runs under certain conditions and compacts live objects
          while sliding them in memory.</li>
        <li>In combination with <code>lock</code>, read barrier checks
          can be optimized to reduce overhead.</li>
      </ul>

      <p class="small">
        Detailed opcode list and GC implementation are described in the AloeVM spec.
      </p>
    </section>

    <section id="limits">
      <h2>11. Limitations &amp; Future Work</h2>

      <h3>11.1 Current Limitations</h3>
      <ul>
        <li>Generic features are minimal (no advanced type inference or typeclass-like features yet).</li>
        <li>Module system and package management are out of scope in this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>11.2 Future Topics</h3>
      <ul>
        <li>Parallelization and fusion optimizations for Pipe / Filter.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Error handling via Result-like types (in addition to exceptions).</li>
        <li>Standard libraries for distributed and streaming workloads.</li>
      </ul>

      <p class="note">
        This draft mainly clarifies the relationship between
        <strong>Pipe / Filter and Producer / Transformer / Consumer / Pipe / Consumer</strong>,
        and their declaration forms.
      </p>
    </section>

  </main>
</div>
</body>
</html>
