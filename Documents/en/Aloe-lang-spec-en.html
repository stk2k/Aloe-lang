Here’s the full English HTML version of the spec, with the latest Task/async + Func<...:...> decisions and without Unit as a type:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – Pipe/Filter/Producer/Consumer + delete/with/lock/class inheritance/generics/Task/async)</title>
  <meta name="last-updated" content="2025-11-29T12:00:00+09:00" />
  <style>
    /* Minimal layout only. Leave fonts to the browser defaults. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / Pipe, Filter, Producer, Consumer + delete/with/lock/class inheritance/generics/Task/async</div>
    <div class="updated">Last updated: 2025-11-29 12:00:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#func-types">4.7 Function Types Func&lt;...:...&gt;</a>
      <a href="#functions-methods">5. Functions and Methods</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>

      <div class="section-title">Syntactic Extensions</div>
      <a href="#with">7. with Syntax</a>
      <a href="#delete">8. delete Syntax</a>
      <a href="#lock">9. lock Syntax and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model and Memory Management</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Work</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing,
        a simple syntax, and a stack-based virtual machine (AloeVM).
        It is designed especially around a <strong>Pipe / Filter style dataflow</strong>
        and interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type checking is performed at compile time).</li>
        <li>C-like surface syntax, but with an intentionally small feature set.</li>
        <li>Focus on writing “data flow and transformation” code pleasantly,
          such as text processing, REST calls, log processing, etc.</li>
        <li>Assumes a stack-based VM (AloeVM) and a future WebAssembly backend.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft language specification</strong>.<br />
        The actual compiler / VM implementation may differ in some details.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: the specification itself should read like documentation.</li>
        <li><strong>Ease of implementation</strong>: possible to implement with a small compiler and VM.</li>
        <li><strong>Consistency of Pipe / Filter</strong>: type-safe dataflow expression.</li>
        <li><strong>Bridge to Wasm</strong>: easy to integrate with future Wasm component model.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Becoming a “do-everything” general-purpose language.</li>
        <li>Competing on performance with heavily optimized JIT compilers.</li>
        <li>Complex metaprogramming (macros, etc.) is out of scope for now.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source files are assumed to be UTF-8 encoded.</li>
        <li>Line comment: <code>// comment</code></li>
        <li>Block comment: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifier: starts with a letter or <code>_</code>, followed by letters, digits, or <code>_</code>.</li>
        <li>Keywords are reserved words and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td>
        </tr>
        <tr>
          <td>Functions</td>
          <td><code>method</code></td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code>, <code>async</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are enclosed in <code>{ ... }</code>.</li>
        <li>Conditions in control constructs must be of type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive and Core Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation dependent; we assume 32 bits here).</td></tr>
        <tr><td><code>Float</code></td><td>Floating-point number (32 or 64 bits, implementation dependent).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation dependent).</td></tr>
      </table>

      <p>
        In addition, Aloe provides core runtime types that the compiler and VM know about, such as:
      </p>
      <ul>
        <li><code>Task</code> – an asynchronous operation that does not produce a value.</li>
        <li><code>Task&lt;T&gt;</code> – an asynchronous operation that produces a value of type <code>T</code>.</li>
        <li><code>Pipe&lt;T&gt;</code> – a lazy sequence / stream of values of type <code>T</code> (see Section 6).</li>
      </ul>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-length array: <code>T[]</code></li>
        <li>Variable-length, lazily evaluated sequences are represented using <code>Pipe&lt;T&gt;</code> (see Section 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignments copy the value.</li>
        <li>Copies are shallow: sharing of nested reference-type fields depends on the VM implementation.</li>
        <li>A struct may inherit from at most one other struct (single inheritance for structs).</li>
        <li>
          It is <strong>forbidden</strong> for a struct to implement an <code>interface</code>.
          (How structs interact with traits or generic constraints will be specified later.)
        </li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as an <strong><code>Int</code></strong>.</li>
        <li>
          “Generic enums” like <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are
          <strong>forbidden</strong>.
        </li>
        <li>Flag-style enums are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed)</h2>

      <h3>4.5.1 Basics of class</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignments perform a <strong>reference copy (shallow copy)</strong>.</li>
        <li><code>clone</code> creates a shallow copy of an object and returns a new reference.</li>
        <li>
          All classes are <strong>cloneable</strong>; the language does not provide a way
          to declare “non-cloneable” at the type level.<br />
          If you need to express restrictions or caution on cloning, you handle it via API design and coding guidelines.
        </li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // Reference copy (A and B refer to the same instance)

var C: User = clone A;  // Shallow copy, returns a reference to a new instance</code></pre>

      <p class="note">
        A <strong>shallow copy</strong> means “copy the field values as-is”.<br />
        If a field itself is a reference type, the reference value is copied.
        Types that need deep copy or custom cloning logic can provide user-defined APIs
        (e.g. <code>Clone</code> methods) layered on top of <code>clone</code>.
      </p>

      <h3>4.5.2 Class inheritance (single inheritance)</h3>
      <p>
        Aloe classes support <strong>single inheritance</strong> only.<br />
        That is, a class may specify exactly one base class.
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// The following is a compile-time error (multiple inheritance for classes is forbidden)
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>Class hierarchies form trees (or chains); diamond inheritance does not occur.</li>
        <li>Class inheritance is a mechanism for reusing state and behavior.</li>
      </ul>

      <h3>4.5.3 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance of classes, Aloe uses <strong>interface</strong> and
        <strong>trait</strong> to compose behavior.
      </p>

      <ul>
        <li>
          <code>interface</code> defines method signatures only and has no implementation
          (whether to allow default implementations is left to future work).
        </li>
        <li>
          <code>trait</code> is a mixin unit that can provide method implementations;
          it is used to add behavior to existing classes.
        </li>
        <li>
          A class has <strong>one base class</strong>, may implement multiple <code>interface</code>s,
          and may apply multiple <code>trait</code>s via <code>with</code>.
        </li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose(): void;
}

trait Printable {
  method PrintSelf(): void {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose(): void {
    // Resource cleanup logic
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        The detailed syntax and rules for <code>interface</code> and <code>trait</code>
        (inheritance, conflict resolution when multiple traits define the same method, etc.)
        are not fully defined in this draft. Only the direction is outlined here.
      </p>

      <h3>4.5.4 sealed classes</h3>
      <p>
        To forbid inheritance from specific classes, Aloe provides the <code>sealed</code> modifier.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// Compile-time error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li><code>sealed class</code> cannot be used as a base class.</li>
        <li>
          Even if a class is <code>sealed</code>, it may still implement interfaces and
          apply traits via <code>with</code>.
        </li>
        <li>
          In the future, combining sealed classes with union / pattern matching
          and exhaustiveness checking is being considered.
        </li>
      </ul>

      <h3>4.5.5 readonly and classes</h3>
      <ul>
        <li>Class fields are mutable by default.</li>
        <li>
          A field marked <code>readonly</code> becomes immutable:
          <ul>
            <li>
              Assignment to that field is only allowed in
              <strong>field initializers</strong> or in the
              <strong>constructor of the same class</strong>.
            </li>
            <li>Any assignment outside of those is a compile-time error.</li>
          </ul>
        </li>
        <li>
          A <code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are implicitly treated as if they were <code>readonly</code>.</li>
            <li>
              Assignments to fields are allowed only in field initializers and
              the constructors of that class.
            </li>
            <li>
              After the constructor completes, no code is allowed to modify the fields
              of that instance.
            </li>
          </ul>
        </li>
        <li>
          <code>readonly</code> and <code>clone</code> are orthogonal:
          a <code>readonly class</code> can still be cloned.
          The result of cloning is a separate instance with the same immutable state.
        </li>
      </ul>

      <p class="small">
        In this section, we establish a high-level policy that:
        classes are heap reference types with single inheritance,
        multiple behaviors are composed via interface + trait,
        <code>sealed</code> expresses “no inheritance”,
        and <code>readonly</code> expresses immutability at field or class level.<br />
        The details of method resolution order and trait conflict resolution
        will be specified separately.
      </p>
    </section>

    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, functions, methods,
        and pipe-related declarations.<br />
        The goal is to enable type-safe reuse for collections and Pipe / Filter,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // Implementation omitted
}</code></pre>

      <h3>4.6.2 Generic Type Parameters</h3>
      <ul>
        <li>
          <code>type</code>, <code>struct</code>, <code>class</code>, <code>interface</code>, <code>trait</code>,
          <code>method</code>, and producer/filter/consumer declarations may take type parameters
          as <code>&lt;T, U, ...&gt;</code>.
        </li>
        <li>
          It is recommended that type parameter names start with an uppercase letter
          (e.g. <code>T</code>, <code>TItem</code>, <code>TKey</code>).
        </li>
        <li>Type arguments are bound to concrete types at the use site.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // Implementation omitted
}</code></pre>

      <h3>4.6.3 where Type Constraints (Overview)</h3>
      <p>
        Aloe generics support arbitrary type constraints using a <code>where</code> clause.<br />
        By default, there are no constraints, but in version 0.1 a small set of basic
        constraints will be supported.
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Sum for Int only
}</code></pre>

      <p class="note">
        Here, <code>where</code> is used purely for <strong>compile-time type checking</strong>.<br />
        The runtime representation (monomorphization vs. shared code with type tags, etc.)
        is left to the VM specification.
      </p>

      <h3>4.6.4 Supported Constraint Types</h3>
      <p>
        In version 0.1, the following constraint categories are supported:
      </p>

      <ul>
        <li><strong>Value type / reference type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive type constraints</strong>
          <ul>
            <li>
              <code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>, etc.
              allow directly specifying primitive type names.
            </li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – any type implementing the trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – exactly the struct type <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – exactly the class type <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Any concrete type name</strong>
          <ul>
            <li>Any existing concrete type name may be specified (e.g. <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Generic restricted to value types
method Zero&lt;T&gt;(): T
  where T: struct
{
  // Implementation omitted
}

// Pipe specialized for Int
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // Implementation omitted
}

// Specialized for a particular struct
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // Implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior on Constraint Violation</h3>
      <ul>
        <li>
          If a type argument does not satisfy the <code>where</code> constraints
          of a generic function or type, this is a compile-time error.
        </li>
        <li>If multiple constraints are specified, all of them must be satisfied.</li>
        <li>Cyclic constraints and advanced typeclass-like structures are not supported at this time.</li>
      </ul>

      <pre><code>// Example of a compile-time error:

// where T: Int, so T cannot be String
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile-time error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization vs.
        shared code with type tags, etc.) is defined by AloeVM.<br />
        This language specification focuses on type-safe reuse and
        <code>where</code>-based constraint checking behavior.
      </p>
    </section>

    <section id="func-types">
      <h2>4.7 Function Types Func&lt;...:...&gt;</h2>

      <h3>4.7.1 Basic Form</h3>
      <p>
        Aloe represents function types explicitly using the form
        <code>Func&lt;ArgList:ReturnType&gt;</code>.
      </p>

      <ul>
        <li>
          <strong>ArgList</strong> is a comma-separated list of argument types
          (may be empty).
        </li>
        <li>
          <strong>ReturnType</strong> is the function’s return type.
        </li>
      </ul>

      <pre><code>let F1: Func&lt;Int:String&gt;;
let F2: Func&lt;String, Int:Bool&gt;;
let F3: Func&lt;:Task&gt;;         // No arguments, returns Task
let F4: Func&lt;Task:Task&gt;;     // Takes Task, returns Task</code></pre>

      <p class="note">
        In explanatory text, we may occasionally use mathematical notation
        like <code>A -&gt; B</code>. However, the <strong>canonical syntax in Aloe</strong> is
        always <code>Func&lt;...:...&gt;</code>.
      </p>

      <h3>4.7.2 No-return Functions</h3>
      <p>
        Functions that conceptually “return nothing” are expressed using
        <code>void</code> in the return position:
      </p>

      <pre><code>let F5: Func&lt;Task:void&gt;;  // Takes Task, returns nothing</code></pre>

      <p>
        The following two are defined to be <strong>equivalent</strong>:
      </p>

      <ul>
        <li><code>Func&lt;Task:void&gt;</code></li>
        <li><code>Func&lt;Task:&gt;</code></li>
      </ul>

      <p class="note">
        <code>void</code> is only allowed in the return position of functions.
        It cannot be used as a normal type for variables or fields.<br />
        For example, <code>let X: void;</code> is invalid syntax.
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. Functions and Methods</h2>

      <h3>5.1 method Declaration</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> defines either a top-level function or a method bound to a type.</li>
        <li>
          If the return type is omitted, the method is treated as returning <code>void</code>.
        </li>
      </ul>

      <h3>5.2 Method Binding with bound</h3>
      <p>
        Aloe uses <code>bound</code> to add methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // VM-dependent internal representation
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; {
    // Implementation omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, we introduce a <strong>restriction</strong> on methods declared
        inside a <code>bound</code> block regarding their return types (see Section 6.2).
      </p>

      <h3>5.3 Task and await (Basics of Asynchronous Execution)</h3>

      <h4>5.3.1 Task Model</h4>
      <ul>
        <li><code>Task</code> represents an asynchronous operation that does not produce a value.</li>
        <li><code>Task&lt;T&gt;</code> represents an asynchronous operation that produces a value of type <code>T</code>.</li>
        <li>There is no <code>Task&lt;void&gt;</code> type.</li>
      </ul>

      <h4>5.3.2 Type Rules for await</h4>
      <ul>
        <li><code>await Expr</code> expects <code>Expr</code> to have type <code>Task&lt;T&gt;</code> or <code>Task</code>.</li>
        <li>If <code>Expr</code> has type <code>Task&lt;T&gt;</code>, then <code>await Expr</code> has type <code>T</code>.</li>
        <li>If <code>Expr</code> has type <code>Task</code>, then <code>await Expr</code> produces no value.</li>
      </ul>

      <pre><code>method FetchUserName(Id: Int): Task&lt;String&gt; {
  let User: UserInfo = await GetUserAsync(Id);  // GetUserAsync: Task&lt;UserInfo&gt;
  return User.Name;
}

method LogAndWait(T: Task): Task {
  Log("waiting...");
  await T;   // No value is produced
  Log("done");
}</code></pre>

      <h4>5.3.3 No async Modifier on Methods</h4>
      <p>
        Aloe does <strong>not</strong> use an <code>async</code> modifier on method declarations.
      </p>
      <ul>
        <li>
          A method that returns <code>Task</code> or <code>Task&lt;T&gt;</code> and uses <code>await</code>
          is automatically compiled into a state machine by the compiler.
        </li>
        <li>
          You simply write the return type as <code>Task</code> or <code>Task&lt;T&gt;</code> and use <code>await</code>
          inside the body.
        </li>
      </ul>

      <h4>5.3.4 Where await is Allowed</h4>
      <p>
        <code>await</code> may only appear in the following contexts:
      </p>
      <ul>
        <li>
          In the body of a <code>method</code> whose declared return type is
          <code>Task</code> or <code>Task&lt;T&gt;</code>.
        </li>
        <li>Inside an <code>async { ... }</code> block (see Section 5.4).</li>
        <li>
          Inside an <code>async (...)</code> lambda expression (see Section 5.4).
        </li>
      </ul>

      <p>
        Using <code>await</code> anywhere else is a compile-time error.
      </p>

      <h3>5.4 async Blocks and async Lambdas</h3>

      <h4>5.4.1 async Blocks</h4>
      <p>
        An <code>async { ... }</code> block creates a <code>Task</code> or <code>Task&lt;T&gt;</code>
        without declaring a named method.
      </p>

      <pre><code>let Job: Task = async {
  Log("start");
  await Sleep(1000);
  Log("done");
};

let T: Task&lt;Int&gt; = async {
  let X: Int = await FetchValue();
  return X + 1;
};</code></pre>

      <ul>
        <li>If the block returns a value via <code>return Value;</code>, the block has type <code>Task&lt;T&gt;</code>.</li>
        <li>If there is no return value, the block has type <code>Task</code>.</li>
      </ul>

      <h4>5.4.2 async Lambdas</h4>
      <p>
        An async lambda is written as <code>async (Params) { ... }</code>
        and can be assigned to a function type returning <code>Task</code> or <code>Task&lt;T&gt;</code>.
      </p>

      <pre><code>let FetchLength: Func&lt;String:Task&lt;Int&gt;&gt; =
  async (Url: String) {
    let Body: String = await HttpGet(Url);
    return Body.Length;
  };

let NotifyDone: Func&lt;Task:&gt; =
  async (t: Task) {
    Log("job finished");
    await FlushLogAsync();
  };</code></pre>

      <ul>
        <li>The type of an async lambda is inferred from the <code>Func&lt;...:...&gt;</code> it is assigned to.</li>
        <li>
          Async lambdas may only be assigned to function types whose return type is
          <code>Task</code> or <code>Task&lt;T&gt;</code>.
        </li>
      </ul>

      <h4>5.4.3 Relationship Between async { } and async Lambdas</h4>
      <p>
        Conceptually, <code>async { ... }</code> is sugar for a parameterless async lambda.
      </p>

      <pre><code>let T: Task&lt;Int&gt; = async {
  let V: Int = await ComputeAsync();
  return V;
};

// Roughly equivalent to:

let T2: Func&lt;:Task&lt;Int&gt;&gt; = async () {
  let V: Int = await ComputeAsync();
  return V;
};</code></pre>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is that it can express
        <strong>Pipe / Filter style dataflow</strong> in a type-safe and consistent style.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, the above is equivalent to the following nested calls:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>The Aloe <code>|&gt;</code> operator is syntactic sugar for this kind of function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe and corresponds to
          lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents a pipe through which elements of type <code>T</code> flow.</li>
          <li>Its internal representation (chained iterators, coroutines, etc.) is VM dependent.</li>
          <li>The standard library provides producers/transformers/consumers built on <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // Implementation-dependent internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the realm of functions that accept and/or return
          <code>Pipe&lt;T&gt;</code> (producers, transformers, consumers).<br />
          Consumers are the exits from the pipe world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, functions and objects are classified into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>:
            a function or object whose return type is <code>Pipe&lt;*&gt;</code> and that appears
            at the head of pipelines.
          </li>
          <li><strong>Role</strong>:
            read data from the external world (files, HTTP, arrays, etc.) and
            “pour” it into the pipe world (<code>Pipe&lt;T&gt;</code>).
          </li>
          <li><strong>Type</strong>:
            typically has the shape <code>X -&gt; Pipe&lt;T&gt;</code>;
            a producer is always designed to output some <code>Pipe&lt;*&gt;</code>.
          </li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filter)</h4>
        <ul>
          <li><strong>Definition</strong>:
            functions/methods of type <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
          </li>
          <li><strong>Role</strong>:
            transform, filter, or sort data inside the pipe world;
            they do not exit the pipe world.
          </li>
        </ul>

        <p>
          In Aloe, methods defined inside <strong><code>bound Pipe&lt;T&gt;</code></strong>
          are considered reserved for transformers.
        </p>

        <div class="note">
          <strong>Restriction:</strong><br />
          Methods declared inside a <code>bound Pipe&lt;T&gt;</code> block must
          <strong>always return <code>Pipe&lt;*&gt;</code></strong>.<br />
          In other words, their type must be <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; { ... }

  // OK: change element type
  method Map&lt;U&gt;(Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; { ... }

  // NG: return type is not Pipe; should be a compile-time error
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer (Terminal Filter)</h4>

        <ul>
          <li><strong>Definition</strong>:
            a function/object of type <code>Pipe&lt;T&gt; -&gt; R</code> where
            <code>R</code> is not <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><strong>Role</strong>:
            exit from the pipe world; consumes the pipe completely and
            converts it into an array, scalar value, external I/O, etc.
          </li>
          <li><strong>Return Type</strong>:
            <code>R</code> may be any type as long as it is not <code>Pipe&lt;*&gt;</code>:
            <code>T[]</code>, <code>Int</code>, <code>bool</code>, <code>void</code>, etc.
          </li>
        </ul>

        <pre><code>// Consumer that materializes a pipe into an array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer that counts elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms to build Pipe / Filter components:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of them are treated as “objects with constructors”; when connected
          in a pipeline, their <code>bound</code> blocks are executed.
        </p>

        <h4>6.3.1 producer Declaration</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when the producer is connected to a pipeline.
    // Reads from external resources and writes into output.
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the name of the producer.</li>
          <li><code>out</code> specifies the type of its output in the pipe world
            and must be <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><code>bound(output)</code> defines the behavior when the producer
            is connected; <code>output</code> has the type specified by <code>out</code>.
          </li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are accessible inside the
          <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo-code:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe Declaration</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connects pipes and performs conversion/transfer
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the name of the pipe.</li>
          <li><code>in</code> is the type that comes from upstream.</li>
          <li><code>out</code> is the type flowing downstream.</li>
          <li><code>bound(input, output)</code> describes the conversion from
            <code>input</code> to <code>output</code>.
          </li>
        </ul>

        <p class="note">
          pipe declarations are intended for bridging between different
          kinds of streams (e.g. text → JSON) or external resources like sockets/HTTP.
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // Decoded object

  bound(input, output) {
    // Pseudo-code:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter Declaration</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Defines how elements flow from input to output
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> is the name of the filter.</li>
          <li><code>in</code> / <code>out</code> specify input and output types.</li>
          <li>
            For intermediate filters in a Pipe / Filter chain, <code>in</code> and <code>out</code>
            usually both involve <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><code>bound(input, output)</code> implements the transformation between them.</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer Declaration</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Executed at the end of a pipeline.
    // Consumes input and returns some value.
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the consumer’s name.</li>
          <li><code>in</code> specifies its input type,
            which is often <strong><code>Pipe&lt;T&gt;</code></strong> in the Pipe / Filter model.
          </li>
          <li><code>bound(input)</code> runs at the end of a pipeline,
            fully consumes <code>input</code>, and returns a value of some type <code>R</code>.
          </li>
          <li>
            <code>R</code> may be any type (<code>T[]</code>, <code>Int</code>, <code>bool</code>, <code>void</code>, etc.),
            as long as <strong>it is not <code>Pipe&lt;*&gt;</code></strong>.
          </li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo-code:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo-code:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, the roles of pipe-related declarations are:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code> (always outputs <code>Pipe</code>).</li>
            <li><strong>pipe</strong>: bridges between heterogeneous streams and external I/O.</li>
            <li><strong>filter</strong>: mainly <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> transformations.</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → non-<code>Pipe</code> type (exit from the pipe world).</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition</h4>
        <p>
          Aloe’s <code>|&gt;</code> is defined as syntactic sugar for simple function composition.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>
            If <code>F</code> has type <code>A -&gt; B</code> and <code>G</code> has type <code>B -&gt; C</code>,
            then <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.
          </li>
          <li>This operator is applicable to any type, not just <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Thus, from the type system’s perspective, it is not problematic that
          “the return type changes in the middle of a pipeline”.<br />
          The constraints of the Pipe / Filter model come from
          <strong><code>Pipe&lt;T&gt;</code> and the library design of pipe-related declarations</strong>,
          not from the operator itself.
        </div>

        <h4>6.4.2 Using Pipe&lt;T&gt; with <code>|&gt;</code></h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>String -&gt; Pipe&lt;String&gt;</code>).</li>
          <li><code>Where</code> / <code>Map</code>: transformers (<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>).</li>
          <li><code>ToArray</code>: consumer (<code>Pipe&lt;User&gt; -&gt; User[]</code>).</li>
          <li>The overall type of the pipeline is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          From the language’s viewpoint, you may technically write more
          <code>|&gt;</code> after a consumer,<br />
          but stylistically it is not recommended.<br />
          For example, patterns like <code>ToArray() |&gt; ToArray()</code> should be avoided.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters and Producers</h3>

        <h4>6.5.1 Representative Transformers (Filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Representative Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Representative Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns Int
}</code></pre>

        <h4>6.5.4 Example Usage</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with Syntax</h2>

      <h3>7.1 Overview</h3>
      <p>
        <code>with</code> is syntactic sugar for repeatedly writing property assignments
        and method calls on the same target object.<br />
        In Aloe, in addition, it serves as a <strong>“lifetime lock”</strong> that keeps
        the target object alive for the duration of the block.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The <code>with</code> block above is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>Expr</code> in <code>with (Expr) { ... }</code> is evaluated <strong>exactly once</strong>.</li>
        <li>
          Simple identifier assignments inside the block are interpreted as member accesses
          on the target object.
        </li>
      </ul>

      <h3>7.3 Lifetime Lock (GC Root Behavior)</h3>
      <p>
        AloeVM is assumed to use a combination of reference counting and sliding compaction for memory management.<br />
        Under this model, a <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The result of evaluating <code>with (Expr)</code> is stored in a hidden variable (a GC root).</li>
        <li>
          This hidden variable keeps the object alive until the block is exited;
          the object is <strong>guaranteed not to be freed</strong> during the block.
        </li>
        <li>Thus, within the <code>with</code> block, the object is guaranteed to be alive.</li>
      </ul>

      <h3>7.4 Relationship Between with and delete</h3>
      <ul>
        <li>
          It is a compile-time error to call <code>delete</code> on the same variable
          that is the target of a <code>with</code> inside that <code>with</code> block.
        </li>
        <li>
          The reason is that <code>with</code> expresses “this object must be alive in this block”,
          which conflicts with the intent of <code>delete</code>.
        </li>
        <li>
          However, calling <code>delete</code> on a <em>different variable</em> that refers to
          the same object is allowed. Since the <code>with</code> still holds a GC root,
          the object itself remains alive.
        </li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is protected by with and guaranteed to be alive in this block.

  delete Alias;   // OK: Only removes the reference from Alias
  Url = "https://example.com/api";  // Still usable
}

// After exiting the with block, the GC root is removed.
// If no other references remain, the object will be freed eventually.</code></pre>

      <p class="note">
        In summary, <code>with</code> is both:
        a <strong>“syntactic sugar for member access”</strong> and
        a <strong>“temporary GC root that keeps the target object alive”</strong>.<br />
        When you want to protect the same target with a lock at the same time,
        use the <code>lock with</code> syntax described in Section 9.3.
      </p>
    </section>

    <section id="delete">
      <h2>8. delete Syntax</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> does <strong>not</strong> directly destroy objects.<br />
        Instead, it is treated as syntax to <strong>remove a reference from a variable</strong>.
      </p>
      <ul>
        <li>
          Actual object destruction (memory freeing, finalizers, etc.) is performed
          by the <strong>runtime (AloeVM)</strong> using reference counting + GC.
        </li>
        <li>
          <code>delete</code> is a type-safe way of expressing
          “this variable no longer points to this object”, replacing null assignments.
        </li>
      </ul>

      <h3>8.2 Grammar</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile Time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li>
          After <code>delete</code>, it is a compile-time error to read from that variable or
          to perform member access/method calls on it.
        </li>
        <li>
          However, assigning a new value to that variable is allowed.
          Conceptually, <code>delete</code> returns the variable to an “uninitialized” state.
        </li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Use Buf
DoSomething(Buf);

delete Buf;

// From here on, reading Buf or Buf.Length is a compile-time error

Buf = NewBuffer();  // After re-assignment, Buf can be used again</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>
          Decrements the reference count of the object currently referred to by <code>Var</code>
          (assuming a reference counting scheme).
        </li>
        <li>
          Marks <code>Var</code> itself as “uninitialized/deleted”.
        </li>
        <li>
          When the object’s reference count reaches 0, it will be freed at the discretion of the GC.<br />
          <strong>Thus, there is no guarantee that delete immediately frees the object.</strong>
        </li>
      </ul>

      <p class="note">
        In this language specification, the timing of object destruction is left
        to the VM/runtime.<br />
        <code>delete</code> only removes one reference from a variable to the object.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>
          As described in Section 7.4, calling <code>delete</code> on the same variable used in
          <code>with</code> inside that <code>with</code> block is a compile-time error.
        </li>
        <li>
          Calling <code>delete</code> on another variable that refers to the same object is allowed,
          because the with-created GC root keeps the object alive.
        </li>
      </ul>

      <p class="note">
        In the future, if Aloe introduces “ownership-based resource types”
        or an ownership model, integrating <code>delete</code> with that model will be considered.<br />
        For now, this draft assumes <strong>no ownership model</strong>.
      </p>
    </section>

    <section id="lock">
      <h2>9. lock Syntax and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> syntax acquires a lock on a specific object and guarantees
        exclusive access and optimized read barriers for that object
        while the block is executing.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li>
          <code>lock (Expr) { Body }</code> acquires a lock on the object represented by <code>Expr</code> and
          guarantees exclusive access inside <code>Body</code>.
        </li>
        <li>Lock acquisition and release are implemented by the VM.</li>
        <li>
          Updates to data shared between threads should basically be confined inside
          <code>lock</code> blocks.
        </li>
      </ul>

      <p class="note">
        AloeVM is assumed to use sliding compaction for memory management.<br />
        Within a <code>lock</code> block, the VM may optimize read barriers and
        minimize per-object checks.
      </p>

      <h3>9.3 lock with Syntax (lock + with Combination)</h3>
      <p>
        For cases where you want to apply both “exclusive lock” and “lifetime lock (with)”
        to the same object, Aloe provides the <code>lock with</code> syntax.
      </p>

      <pre><code>lock with (Conn) {
  // Here:
  //   - Conn is locked exclusively
  //   - Conn is held as a GC root via with
  //   - Members of Conn can be accessed with the shortened syntax (RequestUrl, etc.)
}</code></pre>

      <h4>9.3.1 Grammar</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <p>
        <code>lock with (Expr) { Body }</code> is a compound construct where
        <code>Expr</code> is evaluated once and the result becomes the target of both
        <code>lock</code> and <code>with</code>.
      </p>

      <h4>9.3.2 Desugaring (Semantically Equivalent Code)</h4>
      <p>
        <code>lock with (Expr) { Body }</code> is semantically equivalent to:
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> is evaluated exactly once and bound to a temporary variable <code>__tmp</code>.</li>
        <li>Then <code>lock</code> and <code>with</code> are applied in a nested fashion to <code>__tmp</code>.</li>
        <li>Thus, during the execution of <code>Body</code>:
          <ul>
            <li>Exclusive access to the target object is guaranteed (semantics of <code>lock</code>).</li>
            <li>
              The target object is kept alive as a GC root via <code>with</code>;
              its lifetime is guaranteed.
            </li>
            <li>The target’s members can be accessed in the shortened with-style form.</li>
          </ul>
        </li>
      </ul>

      <h4>9.3.3 Style and Constraints</h4>
      <ul>
        <li>
          <code>lock with</code> is sugar for expressing the intent
          “operate on this resource exclusively and safely within this lifetime”.
        </li>
        <li>
          Alternative forms like <code>with lock (Expr)</code> or <code>lock &amp; with (Expr)</code>
          are not defined by the language; <br />
          for this purpose you always use <code>lock with</code>.
        </li>
        <li>
          Behavior inside a <code>lock with</code> block is interpreted as the combination of
          <code>lock</code> (Section 9.2) and <code>with</code> (Section 7.3).
        </li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// When we get here, the lock is released and
// the with-based lifetime lock is also removed.</code></pre>
    </section>

    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside a <code>try</code> block can be caught by a matching <code>catch</code>.</li>
        <li><code>finally</code> is always executed regardless of whether an exception was thrown.</li>
        <li>The concrete exception types and hierarchy are defined by the VM specification.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. Execution Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode VM.</li>
        <li>Function calls push frames on the call stack.</li>
        <li>GC is assumed to use reference counting plus sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>
          When certain conditions are met, GC runs and compacts memory
          by sliding live objects.
        </li>
        <li>
          <code>with</code> acts as a temporary GC root keeping objects alive,
          and combined with <code>lock</code> allows optimization of read barriers.
        </li>
        <li>
          Normally, you do not need to call <code>delete</code> for memory management;<br />
          you use <code>delete</code> only if you explicitly want to discard a reference early.
        </li>
      </ul>

      <p class="small">
        A detailed opcode list and GC implementation details will be provided
        in the AloeVM specification.
      </p>
    </section>

    <section id="limits">
      <h2>12. Limitations and Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>
          The expressiveness of generics is minimal; typeclasses and higher-kinded generics
          are not defined.
        </li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>12.2 Future Directions</h3>
      <ul>
        <li>Parallelization and fusion optimizations for Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Introducing Result-like types for error handling in addition to exceptions.</li>
        <li>Extending the standard library for distributed processing and streaming.</li>
        <li>
          Introducing ownership-based resource types and integrating them with
          <code>delete</code>, if needed.
        </li>
        <li>
          Integrating traits / interfaces / sealed / readonly with pattern matching
          and exhaustiveness checking.
        </li>
      </ul>

      <p class="note">
        This draft focuses particularly on:<br />
        <strong>
          The relationship between Pipe / Filter and the roles/declarations of
          Producer / Transformer / Consumer / Pipe / Consumer
        </strong>,<br />
        and on
        <strong>
          the relationship between with / delete / lock / class inheritance / readonly / clone / generics
          and the AloeVM memory model.
        </strong>
      </p>
    </section>

  </main>
</div>
</body>
</html>
