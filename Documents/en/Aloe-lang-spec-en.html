<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English)</title>
  <meta name="edit-version" content="4">
  <meta name="edit-date" content="2025-12-02T11:20:00+09:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Left menu -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • English version + with extension</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block (Entry Point)</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with Blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with Extension</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English)</h1>
    <p class="note">
      This document is an English draft based on the specification at<br>
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>.<br>
      On top of that, it adds an extension to <strong>4.2 with-blocks</strong> for
      <strong>type-based with (shortened access to static members / enum members of class / struct / enum)</strong>.<br>
      Other parts of the spec are translated as faithfully as possible to the original.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language aiming for simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and has the following goals:
    </p>
    <ul>
      <li>Easy to read and write for education and small applications.</li>
      <li>Runs on both C# runtime and WebAssembly (WASM) environments.</li>
      <li>Enables I/O and concurrency control while remaining statically typed via <code>pipe</code> and <code>filter</code>.</li>
    </ul>
    <p>Characteristics:</p>
    <ul>
      <li>Static typing
        <ul>
          <li><code>var</code> for type inference.</li>
          <li><code>let</code> for explicit type annotation.</li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> … value types.</li>
          <li><code>class</code> … reference types.</li>
        </ul>
      </li>
      <li>GC-based memory management (specific algorithm is VM-implementation dependent).</li>
      <li>Do not write <code>= null</code> directly in source code.
        <ul>
          <li>Reference types can be null internally, but they are handled via the sugar syntax <code>delete</code>.</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> based dataflow-style design.</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> to end-of-line is a line comment.</li>
      <li><code>/*</code> … <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assume not supported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Cannot be the same spelling as a keyword.</li>
      <li>Identifiers starting with <code>_</code> are treated as “private” by convention (not referred to from outside).</li>
      <li>Unicode characters can be used (excluding whitespace and separators, etc.).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
null
options
or
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> is not used; <code>namespace</code> is used instead.</li>
      <li><code>final</code> is removed; use <code>sealed</code> to forbid extension.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checking.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>Floating-point literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code>, etc.</li>
      <li>Decimal literals: <code>10.12345678901234567890:d</code>, etc.</li>
      <li>Booleans: <code>true</code>, <code>false</code>.</li>
      <li>Strings: <code>"Hello, World!"</code>.</li>
      <li>Characters: <code>'A'</code>, <code>'z'</code>, etc.</li>
      <li>null literal: <code>null</code>.</li>
      <li>Array literals: <code>[1, 2, 3]</code>.</li>
      <li>List literals: <code>(1, 2, 3)</code>.</li>
      <li>Set literals: <code>{1, 2, 3}</code>.</li>
      <li>Map literals: <code>["key1": 10, "key2": 20]</code>.</li>
      <li>enum literals: <code>EnumType.Value1</code>.</li>
      <li>struct literals: <code>Point { x: 0, y: 1 }</code>.</li>
      <li>Object creation: <code>new ClassName()</code>.</li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>All statements end with a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion by newline.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines act as token separators.</li>
      <li>Consecutive whitespace is treated as a single separator.</li>
      <li>Indentation has no semantic meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lower-case.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe defines the following 7 types as “primitive types”:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – boolean value.</li>
      <li><code>int</code> / <code>integer</code> – signed integer.</li>
      <li><code>float</code> – floating-point number.</li>
      <li><code>decimal</code> – high-precision decimal number.</li>
      <li><code>string</code> – string (internally Unicode).</li>
      <li><code>null</code> – special type/value representing “no value”.</li>
      <li><code>void</code> – “no return value” (only for method return types).</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported by the language but treated as value types
      outside the primitive type category and discussed separately in chapter 3 (numbers and conversions).
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Asynchronous task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see chapter 18)</li>
    </ul>
    <p>There is no <code>any</code> type; dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implemented as reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Struct fields can only hold primitive types and other structs.</li>
      <li>They cannot hold reference type fields (such as class).</li>
      <li>Assigning a struct always performs a value copy.</li>
      <li>No explicit limit on maximum size is imposed by the spec.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>Classes can hold struct fields.</li>
      <li>Assigning a class instance to another variable copies the reference (the object itself is shared).</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> result in <code>float</code>.
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision decimal number.</li>
      <li>Expressions mixing <code>int</code> / <code>float</code> can be promoted to <code>decimal</code> if necessary.</li>
      <li>Overflow / underflow / precision issues are treated as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Implicit/explicit conversions between enum and int are both disallowed.</li>
      <li>Expressions mixing enum and numeric types are compile-time errors (except bit operations for bitfield enums).</li>
      <li>Internally, enum / bitfield enum is always represented as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Operations between bytes are allowed, but out-of-range results may cause errors.</li>
          <li>Expressions mixing byte and int are promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic operations on char are not allowed.</li>
          <li>Comparisons (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are allowed only between chars.</li>
          <li>No implicit conversions to/from numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow is handled by exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by zero, including 0 / 0.0.</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block</li>
      <li>Class definition block</li>
      <li>Method definition block</li>
      <li>Arbitrary <code>{ ... }</code> blocks</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadow the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>If an inner block declares a variable with the same name, it shadows the outer one.</li>
      <li>When a field name and a local variable name conflict, the local variable wins.
        The field is accessed via <code>this.</code>.</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks (member access shorthand)</h3>
    <p>
      Aloe provides <code>with</code> blocks to write repeated member accesses on the same object more concisely.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated only once at the beginning of the block and stored in an internal temp variable.</li>
          <li>The special temp variable <code>_</code> refers to the “with target object”.
            <ul>
              <li>For example, <code>log(_);</code> passes the with-target itself.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>The inner <code>with</code> shadows both the resolution for <code>.</code> and <code>_</code>.</li>
          <li>You can still access the outer object via its normal variable name.</li>
        </ul>
      </li>
      <li>Similar to C#’s <code>using</code>-style, multiple <code>with</code> clauses can be listed in the same block:</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The order in which the member is resolved among the objects is implementation-dependent.</li>
      <li>If resolution is ambiguous (multiple objects define the same member), it is a compile-time error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar. Semantically it can be desugared into explicit
      <code>obj.member</code> calls before type checking and code generation.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enum-member shortcuts for class / struct / enum)</h4>
    <p>
      In addition to <code>with (expr)</code>, Aloe supports <code>with</code> that targets a
      <strong>type name</strong>.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here, <code>TypeName</code> is one of:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>In this case, <code>with</code> is interpreted as a “type-context with”:</p>
    <ul>
      <li>The expression inside <code>()</code> is <em>not</em> evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; it does not create an instance.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>Valid <code>Member</code> are:
                <ul>
                  <li>static fields</li>
                  <li>static methods</li>
                  <li>enum / bitfield enum members (enumerators)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The temp variable <code>_</code> behaves as a pseudo-object representing the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members from a type-based with is a compile-time error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even in a type-based <code>with</code>, local variables or outer-scope variables with the same name are preferred.
      To explicitly refer to an enumerator or static member, use <code>TypeName.Member</code> or <code>.Member</code> / <code>_.Member</code>.
    </p>

    <h5>Example: static access of class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
    return 0;
}
</code></pre>

    <h5>Example: enum member access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      A type-based <code>with</code> can be combined with multiple targets:
    </p>
<pre><code>with (user), (Color) {
    .name = "Alice"; // user.name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      As before, resolution order is implementation-dependent. If resolution is ambiguous, it is a compile-time error.
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The variable type is inferred from the right-hand side expression.</li>
      <li><code>var x = 1;</code> is always <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile-time error (type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables cannot be reassigned.</li>
      <li>Type annotation is required for <code>const</code>.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields of class / struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: inside the constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … normal field.</li>
      <li><code>readonly field</code> … can be assigned only inside constructors; read-only afterward.</li>
      <li>Same meaning for both struct / class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended via <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>struct is a value type.</li>
      <li>Fields are limited to primitive types and other structs (reference type fields are forbidden).</li>
      <li>Copying a struct always performs a value copy.</li>
      <li>Struct inheritance is not supported (<code>sealed struct</code> is only a “no extension” marker).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li><code>implements</code> keyword is used to implement interfaces.</li>
      <li><code>is</code> operator can test whether an object implements an interface.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying traits with with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // method from Trait_A (if no conflicts)
</code></pre>

    <h4>Non-destructive add/remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj remains unchanged; obj2 has Trait_A applied
var obj3 = obj2 - Trait_A;     // obj3 is obj2 without Trait_A
</code></pre>

    <h4>Alias with as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: method exposed only via alias; not flattened
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define the same field / method name, it is a compile-time error.</li>
      <li>Members accessed only via alias (e.g. <code>as a</code>) are not considered in conflict checks.</li>
      <li>The interaction between class members and trait members with the same name will be specified in future versions.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li>At VM level, <code>delete obj;</code> is equivalent to <code>obj = null</code>.</li>
      <li>You cannot write <code>obj = null;</code> directly in source code.</li>
      <li>Reference types can be null internally, but the type system does not track nullability.</li>
      <li>Accessing a null reference may cause a <code>NullReferenceException</code>.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks.</li>
      <li>It respects inheritance (Derived is also a Base).</li>
      <li>It can also be used for interfaces and traits.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Array / List / Set / Map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // map&lt;int&gt; is alias of map&lt;string/int&gt;
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>Internal representation is always int32.</li>
      <li>Changing the underlying type such as <code>enum&lt;byte&gt;</code> or <code>enum&lt;string&gt;</code> is not allowed.</li>
      <li>Enum types can be used with type-based with, allowing shortened access to enumerators like <code>with (Color) { Red; }</code>.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that enumerator.</li>
      <li>At most 32 bits (n in 0–31) can be used in a bitfield enum.</li>
      <li>Sharing the same bit among multiple enumerators is allowed; it may only produce warnings.</li>
      <li>The underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code> etc. are compile-time errors.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (Entry Point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0; // process exit code
}
</code></pre>
    <ul>
      <li>Program entry point.</li>
      <li><code>args</code> is the command-line argument list.</li>
      <li><code>main</code> must be declared exactly as <code>function main(args: string[]): int</code>,
          and its return value is specified by an <code>int</code>-typed <code>return</code> statement.</li>
      <li>There is no special temp variable <code>_</code> in main; only ordinary locals.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;   // here, treated as a normal local variable
    return 0;
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // type of _ is determined by the first assignment in this block
}
</code></pre>
    <ul>
      <li><code>_</code> can be used in any block as a special temp variable without explicit declaration.</li>
      <li>In main, it has no special meaning and is treated like an ordinary variable.</li>
      <li>In blocks other than main, the type of <code>_</code> is determined by the first assignment in that block.</li>
      <li>Inside a with block, <code>_</code> additionally refers to the current with-target (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of <code>x</code> and <code>y</code>.</li>
      <li>Whether swap is valid is checked at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (from highest to lowest)</h3>
    <ol>
      <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Additive: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (has a distinct meaning in pipeline statements)</li>
      <li>Logical AND: <code>&amp;&amp;</code> (alias: <code>and</code>)</li>
      <li>Logical OR: <code>||</code> (alias: <code>or</code>)</li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignments (such as <code>+=</code>) are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown on division by zero, including 0 / 0.0.</li>
      <li>Parsing / formatting errors are treated as <code>FormatException</code>.</li>
      <li>Other fatal VM-level errors are implementation-dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> introduces references to other namespaces / symbols.</li>
      <li>File layout, handling of cyclic imports, and so on will be defined in the module specification.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to structure streaming processing
      in servers / CLI tools / web applications, etc.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of T-typed elements.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte stream such as stdin or sockets.</li>
      <li><code>pipe&lt;string&gt;</code> … stream of strings.</li>
      <li>Pipes assume value copy, not shared memory.</li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3>18.2 Result&lt;T&gt; and overview of ROP (Railway Oriented Programming)</h3>
    <p>
      Aloe handles error processing and branching in pipelines and filters via
      <strong>Result&lt;T&gt;</strong> and the idea of
      <strong>Railway Oriented Programming (ROP)</strong>.
    </p>
    <ul>
      <li><code>Result&lt;T&gt;</code> is a built-in generic type representing either “success (Ok)” or “failure (Error)”.</li>
      <li>Filters and future pipe definitions usually return <code>Result&lt;T&gt;</code> to explicitly represent success / failure.</li>
    </ul>

    <h4>18.2.1 Conceptual definition of Result&lt;T&gt;</h4>
<pre><code>// Conceptual pseudo-code (syntax will be finalized later)
Result&lt;T&gt; =
    Ok(value: T)
  | Error(message: string);  // or an error-info object
</code></pre>
    <p>
      Actual syntax and the payload of Error will be strictly defined by the VM / runtime spec and future extensions.
    </p>

    <h4>18.2.2 ROP (Railway Oriented Programming) image</h4>
    <p>
      ROP imagines “success track” and “failure track” running in parallel, where each step (filter)
      returns a <code>Result&lt;T&gt;</code>. Once an error occurs, downstream steps are skipped.
    </p>
<pre><code>Input
  ├─&gt; [ Filter A ] ──&gt; [ Filter B ] ──&gt; [ Filter C ] ──&gt; Output
  │         │               │               │
  │         └─&gt; Error ──────┴───────────────┴───&gt; Error path
  │
  └─&gt; (other branches such as logging, etc.)
</code></pre>
    <p>
      Filters in Aloe are designed, as far as possible, to have limited side effects and to aim for
      “quasi-idempotence”—returning the same output for the same input.
    </p>

    <h3>18.3 Basics and definition of filter(...)</h3>
    <p><code>filter(F)</code> is an intermediate transformation stage in a pipeline.</p>

    <h4>18.3.1 Filter definition (filter definition statement)</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // Type for options (optional)
    options: LineSplitOptions;

    // Field definitions (optional; kept minimal from a side-effect perspective)
    field _buffer: string = "";

    // Constructor (optional)
    constructor(opts: LineSplitOptions) {
        // Initialize based on values passed via options, etc.
    }

    // Body that flows from input pipe to output pipe
    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Ok(); // indicates the processing succeeded
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> specify the types of input and output pipes.</li>
      <li><code>options</code> specifies an option class (typically a bitfield enum, etc.) associated with this filter.</li>
      <li><code>field</code> can be used to hold internal state; however, from the ROP viewpoint, filters are expected
          to behave as “same input → same output”, so side-effectful fields should be kept to a minimum.</li>
      <li><code>constructor</code> is optional and can be used to receive option values or external parameters and perform initialization.</li>
      <li><code>bound(input, output): Result&lt;void&gt;</code> is the execution body of the filter.
          It returns <code>Ok()</code> on success and <code>Error(...)</code> on failure.</li>
    </ul>

    <h4>18.3.2 Filter options (filter option specification)</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Options follow <code>:</code> and are combined with <code>|</code>.</li>
      <li>Each filter has its own option type (bitfield enum, etc.).</li>
      <li>When a filter definition contains <code>options: JsonOptions;</code>, you may omit the class name and write only the enumerator
          when using it on a pipeline:</li>
    </ul>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
    <p>
      The above is equivalent to <code>JsonOptions.PrettyPrint | JsonOptions.IncludeNulls</code>, and the compiler checks
      that these are enumerators belonging to the class specified by <code>options</code>.
    </p>

    <h3>18.4 Pipeline statement and <code>|</code> / pipe-with operator <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li>In <code>A | B | C;</code>, the output of A is connected to B, and the output of B is connected to C.</li>
      <li>Type checking verifies the consistency of input/output types for each stage.</li>
      <li>The pipeline statement itself does not return a value; it only sets up connections as a side effect.</li>
    </ul>

    <h4>18.4.1 Pipe-with operator <span class="operator">|&gt;</span> (shortcut for filter conditions)</h4>
    <p>
      The operator <span class="operator">|&gt;</span> is defined as a shortcut for conditional filtering using
      <code>filter(if)</code>.
    </p>
<pre><code>// Full syntax
users
    | filter(if : .Age &gt;= 20 and .Gender == Gender.Male);

// Shortcut syntax (equivalent)
users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>
    <ul>
      <li>The right-hand side of <span class="operator">|&gt;</span> is a condition expression that uses an implicit context
          for the current element (similar to <code>.</code> in a with block).</li>
      <li>In the above example, it filters “users who are 20 or older and male”.</li>
      <li>Internally, <span class="operator">|&gt;</span> is expanded to <code>filter(if : ...)</code>, so it is enough to
          implement a single filter for <code>if</code> at runtime.</li>
    </ul>

    <h3>18.5 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> internally calls <code>p.next()</code> until EOF.</li>
      <li>When the writer calls <code>close()</code>, the reader detects EOF and terminates the loop.</li>
    </ul>

    <h3>18.6 Element transformation with map</h3>
    <p>
      Applying <code>map</code> to a pipe applies a function (or lambda) to each element and produces a stream of another type.
    </p>
<pre><code>// Using a function in map
function toName(u: User): string {
    return u.Name;
}

names = users | map(toName);

// Lambda-like notation (syntax is draft)
names = users | map (u) =&gt; u.Name;
</code></pre>
    <ul>
      <li><code>map</code> is defined as a built-in higher-order operation.</li>
      <li>The result of <code>map</code> is also a <code>pipe&lt;T&gt;</code> and can be further connected to other filters.</li>
    </ul>

    <h3>18.7 Template map for collection pipes</h3>
    <p>
      For collections (e.g. <code>User()</code> or <code>User{}</code>), a template-based <code>map</code> can also be used.
    </p>
<pre><code>users as u | map Customer {
    Name    = u.Name,
    Address = u.Address
}
</code></pre>
    <ul>
      <li><code>as u</code> introduces an alias for each element.</li>
      <li><code>map Customer { ... }</code> is treated as a template to create a new <code>Customer</code> object,
          with field assignments in the block defining how to map the source fields to the destination.</li>
      <li>The result is a collection type like <code>Customer()</code>, corresponding to the original collection.</li>
    </ul>

    <h3>18.8 close and EOF propagation</h3>
    <ul>
      <li>Calling <code>write()</code> on a closed pipe (<code>p.close()</code> already called) is invalid and may cause an error.</li>
      <li>Filters should call <code>close()</code> on their output when they detect EOF on their input.</li>
    </ul>

    <h3>18.9 Concurrency model using pipe</h3>
    <ul>
      <li>The primary means of communication between tasks is <code>pipe&lt;T&gt;</code>.</li>
      <li>A shared-nothing model is assumed; the design encourages avoiding shared mutable data structures.</li>
    </ul>

    <h3>18.10 Branching by match (branching on Result&lt;T&gt;)</h3>
    <p>
      For pipes or filters that return <code>Result&lt;T&gt;</code>, you can branch using <code>match</code>.
    </p>
<pre><code>stdin
    | filter(parseUser)
    | match {
        case Ok(u):
            // success path pipeline
            | filter(saveUser)
            | filter(logSuccess);
        case Error(e):
            // error path pipeline
            | filter(logError);
        default:
            // in case nothing matches (for future extension)
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... }</code> branches based on the <code>Result&lt;T&gt;</code> output of the immediately preceding stage.</li>
      <li>Right after <code>case pattern:</code>, you can continue to write a pipeline such as <code>| filter(...)</code>.</li>
      <li><code>default:</code> is optional and represents fallback when no <code>case</code> matches.</li>
    </ul>
<pre><code>| match {
    case Condition1:
        | filter(handleCase1);
    case Condition2:
        | filter(handleCase2);
    default:
        | filter(handleDefault);
}
</code></pre>
    <p>
      In the condition part, you can use <code>is</code> or Result patterns such as <code>Ok(...)</code>, <code>Error(...)</code>.
    </p>

    <h3>18.11 Example: simple REST-like pipeline</h3>
<pre><code>class User {
    field id: int;
    field name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    return 0;
}
</code></pre>
    <p class="note">
      <strong>Editing policy memo:</strong><br>
      ・This document is based on the English original, and the Japanese and English versions must always match in structure and meaning.<br>
      ・<code>edit-version</code> is shared between the Japanese and English versions and is incremented only when the content of the Japanese version changes (it never decreases).<br>
      ・<code>edit-date</code> records the time (year, month, day, hour, minute, second) at which each version is output.<br>
      ・As a rule, unrelated parts must not be changed. Even if the meaning is the same, wording and variable names must not be changed arbitrarily.<br>
      ・If you feel “this part should also be fixed,” stop editing, consult the user, and only then apply the change.<br>
      ・The full HTML output in the immediately preceding step is always treated as the “correct” base, and the next editing step must be limited to minimal diffs against that version.<br>
      ・If the previous HTML (the latest “correct” version) can no longer be seen or reconstructed, stop editing and consult the user.<br>
    </p>

  </main>
</div>
</body>
</html>
