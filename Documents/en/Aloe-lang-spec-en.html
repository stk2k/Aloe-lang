<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English)</title>
  <meta name="edit-version" content="3">
  <meta name="edit-date" content="2025-12-02T10:55:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • English translation + with extension</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with Blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English)</h1>
    <p class="note">
      This document is an English draft based on the original specification at<br>
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>.<br>
      On top of that, it adds an extension to <strong>4.2 with-blocks</strong>:
      <strong>type-based with for class / struct / enum (short-access to static members / enum cases)</strong>.<br>
      Apart from this, the specification is translated to English as faithfully as possible.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language aiming for simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and has the following main goals:
    </p>
    <ul>
      <li>Be easy to read and write for education and small applications</li>
      <li>Run on both the C# runtime and WebAssembly (WASM) environments</li>
      <li>Control I/O and concurrency in a statically typed way via <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Features:</p>
    <ul>
      <li>Static typing
        <ul>
          <li>Type inference via <code>var</code></li>
          <li>Explicit type annotation via <code>let</code></li>
        </ul>
      </li>
      <li>Value types / Reference types
        <ul>
          <li><code>struct</code> … value type</li>
          <li><code>class</code> … reference type</li>
        </ul>
      </li>
      <li>GC-based memory management (actual algorithm is VM-dependent)</li>
      <li>No direct <code>= null</code> in source code
        <ul>
          <li>Reference types can be null internally, but are manipulated via the sugar <code>delete</code>.</li>
        </ul>
      </li>
      <li>Data-flow style design with <code>pipe</code> / <code>filter</code></li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> to end-of-line is a line comment.</li>
      <li><code>/*</code> … <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assumed unsupported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code></li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Identifiers cannot have the same spelling as keywords.</li>
      <li>Identifiers starting with <code>_</code> are “private by convention” (not referred to from outside).</li>
      <li>Unicode characters can be used (excluding whitespace and separators).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> is not used; <code>namespace</code> is used instead.</li>
      <li><code>final</code> is removed; <code>sealed</code> is used to prohibit extension.</li>
      <li><code>instanceof</code> is removed; <code>is</code> is used for type checks.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, ...</li>
      <li>Floating point: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>Decimal: <code>10.12345678901234567890:d</code>, etc.</li>
      <li>Boolean: <code>true</code>, <code>false</code></li>
      <li>String: <code>"Hello, World!"</code></li>
      <li>Char: <code>'A'</code>, <code>'z'</code>, …</li>
      <li>null literal: <code>null</code></li>
      <li>Array literal: <code>[1, 2, 3]</code></li>
      <li>List literal: <code>(1, 2, 3)</code></li>
      <li>Set literal: <code>{1, 2, 3}</code></li>
      <li>Map literal: <code>["key1": 10, "key2": 20]</code></li>
      <li>enum literal: <code>EnumType.Value1</code></li>
      <li>struct literal: <code>Point { x: 0, y: 1 }</code></li>
      <li>Object creation: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>All statements end with a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion by newline.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines act as token separators.</li>
      <li>Consecutive whitespace is treated as a single separator.</li>
      <li>Indentation is not significant (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe has the following 7 primitive types:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – boolean value.</li>
      <li><code>int</code> / <code>integer</code> – signed integer.</li>
      <li><code>float</code> – floating point number.</li>
      <li><code>decimal</code> – high-precision decimal.</li>
      <li><code>string</code> – string (internally Unicode).</li>
      <li><code>null</code> – special type/value representing “no value”.</li>
      <li><code>void</code> – “no return value” (only for method return types).</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported by the language, but are excluded from the
      “primitive type” category and treated separately as numeric value types in Chapter 3.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Asynchronous task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see Chapter 18)</li>
    </ul>
    <p>There is no <code>any</code> type; dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implemented as a reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Fields of a struct can only be primitive types or other structs.</li>
      <li>Structs cannot have reference-type fields such as <code>class</code>.</li>
      <li>Assignments of structs always copy the value.</li>
      <li>No explicit limit on maximum size is imposed by the spec.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>A class can have structs as fields.</li>
      <li>Assigning a class instance to another variable copies the reference (the object is shared).</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> result in <code>float</code>.
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision decimal type.</li>
      <li>Expressions mixing <code>decimal</code> with <code>int</code>/<code>float</code> may be promoted to <code>decimal</code> as needed.</li>
      <li>Overflow / underflow / precision errors are represented as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>No implicit or explicit conversions between enum and int.</li>
      <li>Expressions mixing enums and numeric types are compile errors (except bitwise ops on bitfield enums).</li>
      <li>Internally, enum / bitfield enum are stored as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Arithmetic between bytes is allowed, but out-of-range values may cause errors.</li>
          <li>Expressions mixing byte and int are promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>No arithmetic on char.</li>
          <li>Comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are only for char-to-char.</li>
          <li>No implicit conversions with numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow is handled via exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown on division by zero (including 0 / 0.0).</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      A block is delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block</li>
      <li>Class definition blocks</li>
      <li>Method definition blocks</li>
      <li>Arbitrary <code>{ ... }</code> blocks</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadows the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>Declaring an inner variable with the same name shadows the outer one.</li>
      <li>If a field name and a local variable name conflict, the local variable wins.
        The field is accessed via <code>this.</code>.</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks (shorthand for member access)</h3>
    <p>
      Aloe has a <code>with</code> block to write repeated member access on one object concisely.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated once at the beginning of the block and stored in an internal temp variable.</li>
          <li>The special temp variable <code>_</code> refers to “the current with-target object”.
            <ul>
              <li>You can pass it, e.g., <code>log(_);</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>The inner <code>with</code> shadows the resolution of <code>.</code> and <code>_</code>.</li>
          <li>You can still access outer objects via their normal variable names.</li>
        </ul>
      </li>
      <li>Like C#’s <code>using</code>-style, multiple <code>with</code> targets can be written together:</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The order of resolution for which object <code>.Member</code> refers to is implementation-dependent.</li>
      <li>If resolution is ambiguous (the same member exists on multiple objects), it is a compile error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar: all occurrences can be desugared into explicit
      <code>obj.member</code> access, and type-checking / code generation can be performed on the desugared form.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enum shortcuts for class / struct / enum)</h4>
    <p>
      In addition to the usual <code>with (expr)</code>, you can use <code>with</code> with a <strong>type name</strong>.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here, <code>TypeName</code> is one of:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>In this case, <code>with</code> is interpreted as a “type context with”:</p>
    <ul>
      <li>The expression inside <code>()</code> is not evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; no instance is created.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>Valid <code>Member</code> targets are:
                <ul>
                  <li>static fields</li>
                  <li>static methods</li>
                  <li>enum / bitfield enum cases</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The temp variable <code>_</code> acts as a pseudo-object representing the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members in a type-based with is a compile error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even in a type-based with, local variables or outer scope variables with the same name take precedence.
      To explicitly refer to enum cases or static members, use <code>TypeName.Member</code> or <code>.Member</code> / <code>_.Member</code>.
    </p>

    <h5>Example: static access on class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

main(args: string[]) {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
}
</code></pre>

    <h5>Example: enum case access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

main(args: string[]) {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
}
</code></pre>
    <p>
      Type-based <code>with</code> can also be mixed with multiple with-targets:
    </p>
<pre><code>with (user), (Color) {
    .name = "Alice"; // user.name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      Resolution order is implementation-dependent, but ambiguity must result in a compile error.
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The variable’s type is inferred from the right-hand side.</li>
      <li><code>var x = 1;</code> is always <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile error (type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables cannot be reassigned.</li>
      <li>Const declarations require an explicit type annotation.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields of class / struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: inside the constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … ordinary field.</li>
      <li><code>readonly field</code> … assignable only in the constructor; read-only afterwards.</li>
      <li>Same semantics for struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li><code>class</code> is a reference type.</li>
      <li><code>sealed class</code> cannot be extended with <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li><code>struct</code> is a value type.</li>
      <li>Fields must be primitive types or other structs (no reference-type fields).</li>
      <li>Struct copying is always by value.</li>
      <li>Struct inheritance is not supported (<code>sealed struct</code> is a “no extension” marker only).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li>Interfaces are implemented using the <code>implements</code> keyword.</li>
      <li>Use the <code>is</code> operator to check whether an object implements an interface.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying traits with with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // method from Trait_A (if no conflicts)
</code></pre>

    <h4>Non-destructive add/remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj unchanged; obj2 has Trait_A
var obj3 = obj2 - Trait_A;     // obj3 is obj2 without Trait_A
</code></pre>

    <h4>Alias with as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: accessible only via alias
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define the same field/method name, it is a compile error.</li>
      <li>Applications with alias such as <code>as a</code> are excluded from conflict detection.</li>
      <li>The behavior when trait members conflict with class members is to be defined in a future version.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> is equivalent to <code>obj = null</code> at the VM level.</li>
      <li>You cannot write <code>obj = null;</code> directly in source code.</li>
      <li>Reference types can be null internally, but the type system does not track nullability.</li>
      <li>Accessing a null reference may throw <code>NullReferenceException</code>.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs a runtime type check.</li>
      <li>Inheritance is considered (an instance of Derived is also a Base).</li>
      <li><code>is</code> can also be used for interfaces and traits.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Array / List / Set / Map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // default key type is string
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>The underlying representation is always int32.</li>
      <li>Changing the underlying type, e.g. <code>enum&lt;byte&gt;</code> or <code>enum&lt;string&gt;</code>, is not allowed.</li>
      <li>Enums can be used in type-based with, allowing short access to enum cases via <code>with (Color) { Red; }</code>.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that case.</li>
      <li><code>bitfield enum</code> can use up to 32 bits (n = 0–31).</li>
      <li>It is allowed for multiple cases to share the same bit; the compiler may warn but not error.</li>
      <li>The underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code>, etc., are compile errors.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (entry point)</h2>
<pre><code>main(args: string[]) {
    var fb = new FizzBuzz();
    fb.run();
    _ = 0; // process exit code (int)
}
</code></pre>
    <ul>
      <li>The entry point of the program.</li>
      <li><code>args</code> holds the command-line arguments.</li>
      <li>In the main block, the temp variable <code>_</code> is always of type <code>int</code>, and its value is used as the process exit code.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>main(args: string[]) {
    var x = 10;
    _ = x + 5;   // _ is int (exit code)
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // type of _ is inferred in this block
}
</code></pre>
    <ul>
      <li><code>_</code> is a special temp variable that can be used in any block without an explicit declaration.</li>
      <li>In <code>main</code>, <code>_</code> is always <code>int</code>.</li>
      <li>In other blocks, the type of <code>_</code> is determined by the first assignment in that block.</li>
      <li>Inside a <code>with</code> block, <code>_</code> additionally refers to the current with-target (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of <code>x</code> and <code>y</code>.</li>
      <li>Whether swap is valid is checked at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (from high to low)</h3>
    <ol>
      <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Additive: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (has a different meaning in pipeline statements)</li>
      <li>Logical AND: <code>&amp;&amp;</code></li>
      <li>Logical OR: <code>||</code></li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignments such as <code>+=</code> are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown on division by zero (including 0 / 0.0).</li>
      <li>Parsing/format errors are represented by <code>FormatException</code>.</li>
      <li>Other fatal VM-level errors are implementation-dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> introduces references to other namespaces / symbols.</li>
      <li>Details such as file layout and cyclic imports are defined by a separate module specification.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to build streaming processing
      for servers, CLI tools, web applications, etc.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of elements of type <code>T</code>.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte stream such as stdin or sockets.</li>
      <li><code>pipe&lt;string&gt;</code> … string stream.</li>
      <li>Pipes are based on value copying, not shared memory.</li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3>18.2 Basics of filter(...)</h3>
    <p><code>filter(F)</code> is an intermediate transformation stage in a pipeline.</p>

    <h4>18.2.1 Filter definition</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(input, output) {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
    }
}
</code></pre>

    <h4>18.2.2 Filter options</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Options are specified after <code>:</code> and combined with <code>|</code>.</li>
      <li>Each filter has its own option type (e.g. bitfield enum).</li>
    </ul>

    <h3>18.3 Pipeline statements and <code>|</code></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li>In <code>A | B | C;</code>, the output of A is connected to B, and the output of B to C.</li>
      <li>Type-checking ensures consistency of input/output types across stages.</li>
      <li>The pipeline statement itself does not return a value (it only establishes connections as side effects).</li>
    </ul>

    <h3>18.4 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> internally calls <code>p.next()</code> until EOF.</li>
      <li>When the writer calls <code>close()</code>, the reader detects EOF and exits the loop.</li>
    </ul>

    <h3>18.5 close and EOF propagation</h3>
    <ul>
      <li>After <code>p.close()</code>, calls to <code>write()</code> are invalid (may cause errors).</li>
      <li>Filters should call <code>close()</code> on their output when EOF is detected on the input.</li>
    </ul>

    <h3>18.6 Concurrency model with pipes</h3>
    <ul>
      <li>The main communication between tasks is <code>pipe&lt;T&gt;</code>.</li>
      <li>A shared-nothing model is assumed; shared mutable data structures are discouraged.</li>
    </ul>

    <h3>18.7 Example: simple REST-like pipeline</h3>
<pre><code>class User {
    field id: int;
    field name: string;
}

main(args: string[]) {
    let req: pipe&lt;byte&gt; = pipe&lt;byte&gt;.create();
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    _ = 0;
}
</code></pre>
    <p class="note">
      Details of standard filters such as <code>utf8</code> and <code>json&lt;T&gt;</code> are specified in a separate
      “standard filter library” document, not in the core language spec.
    </p>

    <hr>
    <p class="note">
      The above is the Aloe language specification (HTML, English version) based on the original English spec,
      plus the type-based with extension.<br>
      <strong>Editing policy (summary):</strong><br>
      ・<code>edit-version</code> is shared between the Japanese and English versions and indicates the common spec version.<br>
      ・The Japanese and English versions must represent exactly the same specification content.<br>
      ・Unrelated parts should basically not be modified.<br>
      ・Even changes that do not alter meaning (identifier names, casing, comments, etc.) are prohibited in principle.<br>
      ・If such changes seem necessary, editing must be paused and discussed with the author first.<br>
      ・This HTML is treated as the “canonical” version (“正”), and all future edits must follow the above policy.<br>
    </p>

  </main>
</div>
</body>
</html>
