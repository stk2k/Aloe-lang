
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – Pipe/Filter/producer/consumer + delete/with/lock/class inheritance/generics/events)</title>
  <meta name="last-updated" content="2025-11-29T12:00:00+09:00" />
  <style>
    /* Minimal layout only. Let the browser decide fonts. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / Pipe, Filter, Producer, Consumer + delete/with/lock/class inheritance/generics/events</div>
    <div class="updated">Last updated: 2025-11-29 12:00:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#functions-methods">5. Functions and Methods</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>

      <div class="section-title">Syntactic Extensions</div>
      <a href="#with">7. with Construct</a>
      <a href="#delete">8. delete Construct</a>
      <a href="#lock">9. lock Construct and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model and Memory Management</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Work</a>
      <a href="#events">13. Events</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing, simple syntax, and
        a stack-based virtual machine (AloeVM).
        It is designed with a particular focus on <strong>dataflow in Pipe / Filter style</strong>
        and interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type checking is performed at compile time).</li>
        <li>C-like surface syntax, but with a deliberately small feature set.</li>
        <li>Emphasis on writing “data flow and transformation” comfortably for:
          <br />text processing, REST calls, logging, etc.</li>
        <li>Assumes a stack-based VM (AloeVM) and a future WebAssembly backend.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft language specification</strong>.<br />
        There may be differences from the actual compiler / VM implementation.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: the specification itself should be readable as documentation.</li>
        <li><strong>Ease of implementation</strong>: implementable with a small compiler and VM.</li>
        <li><strong>Consistency of Pipe / Filter</strong>: type-safe representation of dataflow.</li>
        <li><strong>Bridge to Wasm</strong>: easy to connect to future Wasm component model.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Being a “do everything” general-purpose language.</li>
        <li>Competing with highly optimized JIT compilers in terms of performance.</li>
        <li>Complex metaprogramming (macros, etc.) is out of scope for now.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source files are assumed to be encoded in UTF-8.</li>
        <li>Single-line comment: <code>// comment</code></li>
        <li>Multi-line comment: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifier: starts with a letter or <code>_</code>, followed by letters, digits, or <code>_</code>.</li>
        <li>Keywords are reserved words and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code>, <code>event</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td>
        </tr>
        <tr>
          <td>Functions</td>
          <td><code>method</code></td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are surrounded by <code>{ ... }</code>.</li>
        <li>Conditions in control constructs must be of type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit-width is implementation-dependent; assume 32-bit here).</td></tr>
        <tr><td><code>Float</code></td><td>Floating point (32 or 64 bit, implementation-dependent).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-dependent).</td></tr>
      </table>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-length array: <code>T[]</code></li>
        <li>For variable-length and lazily evaluated sequences, use <code>Pipe&lt;T&gt;</code> (details in Section 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignments copy values.</li>
        <li>Copying is shallow; sharing of nested reference-type fields depends on the VM implementation.</li>
        <li>A struct may inherit from at most one other struct (single inheritance of structs).</li>
        <li>It is <strong>forbidden</strong> for a struct to implement an <code>interface</code>.
          (How it interacts with traits and generic constraints will be clarified in future revisions.)
        </li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as <strong><code>Int</code></strong>.</li>
        <li>“Generic enums” such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are
          <strong>forbidden</strong>.
        </li>
        <li>Enums used as bit flags are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed)</h2>

      <h3>4.5.1 Class Basics</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignments perform <strong>reference copies (shallow copies)</strong>.</li>
        <li>The <code>clone</code> keyword creates a shallow copy and returns a new reference.</li>
        <li>All classes are <strong>cloneable</strong>; there is no type-level way to declare “non-cloneable” classes.<br />
          If cloning should be avoided, handle that via API design or coding guidelines.
        </li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // reference copy (A and B point to the same instance)

var C: User = clone A;  // returns a new instance that is a shallow copy</code></pre>

      <p class="note">
        A <strong>shallow copy</strong> means “copy field values as they are”.<br />
        If a field itself is a reference type, that reference value is copied.
        For deep copies or custom cloning logic, provide user-defined APIs such as a <code>Clone</code> method
        on top of the language-level <code>clone</code>.
      </p>

      <h3>4.5.2 Class Inheritance (Single Inheritance)</h3>
      <p>
        Aloe <code>class</code> supports <strong>single inheritance</strong> only.<br />
        That is, a class can have exactly one base class.
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// The following is a compile error (multiple inheritance of classes is forbidden)
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>Class hierarchies form trees (or chains); diamond inheritance cannot occur.</li>
        <li>Class inheritance is a mechanism for reusing state and behavior.</li>
      </ul>

      <h3>4.5.3 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance of classes,
        Aloe uses <strong>interface</strong> and <strong>trait</strong>
        to compose behavior.
      </p>

      <ul>
        <li><code>interface</code> defines method signatures but no implementations
          (whether to allow default implementations is a future topic).
        </li>
        <li><code>trait</code> is a mixin unit that can contain implementations,
          used to add behavior to existing classes.
        </li>
        <li>A class can have <strong>one</strong> base class, implement multiple <code>interface</code>s,
          and apply multiple <code>trait</code>s via <code>with</code>.
        </li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose(): Unit;
}

trait Printable {
  method PrintSelf(): Unit {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose(): Unit {
    // resource cleanup
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        The detailed syntax and rules for <code>interface</code> and <code>trait</code>
        (inheritance, resolving conflicts when multiple traits define the same method, etc.)
        are not fully defined in this draft. Only the general direction is described here.
      </p>

      <h3>4.5.4 sealed Classes</h3>
      <p>
        To forbid inheritance from a specific class, Aloe provides the <code>sealed</code> modifier.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// This is a compile error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li><code>sealed class</code> cannot be used as a base class.</li>
        <li>Even if a class is <code>sealed</code>, it may still implement interfaces and
          have traits applied via <code>with</code>.</li>
        <li>In the future, we plan to combine sealed classes with unions and pattern matching
          to support exhaustiveness checking.</li>
      </ul>

      <h3>4.5.5 readonly and Classes</h3>
      <ul>
        <li>Fields of a class are mutable by default.</li>
        <li>Adding the <code>readonly</code> modifier to a field makes it immutable:
          <ul>
            <li>Assignments to that field are only allowed in
              <strong>field initializers</strong> and
              <strong>constructors of the same class</strong>.
            </li>
            <li>Any other assignment is a compile error.</li>
          </ul>
        </li>
        <li><code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are implicitly treated as <code>readonly</code>.</li>
            <li>Assignments to fields are only allowed in field initializers and constructors of that class.</li>
            <li>After the constructor completes, no code may modify any field of that instance.</li>
          </ul>
        </li>
        <li><code>readonly</code> and <code>clone</code> are orthogonal:
          a <code>readonly class</code> can still be cloned with <code>clone</code>.
          The cloned instance has the same immutable state.
        </li>
      </ul>

      <p class="small">
        In summary, classes are heap-allocated reference types with single inheritance;
        multiple behaviors are composed via interface + trait;
        inheritance can be forbidden via <code>sealed</code>;
        and <code>readonly</code> expresses immutability at field or class level.<br />
        The details of method resolution order and trait conflict resolution will be specified separately.
      </p>
    </section>

    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, functions, methods,
        and pipe-related declarations.<br />
        The goal is to enable type-safe reuse for collections and Pipe / Filter,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: T -&gt; U): Pipe&lt;U&gt; {
  // Implementation omitted
}</code></pre>

      <h3>4.6.2 Generic Type Parameters</h3>
      <ul>
        <li>Types, struct, class, interface, trait, method,
          and producer/filter/consumer declarations may take type parameters
          via <code>&lt;T, U, ...&gt;</code>.
        </li>
        <li>Type parameter names are recommended to start with uppercase
          (e.g. <code>T</code>, <code>TItem</code>, <code>TKey</code>).</li>
        <li>Type arguments are bound to concrete types at use sites.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // Implementation omitted
}</code></pre>

      <h3>4.6.3 where Type Constraints (Overview)</h3>
      <p>
        Aloe generics support arbitrary type constraints using a <code>where</code> clause.<br />
        The default is “no constraints”, but version 0.1 will support a few basic constraints.
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int-specific summation
}</code></pre>

      <p class="note">
        Here, <code>where</code> exists solely for <strong>compile-time type checking</strong>.<br />
        The runtime representation (monomorphization vs. shared code with type tags, etc.) is left to the VM.
      </p>

      <h3>4.6.4 Supported Kinds of Constraints</h3>
      <p>
        In version 0.1, the following constraints are supported:
      </p>

      <ul>
        <li><strong>Value type / reference type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive-type constraints</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>, etc.,
              can directly specify primitive type names.
            </li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – types implementing trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – type must be exactly the struct <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – type must be exactly the class <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Any concrete type name</strong>
          <ul>
            <li>Any existing concrete type name can be used (e.g. <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Generic restricted to value types
method Zero&lt;T&gt;(): T
  where T: struct
{
  // Implementation omitted
}

// Pipe specialized for Int
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // Implementation omitted
}

// Generic restricted to a specific struct type
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // Implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior When Constraints Are Violated</h3>
      <ul>
        <li>If a type argument for a generic function/type does not satisfy its <code>where</code> constraints,
          this is a compile error.
        </li>
        <li>When multiple constraints are specified, all of them must be satisfied simultaneously.</li>
        <li>Circular constraints and advanced typeclass-like structures are not supported at this time.</li>
      </ul>

      <pre><code>// Example of a compile error:

// T is constrained to Int, so it cannot be String
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization vs. shared code with type tags, etc.)
        is defined by AloeVM.<br />
        The language spec focuses on type-safe reuse and constraint checking via <code>where</code>.
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. Functions and Methods</h2>

      <h3>5.1 method Declarations</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> defines top-level functions or methods bound to types.</li>
        <li>If the return type is omitted, the method is assumed to return <code>Unit</code>.</li>
      </ul>

      <h3>5.2 Adding Methods via bound</h3>
      <p>
        Aloe uses <code>bound</code> blocks to add methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // Internal representation is VM-dependent
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // Implementation omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, we introduce a <strong>restriction</strong> on methods declared inside
        <code>bound</code> blocks (see Section 6.2 for details) regarding their return types.
      </p>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is that it can express
        <strong>dataflow in Pipe / Filter style</strong>
        in a type-safe and consistent way.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, the above is equivalent to the following nested calls:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>Aloe’s <code>|&gt;</code> operator is syntactic sugar for such function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe,
          corresponding to lazy sequences, streams, and iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents “a pipe through which elements of type <code>T</code> flow”.</li>
          <li>Internal representation (chained iterators, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers / transformers / consumers based on <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // VM-dependent internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the realm composed of functions that take and/or return
          <code>Pipe&lt;T&gt;</code> (producers / transformers / consumers).<br />
          Consumers are the exit from the pipe world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, we classify functions and objects into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>:
            a function/object whose return type is <code>Pipe&lt;*&gt;</code>
            and that appears at the beginning of a pipeline.
          </li>
          <li><strong>Role</strong>:
            read data from the external world (file, HTTP, array, etc.)
            and feed it into the pipe world (<code>Pipe&lt;T&gt;</code>).
          </li>
          <li><strong>Type</strong>:
            conceptually of the shape <code>X -&gt; Pipe&lt;T&gt;</code>.
            A producer is always designed to output a <code>Pipe&lt;*&gt;</code>.
          </li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filter)</h4>
        <ul>
          <li><strong>Definition</strong>:
            a function/method of type <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.</li>
          <li><strong>Role</strong>:
            transforms/filters/sorts data inside the pipe world,
            without exiting the pipe world.
          </li>
        </ul>

        <p>
          In Aloe, methods declared inside <strong><code>bound Pipe&lt;T&gt;</code></strong>
          are intended for use as transformers (intermediate filters).
        </p>

        <div class="note">
          <strong>Restriction:</strong><br />
          Methods declared in a <code>bound Pipe&lt;T&gt;</code> block must<br />
          return <strong><code>Pipe&lt;*&gt;</code></strong>.<br />
          In other words, their type must be of the form <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; { ... }

  // OK: changes element type
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; { ... }

  // NG: return type is not Pipe, so this should be a compile error
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer (Terminal Filter)</h4>

        <ul>
          <li><strong>Definition</strong>:
            a function/object of type <code>Pipe&lt;T&gt; -&gt; R</code> where
            <code>R</code> is not <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><strong>Role</strong>:
            the exit from the pipe world, consuming the pipe entirely and producing
            an array, scalar, or external I/O.
          </li>
          <li><strong>Return type</strong>:
            there are no restrictions as long as <code>R</code> is not <code>Pipe&lt;*&gt;</code>.
            It can be <code>T[]</code>, <code>Int</code>, <code>Unit</code>, etc.
          </li>
        </ul>

        <pre><code>// Consumer that materializes a pipe as an array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer that counts elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms for building Pipe / Filter components:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of these are treated as “objects with constructors” whose <code>bound</code> blocks
          run when they are connected in a pipeline.
        </p>

        <h4>6.3.1 producer Declarations</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when the producer is connected to a pipeline
    // Reads data from external resources and writes to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the producer’s name.</li>
          <li><code>out</code> specifies the <strong>output type</strong> in the pipe world.
            It must be a <code>Pipe&lt;*&gt;</code> type.
          </li>
          <li><code>bound(output)</code> defines the behavior when the producer is connected.
            The type of <code>output</code> is the same as the type specified in <code>out</code>,
            e.g. <code>Pipe&lt;T&gt;</code>.
          </li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are visible from inside the <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo code:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe Declarations</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connect pipes and perform transformation
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the pipe’s name.</li>
          <li><code>in</code> is the type of the “upstream” input.</li>
          <li><code>out</code> is the type of the “downstream” output.</li>
          <li><code>bound(input, output)</code> describes how to transform input into output.</li>
        </ul>

        <p class="note">
          Pipe declarations are intended for bridging external resources (sockets, HTTP, etc.)
          and different kinds of streams (text → JSON, etc.).
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // decoded object

  bound(input, output) {
    // Pseudo code:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter Declarations</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Define how elements flow from input to output
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> is the filter’s name.</li>
          <li><code>in</code> / <code>out</code> specify input and output types.</li>
          <li>In Pipe / Filter chains, intermediate filters usually take and return
            <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><code>bound(input, output)</code> describes the transformation between them.</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo code:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo code:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer Declarations</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Executed at the end of the pipeline
    // Consumes input and returns some value
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the consumer’s name.</li>
          <li><code>in</code> specifies the input type.
            In the Pipe / Filter model it will usually be <strong><code>Pipe&lt;T&gt;</code></strong>.
          </li>
          <li><code>bound(input)</code> is executed at the end of the pipeline,
            consuming <code>input</code> and returning a value of arbitrary type <code>R</code>.
          </li>
          <li><code>R</code> can be any type such as <code>T[]</code>, <code>Int</code>, <code>Bool</code>, <code>Unit</code>,
            but must <strong>not</strong> be <code>Pipe&lt;*&gt;</code>.
          </li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo code:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo code:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, the roles of pipe-related declarations are:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code>
              (always outputs a <code>Pipe</code>)</li>
            <li><strong>pipe</strong>: bridging heterogeneous streams and external I/O</li>
            <li><strong>filter</strong>: usually <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> transformations</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → non-<code>Pipe</code> type
              (the exit from the pipe world)</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition</h4>
        <p>
          Aloe’s <code>|&gt;</code> is defined as syntactic sugar for
          <strong>simple function composition</strong>.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>A -&gt; B</code> and <code>G</code> has type <code>B -&gt; C</code>,
            then <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.
          </li>
          <li>This operator can be applied to any type; it is not limited to <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Therefore, from the type system’s point of view,
          “changing the return type in the middle of a pipeline” is not a problem.<br />
          Constraints in the Pipe / Filter model are provided by the
          <strong><code>Pipe&lt;T&gt;</code> type and pipe-related library design</strong>,
          not by the operator itself.
        </div>

        <h4>6.4.2 Using Pipe&lt;T&gt; with <code>|&gt;</code></h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>String -&gt; Pipe&lt;String&gt;</code>)</li>
          <li><code>Where</code>, <code>Map</code>: transformers (<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>)</li>
          <li><code>ToArray</code>: consumer (<code>Pipe&lt;User&gt; -&gt; User[]</code>)</li>
          <li>The overall type of the pipeline is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          At the language level, it is allowed to continue using <code>|&gt;</code>
          even after a consumer,<br />
          but stylistically this is discouraged.<br />
          For example, patterns like <code>ToArray() |&gt; ToArray()</code> should be avoided.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters and Producers</h3>

        <h4>6.5.1 Representative Transformers (Filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Representative Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Representative Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns Int
}</code></pre>

        <h4>6.5.4 Example Usage</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with Construct</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> construct is syntactic sugar to avoid repeatedly writing
        the same target object for property assignments and method calls.<br />
        In Aloe it also acts as a <strong>“lifetime lock”</strong>,
        keeping the target object alive for the duration of the block.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The <code>with</code> block above is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li>In <code>with (Expr) { ... }</code>, <code>Expr</code> is evaluated <strong>exactly once</strong>.</li>
        <li>Within the block, simple identifiers on the left-hand side of assignments
          are interpreted as member accesses on the target object.</li>
      </ul>

      <h3>7.3 Lifetime Lock (Behavior as a GC Root)</h3>
      <p>
        AloeVM is assumed to use a combination of reference counting and sliding compaction
        for memory management.<br />
        Within this model, a <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The result of evaluating <code>with (Expr)</code> is stored in a hidden variable (a GC root).</li>
        <li>This hidden variable keeps the object alive until the block is exited,
          guaranteeing that the object is <strong>not collected</strong> while inside the block.
        </li>
        <li>Thus, the object is guaranteed to be alive while the block executes.</li>
      </ul>

      <h3>7.4 Relationship Between with and delete</h3>
      <ul>
        <li>If a variable is the target of a <code>with</code> block,
          then issuing <code>delete</code> on that same variable inside the block
          is a compile error.</li>
        <li>The reason is that <code>with</code> expresses the intent
          “I want this object to stay alive here”,
          which conflicts with <code>delete</code>.</li>
        <li>However, it is allowed to <code>delete</code> another variable that points to
          the same object. The GC root introduced by <code>with</code> remains,
          so the object itself stays alive.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is protected by with and is guaranteed to be alive in this block

  delete Alias;   // OK: only removes the reference from Alias
  Url = "https://example.com/api";  // still usable
}

// After leaving the with block, the GC root is removed.
// If no other references remain, the object will eventually be collected.</code></pre>

      <p class="note">
        In summary, <code>with</code> is both
        <strong>syntactic sugar for member access</strong> and
        <strong>a mechanism for temporarily holding the target object as a GC root</strong>.<br />
        When we want to protect the same target with locking, we can use
        <code>lock with</code> (Section 9.3).
      </p>
    </section>

    <section id="delete">
      <h2>8. delete Construct</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> does <strong>not</strong> directly destroy an object.<br />
        Instead, it is a construct for <strong>removing a reference from a variable</strong>.
      </p>
      <ul>
        <li>Actual object destruction (memory reclamation, finalizers, etc.) is performed by
          the <strong>runtime (AloeVM) using reference counting + GC</strong>.
        </li>
        <li><code>delete</code> is intended as a type-safe way to express
          “this variable no longer refers to this object”, instead of assigning null.</li>
      </ul>

      <h3>8.2 Grammar</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile Time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After <code>delete</code>, reading from that variable or doing member access / method calls
          is a compile error</strong>.</li>
        <li>However, assigning a new value to that variable is allowed.
          Conceptually, <code>delete</code> returns the variable to an “uninitialized” state.</li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Use Buf
DoSomething(Buf);

delete Buf;

// From here, reading Buf or Buf.Length is a compile error

Buf = NewBuffer();  // after re-assignment, Buf can be used again</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>Decrease the reference count on the object currently pointed to by <code>Var</code>
          (assuming reference counting).</li>
        <li>Mark <code>Var</code> itself as “uninitialized / deleted”.</li>
        <li>When the object’s reference count reaches 0, the object is freed at the discretion of the GC.<br />
          <strong>In other words, there is no guarantee that the object is destroyed immediately
          when <code>delete</code> is executed.</strong>
        </li>
      </ul>

      <p class="note">
        In this language spec, the timing of object destruction is the responsibility of the VM/runtime.<br />
        <code>delete</code> only removes a reference from one variable.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>As described in Section 7.4, it is a compile error to issue <code>delete</code>
          on a variable that is the target of a <code>with</code> block, inside that block.</li>
        <li>It is allowed to <code>delete</code> a different variable that points to the same object,
          because the object is still kept alive by the GC root introduced by <code>with</code>.</li>
      </ul>

      <p class="note">
        In the future, if Aloe introduces “owned resource types” or an ownership model,
        <code>delete</code> may be integrated with that model.<br />
        In this draft, we assume <strong>no ownership model</strong>.
      </p>
    </section>

    <section id="lock">
      <h2>9. lock Construct and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> construct acquires a lock on a particular object and,
        during the execution of the block, guarantees exclusive access to that object and
        enables optimizations of read barriers.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> acquires a lock on the object represented by <code>Expr</code> and
          guarantees exclusive access inside <code>Body</code>.</li>
        <li>Lock acquisition and release are implemented by the VM.</li>
        <li>Updates to data shared across threads should generally be confined inside <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM is assumed to use sliding compaction for memory management.<br />
        Inside a <code>lock</code> block, the VM can optimize read barriers
        and reduce checks for each object to as few as possible.
      </p>

      <h3>9.3 lock with Construct (lock + with Combination)</h3>
      <p>
        For situations where we want to apply both “exclusive lock”
        and “lifetime lock (with)” to the same target object,
        Aloe provides a <code>lock with</code> construct.
      </p>

      <pre><code>lock with (Conn) {
  // Here:
  //   - Conn is locked exclusively
  //   - Conn is held as a GC root by with
  //   - Members of Conn can be referenced without qualification (RequestUrl, etc.)
}</code></pre>

      <h4>9.3.1 Grammar</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <p>
        <code>lock with (Expr) { Body }</code> is a combined construct where <code>Expr</code> is evaluated once,
        and the result is used as the target of both <code>lock</code> and <code>with</code>.
      </p>

      <h4>9.3.2 Desugaring (Semantically Equivalent Code)</h4>
      <p>
        <code>lock with (Expr) { Body }</code> is semantically equivalent to:
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> is evaluated exactly once and bound to a temporary <code>__tmp</code>.</li>
        <li><code>lock</code> and <code>with</code> are then applied to <code>__tmp</code> in nested fashion.</li>
        <li>Thus, during execution of <code>Body</code>:
          <ul>
            <li>Exclusive access to the target object is guaranteed (<code>lock</code> semantics).</li>
            <li>The target is kept alive as a GC root by <code>with</code>.</li>
            <li>Members of the target can be referenced in the same way as in a <code>with</code> block.</li>
          </ul>
        </li>
      </ul>

      <h4>9.3.3 Style and Constraints</h4>
      <ul>
        <li><code>lock with</code> is syntactic sugar to express the intent
          “operate on a particular resource exclusively and safely within a lifetime range”
          in a single construct.</li>
        <li>Alternative spellings such as <code>with lock (Expr)</code> or <code>lock &amp; with (Expr)</code>
          are not defined in the language spec.<br />
          For this purpose, always use <code>lock with</code>.
        </li>
        <li>Behavior inside a <code>lock with</code> block is interpreted as the combination of rules
          from Section 9.2 (<code>lock</code>) and Section 7.3 (<code>with</code>).</li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// Upon leaving the block, the lock is released and
// the lifetime lock from with is also released.</code></pre>
    </section>

    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside the <code>try</code> block can be caught by corresponding <code>catch</code> blocks.</li>
        <li>The <code>finally</code> block is executed regardless of whether an exception is thrown.</li>
        <li>The details of exception types and their hierarchy are defined on the VM side.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. Execution Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>A stack-based bytecode VM.</li>
        <li>Function calls push frames on a call stack.</li>
        <li>GC is assumed to use reference counting plus sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>When certain conditions are met, GC runs, slides live objects,
          and compacts memory.</li>
        <li><code>with</code> acts as a temporary GC root to keep objects alive, and in
          combination with <code>lock</code> enables optimization of read barriers.</li>
        <li>Normally, calling <code>delete</code> is not required for memory management.
          Use <code>delete</code> only when you explicitly want to drop a reference.</li>
      </ul>

      <p class="small">
        A detailed opcode table and GC implementation details are provided in the AloeVM specification.
      </p>
    </section>

    <section id="limits">
      <h2>12. Limitations and Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>The expressiveness of generics is minimal; typeclasses and higher-kinded generics are not defined.</li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>12.2 Future Work</h3>
      <ul>
        <li>Parallelization and fusion optimizations for Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Introducing error-handling constructs such as a Result type, in addition to exceptions.</li>
        <li>Extending standard libraries for distributed processing and streaming.</li>
        <li>Integrating <code>delete</code> with owned resource types and an ownership model if needed.</li>
        <li>Integrating trait / interface / sealed / readonly with pattern matching
          and exhaustiveness checking.</li>
      </ul>

      <p class="note">
        This draft focuses especially on:<br />
        <strong>the relationships between Pipe / Filter and Producer / Transformer / Consumer / Pipe / Consumer</strong>,<br />
        and<br />
        <strong>the relationships between with / delete / lock / class inheritance / readonly / clone / generics
        and the AloeVM memory model</strong>.
      </p>
    </section>

    <section id="events">
      <h2>13. Events</h2>

      <h3>13.1 Motivation and Overview</h3>
      <p>
        Aloe provides an <code>event</code> construct to model push-style callbacks
        (for example “something has changed” notifications) in a structured way,
        similar to C# events.
      </p>
      <ul>
        <li>Events are multi-cast: multiple handlers can be subscribed to a single event.</li>
        <li>Handlers are ordinary methods whose signatures are checked by the type system.</li>
        <li>Subscribers can only add/remove handlers; only the declaring type is allowed to raise the event.</li>
      </ul>

      <h3>13.2 Event Handler Types</h3>
      <p>
        Aloe does not introduce a special “delegate” declaration.
        Event handler types are expressed using normal function types.
      </p>

      <pre><code>// Example: event args type
struct ValueChangedEventArgs {
  OldValue: Int;
  NewValue: Int;
}

// Event handler type (informal notation):
// (Sender: Counter, Args: ValueChangedEventArgs) -&gt; Unit</code></pre>

      <p class="note">
        The exact grammar of function types (multiple parameters, named parameters, etc.)
        is defined in the core type system.
        For events, the common convention is:
        <ul>
          <li>First parameter: the sender (the instance raising the event).</li>
          <li>Second parameter: an “event args” struct that carries additional data.</li>
          <li>Return type: no meaningful value (the handler is used for side effects).</li>
        </ul>
      </p>

      <h3>13.3 Event Declarations</h3>
      <p>
        Events can be declared as members of classes or structs using the <code>event</code> keyword.
        An event has a name and a handler type.
      </p>

      <pre><code>class Counter {
  Value: Int;

  // Event raised when Value changes
  event Changed: (Sender: Counter, Args: ValueChangedEventArgs) -&gt; Unit;

  method Increment() {
    let Old = Value;
    Value = Value + 1;
    RaiseChanged(Old, Value);
  }

  method RaiseChanged(Old: Int, New: Int) {
    let Args: ValueChangedEventArgs;
    Args.OldValue = Old;
    Args.NewValue = New;

    // Raising the event (details in 13.5)
    Changed(this, Args);
  }
}</code></pre>

      <ul>
        <li>Only the declaring type (here: <code>Counter</code>) is allowed to invoke
          <code>Changed(...)</code> directly.</li>
        <li>From outside, code can subscribe/unsubscribe, but not call the event.</li>
      </ul>

      <h3>13.4 Subscribing and Unsubscribing</h3>
      <p>
        Handlers are attached to events using <code>+=</code> and removed using <code>-=</code>,
        following C#-like syntax.
      </p>

      <pre><code>method LogCounterChange(Sender: Counter, Args: ValueChangedEventArgs): Unit {
  Print("Counter changed: " + Args.OldValue + " -&gt; " + Args.NewValue);
}

var C: Counter;

// Subscribe
C.Changed += LogCounterChange;

// Unsubscribe
C.Changed -= LogCounterChange;</code></pre>

      <ul>
        <li>The right-hand side of <code>+=</code> / <code>-=</code> must be a function value
          (for example a named method or a lambda)
          whose type is compatible with the event’s handler type.</li>
        <li>If the types are incompatible, it is a compile-time error.</li>
        <li>Subscribing the same handler multiple times is allowed;
          each subscription represents a separate entry in the internal handler list.</li>
      </ul>

      <p class="note">
        <strong>Informal runtime model:</strong><br />
        Each event is backed by an internal list of handlers.
        <code>+=</code> appends to this list, and <code>-=</code> removes the first matching entry.
        The exact data structure is implementation-dependent.
      </p>

      <h3>13.5 Raising Events</h3>
      <p>
        Inside the declaring type, raising an event is expressed as an ordinary call
        to the event name with the appropriate arguments.
        The runtime dispatches the call to all subscribed handlers.
      </p>

      <pre><code>class Counter {
  Value: Int;
  event Changed: (Sender: Counter, Args: ValueChangedEventArgs) -&gt; Unit;

  method Increment() {
    let Old = Value;
    Value = Value + 1;

    let Args: ValueChangedEventArgs;
    Args.OldValue = Old;
    Args.NewValue = Value;

    // Raise the event
    Changed(this, Args);
  }
}</code></pre>

      <ul>
        <li>When an event is raised, all handlers currently subscribed are invoked in
          <strong>subscription order</strong> (the first handler added is called first).</li>
        <li>If there are no handlers, raising the event is a no-op.</li>
        <li>If a handler throws an exception, the default behavior in version 0.1 is:
          <ul>
            <li>Stop invoking subsequent handlers.</li>
            <li>Propagate the exception as if it was thrown directly from the event call site.</li>
          </ul>
        </li>
      </ul>

      <p class="warning">
        This means that one faulty handler can prevent later handlers from running.
        If you need “best effort” semantics (invoke all handlers and collect errors),
        you should wrap the event call in a <code>try</code>/<code>catch</code> block
        and handle exceptions explicitly.
      </p>

      <h3>13.6 Lambdas and Inline Handlers</h3>
      <p>
        Lambdas can be used as inline event handlers as long as their parameter and
        (implicit) return types match the event’s handler type.
      </p>

      <pre><code>var C: Counter;

C.Changed += (Sender: Counter, Args: ValueChangedEventArgs) {
  Print("Inline handler: " + Args.NewValue);
};</code></pre>

      <ul>
        <li>If the return type is omitted in a lambda, it is assumed to be “no return value”,
          which matches handlers that are intended for side effects only.</li>
        <li>Capturing local variables from the enclosing scope in an event handler is allowed;
          lifetime and GC behavior follow the normal closure rules of Aloe.</li>
      </ul>

      <h3>13.7 Events and Lifetime</h3>
      <p>
        Event subscriptions extend the lifetime of captured objects as long as
        the event source is alive and still holds references to the handlers.
      </p>
      <ul>
        <li>For instance, if a long-lived object publishes events and a short-lived object subscribes,
          the subscription may keep the short-lived object alive longer than expected.</li>
        <li>This is the same “event subscription leak” pattern as in other managed languages.</li>
        <li>In Aloe, unsubscribing via <code>-=</code> when the subscriber is no longer needed
          is the recommended pattern.</li>
      </ul>

      <p class="note">
        Future versions of the language may introduce “weak events” or other patterns
        to mitigate subscription leaks.
        Version 0.1 intentionally keeps the model close to C# for familiarity.
      </p>
    </section>

  </main>
</div>
</body>
</html>
