<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, Japanese version)</title>
  <meta name="edit-version" content="4">
  <meta name="edit-date" content="2025-12-02T11:05:00+09:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • Japanese translation + with extension</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span> Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span> Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span> Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span> Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span> Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span> Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span> Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span> Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span> delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span> is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span> Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span> enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span> main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span> Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span> swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span> Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span> Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span> Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span> Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with extension</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, Japanese version)</h1>
    <p class="note">
      This document is a Japanese draft based on the English specification<br>
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>.<br>
      On top of that, it adds an extension to <strong>4.2 with-blocks</strong> for
      <strong>type-based with on class / struct / enum (shortened access to static members / enum constants)</strong>.<br>
      Other than that, the specification is translated as faithfully as possible to the original text.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically typed scripting language aiming for simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and mainly has the following goals:
    </p>
    <ul>
      <li>Easy to read and write for educational purposes and small-scale applications</li>
      <li>Operates both on a C# runtime and in WebAssembly (WASM) environments</li>
      <li>Allows control of I/O and concurrency in a statically typed manner via <code>pipe</code> and <code>filter</code></li>
    </ul>
    <p>Features:</p>
    <ul>
      <li>Static typing
        <ul>
          <li><code>var</code> for type inference</li>
          <li><code>let</code> for explicit type annotations</li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> … value types</li>
          <li><code>class</code> … reference types</li>
        </ul>
      </li>
      <li>GC-based memory management (concrete algorithm is VM-implementation-dependent)</li>
      <li>Do not write <code>= null</code> directly in source code
        <ul>
          <li>Reference types can internally hold null, but it is handled through syntactic sugar via <code>delete</code>.</li>
        </ul>
      </li>
      <li>Dataflow-style design through <code>pipe</code> / <code>filter</code></li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> up to the end of the line is a line comment.</li>
      <li><code>/*</code> to <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assumed not to be supported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code></li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Cannot use the same spelling as a keyword.</li>
      <li>Identifiers starting with <code>_</code> are treated as “private” by convention (not referenced from outside).</li>
      <li>Unicode characters may also be used (excluding whitespace and delimiter characters).</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
null
options
or
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
    <ul>
      <li>Do not use <code>package</code>; use <code>namespace</code> instead.</li>
      <li><code>final</code> has been removed; use <code>sealed</code> to forbid extension.</li>
      <li><code>instanceof</code> has been removed; use <code>is</code> for type checks.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>Floating-point literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>Decimal literals: <code>10.12345678901234567890:d</code>, etc.</li>
      <li>Boolean values: <code>true</code>, <code>false</code></li>
      <li>String: <code>"Hello, World!"</code></li>
      <li>Char: <code>'A'</code>, <code>'z'</code>, etc.</li>
      <li>null literal: <code>null</code></li>
      <li>Array literal: <code>[1, 2, 3]</code></li>
      <li>List literal: <code>(1, 2, 3)</code></li>
      <li>Set literal: <code>{1, 2, 3}</code></li>
      <li>Map literal: <code>["key1": 10, "key2": 20]</code></li>
      <li>enum literal: <code>EnumType.Value1</code></li>
      <li>struct literal: <code>Point { x: 0, y: 1 }</code></li>
      <li>Object creation: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>Every statement is terminated by a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion based on line breaks.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Space, tab, and newline are treated as token separators.</li>
      <li>Consecutive whitespaces are treated as a single separator.</li>
      <li>Indentation has no semantic meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      In Aloe, the “primitive types” are the following seven:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – boolean values.</li>
      <li><code>int</code> / <code>integer</code> – signed integers.</li>
      <li><code>float</code> – floating-point numbers.</li>
      <li><code>decimal</code> – high-precision decimal numbers.</li>
      <li><code>string</code> – strings (internally Unicode).</li>
      <li><code>null</code> – a special type/value representing “no value”.</li>
      <li><code>void</code> – no return value (only for method return types).</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported by the language but are treated as value types
      handled separately in the chapter on numbers and conversions (chapter 3), and
      are excluded from the “primitive types” category.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Asynchronous task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see chapter 18)</li>
    </ul>
    <p>There is no <code>any</code> type; dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implemented as a reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Fields of a struct may only be primitive types or other structs.</li>
      <li>They cannot have fields of reference types such as class.</li>
      <li>Assignment of a struct always performs a value copy.</li>
      <li>The specification does not impose any explicit limit on the maximum size.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>A class can hold structs as fields.</li>
      <li>Assigning a class instance to another variable copies the reference (the object itself is shared).</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> have a <code>float</code> result.
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision decimal number.</li>
      <li>Expressions mixing <code>decimal</code> with <code>int</code> / <code>float</code> may be promoted to <code>decimal</code>, as needed.</li>
      <li>Overflow / underflow / precision issues are handled as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Implicit / explicit conversions between enum and int are both forbidden.</li>
      <li>Expressions mixing enum and numeric types are compile errors (except bitwise operations on bitfield enums).</li>
      <li>Internally, both enum and bitfield enum are represented as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Operations between bytes are allowed, but out-of-range results may cause errors.</li>
          <li>In mixed expressions with int, byte is promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic on char is not allowed.</li>
          <li>Comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are only defined between chars.</li>
          <li>No implicit conversions to numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow / underflow is handled by exceptions rather than NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is always thrown for 0 / 0.0.</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block</li>
      <li>Class definition block</li>
      <li>Method definition block</li>
      <li>Any arbitrary <code>{ ... }</code> block</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadow the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>Declaring a variable with the same name in an inner block shadows the outer variable.</li>
      <li>When a field name and local variable name conflict, the local variable takes precedence.
        The field is referenced via <code>this.</code>.</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks (member access shorthand)</h3>
    <p>
      Aloe provides the <code>with</code> block to write multiple member accesses on the same object more concisely.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside a <code>with (expr) { ... }</code> block:
        <ul>
          <li><code>.Member</code> is a shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated only once at the beginning of the block and stored in an internal temporary variable.</li>
          <li>The special temporary variable <code>_</code> refers to “the with target object”.
            <ul>
              <li>It can be passed as in <code>log(_);</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>An inner <code>with</code> shadows the resolution of <code>.</code> and <code>_</code> of the outer <code>with</code>.</li>
          <li>The outer object can still be accessed by its normal variable name.</li>
        </ul>
      </li>
      <li>Similar to C#’s <code>using</code>-style, multiple <code>with</code> targets can be written in the same block:</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The resolution order for which object’s member is chosen is implementation-dependent.</li>
      <li>However, if ambiguous (multiple objects have the same member), it is a compile error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar; semantically everything may be rewritten into
      explicit <code>obj.member</code> calls before performing type checking and code generation.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enum-constant shortcuts for class / struct / enum)</h4>
    <p>
      In addition to the usual <code>with (expr)</code>, you can use <code>with</code> on a <strong>type name</strong>.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here, <code>TypeName</code> is one of the following:</p>
    <ul>
      <li>A <code>class</code> type</li>
      <li>A <code>struct</code> type</li>
      <li>An <code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>In this case, the <code>with</code> is interpreted as a “type-context with”:</p>
    <ul>
      <li>The expression in <code>()</code> is not evaluated as a value at runtime.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; no instance creation is performed.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>Valid targets for <code>Member</code> are:
                <ul>
                  <li>Static fields</li>
                  <li>Static methods</li>
                  <li>Enum / bitfield enum constants</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The temporary variable <code>_</code> behaves as a pseudo-object representing the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members inside a type-based with is a compile error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even in a type-based <code>with</code>, if there are local variables or outer-scope variables with the same name,
      they take precedence. When you want to explicitly refer to enum constants or static members,
      use <code>TypeName.Member</code> or <code>.Member</code> / <code>_.Member</code>.
    </p>

    <h5>Example: static access on class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
    return 0;
}
</code></pre>

    <h5>Example: enum constant access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      Type-based <code>with</code> can also be mixed with multiple-target syntax:
    </p>
<pre><code>with (user), (Color) {
    .name = "Alice"; // user.name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      The resolution order is also implementation-dependent here, but if ambiguous it must be a compile error.
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The type of a variable is inferred from the expression on the right-hand side.</li>
      <li><code>var x = 1;</code> is always of type <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile error (type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit types)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables cannot be reassigned.</li>
      <li>Type annotations are mandatory for consts.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields (field declarations)</h2>
    <p>Fields of class / struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: inside the constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … normal field.</li>
      <li><code>readonly field</code> … assignable only inside the constructor; read-only afterwards.</li>
      <li>Same meaning for both struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended by <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>struct is a value type.</li>
      <li>Fields are limited to primitive types or other structs (fields of reference types are forbidden).</li>
      <li>Copying a struct always performs value copy.</li>
      <li>Struct inheritance is not supported (<code>sealed struct</code> acts only as a “non-extendable” marker).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li>Use the <code>implements</code> keyword to implement interfaces.</li>
      <li>The <code>is</code> operator can be used to test whether an interface is implemented.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying a trait via with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // method brought in from Trait_A (as long as there is no conflict)
</code></pre>

    <h4>Non-destructive add/remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj is unchanged; obj2 has Trait_A applied
var obj3 = obj2 - Trait_A;     // obj3 is obj2 with Trait_A removed
</code></pre>

    <h4>Alias with as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: only alias; members are not flattened
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define fields/methods with the same name, it is a compile error.</li>
      <li>Applications with aliases such as <code>as a</code> are excluded from conflict detection.</li>
      <li>The handling of conflicts between class body members and trait members will be defined in future versions.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> is equivalent to <code>obj = null</code> at the VM level.</li>
      <li>You cannot write <code>obj = null;</code> directly in source code.</li>
      <li>Reference types can internally hold null, but the type system does not track null state.</li>
      <li>Accessing an object in a null state may cause a <code>NullReferenceException</code>.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks.</li>
      <li>Inheritance relationships are taken into account (Derived is also treated as Base).</li>
      <li>It can also be used for interfaces and traits.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (array / list / set / map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // map&lt;int&gt; is an alias of map&lt;string/int&gt;
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>Internal representation is always int32.</li>
      <li>Changing the underlying type, such as <code>enum&lt;byte&gt;</code> or <code>enum&lt;string&gt;</code>, is not allowed.</li>
      <li>Enum types are also valid targets for type-based with, allowing shortened access to constants like <code>with (Color) { Red; }</code>.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that enum constant.</li>
      <li>In a <code>bitfield enum</code>, usable bits are at most 32 (n is 0–31).</li>
      <li>Even if multiple constants share the same bit, the compiler only emits a warning, not an error.</li>
      <li>The underlying type is always int32; <code>bitfield enum&lt;byte&gt;</code> etc. are compile errors.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (entry point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0; // process exit code
}
</code></pre>
    <ul>
      <li>The entry point of the program.</li>
      <li><code>args</code> is the command-line argument list.</li>
      <li>The <code>main</code> block must always be declared as <code>function main(args: string[]): int</code>,
          and its return value must be specified by a <code>return</code> statement of type <code>int</code>.</li>
      <li>There is no special semantics for the temporary variable <code>_</code> inside the main block (it behaves as a normal temporary variable).</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;   // here it is treated as a normal local variable
    return 0;
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // the type of _ in this block is determined by the first assignment
}
</code></pre>
    <ul>
      <li><code>_</code> is treated as a special temporary variable that can be used without declaration in any block.</li>
      <li>However, it has no special meaning in main and is treated like a normal variable.</li>
      <li>In blocks other than main, the type of <code>_</code> is the type of the expression used in the first assignment within that block.</li>
      <li>Inside a with block, it additionally refers to “the current with target” (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of x and y.</li>
      <li>Whether the swap is valid is checked at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (from highest to lowest)</h3>
    <ol>
      <li>Member access / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiplication / division: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Addition / subtraction: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (different semantics in pipeline statements)</li>
      <li>Logical AND: <code>&amp;&amp;</code> (alias: <code>and</code>)</li>
      <li>Logical OR: <code>||</code> (alias: <code>or</code>)</li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignments (e.g. <code>+=</code>) are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> is used for both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown for division by 0 / 0.0.</li>
      <li>Parsing and formatting errors are represented by <code>FormatException</code>.</li>
      <li>Other fatal VM-level errors are implementation-dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> introduces references to other namespaces / symbols.</li>
      <li>Details such as file layout and handling of circular imports are defined in the module specification.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to construct streaming processing
      for servers / CLI / web applications.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> is a stream of elements of type T.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte stream for standard input or sockets, etc.</li>
      <li><code>pipe&lt;string&gt;</code> … string stream.</li>
      <li>Pipes assume value copying rather than shared memory.</li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3>18.2 Overview of Result&lt;T&gt; and Railway Oriented Programming (ROP)</h3>
    <p>
      In Aloe, error handling and branching in pipelines and filters are handled using
      the <strong>Result&lt;T&gt;</strong> type and the concept of
      <strong>Railway Oriented Programming (ROP)</strong>.
    </p>
    <ul>
      <li><code>Result&lt;T&gt;</code> is a language built-in generic type that represents either “success (Ok)” or “failure (Error)”.</li>
      <li>Filters and future pipeline definitions typically return <code>Result&lt;T&gt;</code>
          to explicitly express success / failure.</li>
    </ul>

    <h4>18.2.1 Conceptual definition of Result&lt;T&gt;</h4>
<pre><code>// Conceptual sketch in pseudo-code (syntax will be finalized later)
Result&lt;T&gt; =
    Ok(value: T)
  | Error(message: string);  // or an error info object
</code></pre>
    <p>
      Actual syntax and the payload on the Error side will be strictly defined
      by the VM/runtime specification and future extensions.
    </p>

    <h4>18.2.2 Image of ROP (Railway Oriented Programming)</h4>
    <p>
      ROP imagines “success tracks” and “failure tracks” running in parallel,
      where each step (filter) returns a <code>Result&lt;T&gt;</code>, and when
      an error occurs, subsequent steps are skipped.
    </p>
<pre><code>Input
  ├─&gt; [ Filter A ] ──&gt; [ Filter B ] ──&gt; [ Filter C ] ──&gt; Output
  │         │               │               │
  │         └─&gt; Error ──────┴───────────────┴───&gt; Error path
  │
  └─&gt; (other branches, logging, etc.)
</code></pre>
    <p>
      Filters in Aloe are designed to limit side effects as much as possible
      and aim for “quasi-idempotence”, i.e., returning the same output for the same input.
    </p>

    <h3>18.3 Basics and definition of filter(...)</h3>
    <p><code>filter(F)</code> represents an intermediate transformation stage in a pipeline.</p>

    <h4>18.3.1 Filter definition (filter definition statement)</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // Type used for options (optional)
    options: LineSplitOptions;

    // Field definitions (optional but recommended minimal for side-effect considerations)
    field _buffer: string = "";

    // Constructor (optional)
    constructor(opts: LineSplitOptions) {
        // Initialize using option values, etc.
    }

    // Main body to pass processing from input pipe to output pipe
    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Ok(); // indicates processing succeeded
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> specify the types of the input/output pipes.</li>
      <li><code>options</code> specifies an option class (usually a <code>bitfield enum</code>, etc.) for this filter.</li>
      <li><code>field</code> can be used to keep internal state in the filter, but from the perspective of ROP,
          it is recommended to minimize stateful side effects to preserve
          “same output for same input” behavior.</li>
      <li><code>constructor</code> can optionally be defined to receive options and external parameters for initialization.</li>
      <li><code>bound(input, output): Result&lt;void&gt;</code> is the main execution body of the filter.
          It can return <code>Ok()</code> on success or <code>Error(...)</code> on failure.</li>
    </ul>

    <h4>18.3.2 Filter options (filter option specification)</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Options are specified after <code>:</code> and combined with <code>|</code>.</li>
      <li>Each filter has its own option type (such as a bitfield enum).</li>
      <li>If the filter definition specifies an option class with
          <code>options: JsonOptions;</code>, then when using this filter in a pipeline,
          you may omit the <code>JsonOptions.</code> prefix and write only the enumeration names:</li>
    </ul>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
    <p>
      The above is equivalent to <code>JsonOptions.PrettyPrint | JsonOptions.IncludeNulls</code>,
      and the compiler verifies that these are members of the option class specified in <code>options</code>.
    </p>

    <h3>18.4 Pipeline statement and <code>|</code> / pipe-with operator <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li>In <code>A | B | C;</code>, the output of A is connected to B, and the output of B to C.</li>
      <li>Type checking verifies the input/output type consistency at each stage.</li>
      <li>The pipeline statement itself does not return a value (it only establishes connections as a side effect).</li>
    </ul>

    <h4>18.4.1 Pipe-with operator <span class="operator">|&gt;</span> (shortcut for filter conditions)</h4>
    <p>
      The operator <span class="operator">|&gt;</span> is defined as a shorthand for conditional filtering
      using <code>filter(if)</code>.
    </p>
<pre><code>// Full syntax
users
    | filter(if : .Age &gt;= 20 and .Gender == Gender.Male);

// Shortcut syntax (equivalent)
users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>
    <ul>
      <li>The right-hand side of <span class="operator">|&gt;</span> uses an implicit context
          representing the current element (similar to <code>.</code> in with) to write a condition.</li>
      <li>In the above example, the filter passes only “users who are at least 20 years old and male”.</li>
      <li>Internally, <span class="operator">|&gt;</span> is expanded into <code>filter(if : ...)</code>,
          so implementation-wise it is enough to implement a single filter for <code>if</code>.</li>
    </ul>

    <h3>18.5 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> internally calls <code>p.next()</code> until EOF.</li>
      <li>Once the writer side calls <code>close()</code>, the reader side detects EOF and terminates the loop.</li>
    </ul>

    <h3>18.6 Element transformation via map</h3>
    <p>
      Applying <code>map</code> to a pipe applies a function (or lambda) to each element,
      producing another stream possibly of a different type.
    </p>
<pre><code>// map with a function
function toName(u: User): string {
    return u.Name;
}

names = users | map(toName);

// Lambda-like syntax (syntax is still draft)
names = users | map (u) =&gt; u.Name;
</code></pre>
    <ul>
      <li><code>map</code> is defined as a built-in higher-order operation.</li>
      <li>The result of <code>map</code> is also a <code>pipe&lt;T&gt;</code>, which can be further connected to other filters.</li>
    </ul>

    <h3>18.7 Template map for collection pipes</h3>
    <p>
      Template syntax can be used for <code>map</code> on collections
      (e.g., <code>User()</code> or <code>User{}</code>).
    </p>
<pre><code>users as u | map Customer {
    Name    = u.Name,
    Address = u.Address
}
</code></pre>
    <ul>
      <li><code>as u</code> introduces an alias for each element.</li>
      <li><code>map Customer { ... }</code> is treated as a template that creates a new
          <code>Customer</code> object and uses field assignments in the block to map values.</li>
      <li>The result is a collection of the same shape as the original (e.g., <code>Customer()</code>).</li>
    </ul>

    <h3>18.8 close and EOF propagation</h3>
    <ul>
      <li>After <code>p.close()</code>, calls to <code>write()</code> are invalid (and may cause errors).</li>
      <li>When a filter detects EOF on its input, it should also call <code>close()</code> on its output.</li>
    </ul>

    <h3>18.9 Concurrency model using pipes</h3>
    <ul>
      <li>The main communication mechanism between tasks is <code>pipe&lt;T&gt;</code>.</li>
      <li>A shared-nothing model is assumed, and designs using shared mutable data structures are discouraged.</li>
    </ul>

    <h3>18.10 Branching pipes with match (branching Result&lt;T&gt;)</h3>
    <p>
      For pipes and filters returning <code>Result&lt;T&gt;</code>,
      you can use <code>match</code> to branch based on the result.
    </p>
<pre><code>stdin
    | filter(parseUser)
    | match {
        case Ok(u):
            // success path
            | filter(saveUser)
            | filter(logSuccess);
        case Error(e):
            // error path
            | filter(logError);
        default:
            // case for non-matching patterns (for future extensions)
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... }</code> branches on the <code>Result&lt;T&gt;</code> output of the previous stage.</li>
      <li>Immediately after <code>case pattern:</code>, you can continue to attach pipelines such as <code>| filter(...)</code>.</li>
      <li><code>default:</code> is optional and represents a fallback when none of the <code>case</code> clauses match.</li>
    </ul>
<pre><code>| match {
    case condition1:
        | filter(handleCase1);
    case condition2:
        | filter(handleCase2);
    default:
        | filter(handleDefault);
}
</code></pre>
    <p>
      The condition part can use <code>is</code> or Result patterns (<code>Ok(...)</code>, <code>Error(...)</code>).
    </p>

    <h3>18.11 Example: simple REST-like pipeline</h3>
<pre><code>class User {
    field id: int;
    field name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    return 0;
}
</code></pre>
    <p class="note">
      <strong>Edit policy memo:</strong><br>
      &middot; This document is based on the English specification, and the content (structure and meaning) of the Japanese and English versions must always match.<br>
      &middot; The <code>edit-version</code> must be shared between the Japanese and English versions, and incremented by +1 only when the content of the Japanese version is changed (it must never decrease).<br>
      &middot; <code>edit-date</code> records the timestamp (year/month/day hour:minute:second) at which each version is output.<br>
      &middot; As a rule, unrelated parts must not be changed. Even if the meaning is the same, do not arbitrarily change wording or variable names.<br>
      &middot; If you feel “this part also should be fixed”, stop editing and consult the user before applying any changes.<br>
      &middot; Always treat the last full HTML output as the “correct” version, and limit the next edit to the minimum diff against that version.<br>
      &middot; If the previous HTML (the last “correct” version) is no longer visible or cannot be reproduced, stop editing and consult the user without making further changes.<br>
    </p>

  </main>
</div>
</body>
</html>
