
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – pipe/filter/producer/consumer + delete/with/lock/class inheritance/generics/event)</title>
  <meta name="last-updated" content="2025-11-30T12:00:00+09:00" />
  <style>
    /* Minimal layout only. Let the browser decide fonts. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / pipe, filter, producer, consumer + delete/with/lock/class inheritance/generics/event</div>
    <div class="updated">Last updated: 2025-11-30 12:00:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#functions-methods">5. Functions and Methods</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operators <code>|</code> and <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers / Consumers</a>

      <div class="section-title">Syntactic Extensions</div>
      <a href="#with">7. with Statement</a>
      <a href="#delete">8. delete Statement</a>
      <a href="#lock">9. lock Statement and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Runtime Model and Memory Management</a>

      <div class="section-title">Events</div>
      <a href="#event">13. event Syntax and Event Model</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Work</a>
    </nav>
  </aside>

  <main class="content">

    <!-- 1. Introduction -->
    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing,
        simple syntax, and a stack-based virtual machine (AloeVM).
        It is especially designed with a focus on <strong>Pipe / Filter style dataflow</strong>
        and interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type-checking is performed at compile time).</li>
        <li>C-like surface syntax with an intentionally small feature set.</li>
        <li>Emphasis on writing “flows and transformations of data” comfortably:
          text processing, REST calls, logging, etc.</li>
        <li>Assumes a stack-based VM (AloeVM) and future WebAssembly backends.</li>
        <li><strong>Functions</strong> are first-class values; they can be stored in variables,
          passed as arguments, and sent through pipes.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft of the language specification</strong>.<br />
        It may differ from actual compiler / VM implementations.
      </p>
    </section>

    <!-- 2. Design Goals -->
    <section id="goals">
      <h2>2. Design Goals</h2>

      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: The spec itself should be readable as documentation.</li>
        <li><strong>Ease of implementation</strong>: A small compiler and VM should suffice.</li>
        <li><strong>Consistency of Pipe / Filter</strong>: Type-safe dataflow representation.</li>
        <li><strong>Bridge to Wasm</strong>: Easy integration with future Wasm component model.</li>
        <li><strong>Small core</strong>:
          A useful Aloe program should be writable <strong>without using</strong>
          <code>delete</code>, <code>with</code>, or <code>lock</code> at all.
          These are positioned as “low-level extensions”.
        </li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Becoming a “do everything” general-purpose language.</li>
        <li>Competing in performance with aggressively optimized JIT compilers.</li>
        <li>Supporting complex metaprogramming (macros, etc.) in this version.</li>
      </ul>

      <p class="note">
        In Aloe, as long as you write code using <strong>pipes as the main abstraction</strong>,
        you avoid directly sharing <code>Pipe&lt;T&gt;</code> between threads, and the type system
        expresses “which thread consumes which pipe”. This makes race conditions easier to avoid.<br />
        Explicit mutexes and <code>lock</code> are assumed to be needed only for lower-level
        performance tuning or integration with legacy APIs.
      </p>
    </section>

    <!-- 3. Basic Syntax -->
    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source File</h3>
      <ul>
        <li>Source files are assumed to be UTF-8 encoded.</li>
        <li>Line comment: <code>// comment</code></li>
        <li>Block comment: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifier: starts with an alphabetic character or <code>_</code>, followed by
          alphanumerics or <code>_</code>.</li>
        <li>Keywords are reserved and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code>, <code>readonly</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code>, <code>delete</code></td>
        </tr>
        <tr>
          <td>Functions</td>
          <td><code>function</code>, <code>method</code></td>
        </tr>
        <tr>
          <td>Additional</td>
          <td><code>with</code>, <code>clone</code>, <code>where</code>, <code>event</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are delimited with <code>{ ... }</code>.</li>
        <li>Conditions in control constructs must be of type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <!-- 4. Type System -->
    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation-defined; assume 32 bits here).</td></tr>
        <tr><td><code>Float</code></td><td>Floating point number (32 or 64 bit, implementation-defined).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-defined).</td></tr>
      </table>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-length array: <code>T[]</code></li>
        <li>Variable-length, lazily evaluated sequences are expressed using <code>Pipe&lt;T&gt;</code>
          (see section 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignments copy the value.</li>
        <li>The copy is shallow; sharing of nested reference-type fields depends on VM implementation.</li>
        <li>A struct may inherit from at most one other struct (single inheritance between structs).</li>
        <li>A struct implementing an <code>interface</code> is <strong>forbidden</strong>.
          (How structs participate in traits and generic constraints will be clarified later.)</li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as an <strong><code>Int</code></strong>.</li>
        <li>“Generic enums” such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code>
          are <strong>forbidden</strong>.</li>
        <li>Bit-field enums are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <!-- 4.5 Classes and Inheritance -->
    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed / Object)</h2>

      <h3>4.5.1 Object and Basic Classes</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignment performs a <strong>reference copy (shallow copy)</strong>.</li>
        <li>All classes implicitly have <code>Object</code> as their ultimate base class.
          Even when another base class is specified, <code>Object</code> sits at the root.</li>
        <li><code>clone</code> creates a shallow copy of an object and returns a new reference.</li>
        <li>All classes are <strong>cloneable</strong>. The language does not provide a way
          to declare a “non-cloneable” class at the type level.</li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;

  method ToString(): String {
    return "User(" + Name + ")";
  }
}

var A: User = NewUser();
var B: User = A;        // reference copy (A and B point to the same instance)

var C: User = clone A;  // shallow-copied new instance</code></pre>

      <p class="note">
        The <strong>Object</strong> class is the common base for all classes, and has at least
        the following virtual methods:
      </p>
      <ul>
        <li><code>method ToString(): String</code> – a short human-readable description.</li>
        <li><code>method Dump(): String</code> – a debugging-oriented structural dump string
          (including field names and nested structure).</li>
      </ul>
      <p class="note">
        The built-in <code>dump</code> consumer (see section 6.5.4) is expected to call
        <code>Dump()</code> on each object and send the result to logs or stdout.<br />
        The exact formatting of the dump is up to library implementations.
      </p>

      <h3>4.5.2 Class Inheritance (Single Inheritance)</h3>
      <p>
        Aloe classes support <strong>single inheritance</strong> only.<br />
        That is, a class may specify exactly one base class (excluding the implicit <code>Object</code>).
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// This is a compile error (no multiple inheritance of classes):
// class Bad : Base, OtherBase {
// }</code></pre>

      <ul>
        <li>Class hierarchies form trees (or chains). Diamond inheritance does not occur.</li>
        <li>Class inheritance is a mechanism to reuse state and behavior.</li>
      </ul>

      <h3>4.5.3 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance of classes, Aloe uses
        <strong>interfaces</strong> and <strong>traits</strong> to compose behavior.
      </p>

      <ul>
        <li><code>interface</code> defines method signatures but no implementations
          (whether default implementations are allowed is TBD).</li>
        <li><code>trait</code> is a mixin unit that can contain method implementations.
          It is used to add behavior to existing classes.</li>
        <li>A class can have <strong>one base class</strong>, implement multiple <code>interface</code>s,
          and apply multiple <code>trait</code>s via <code>with</code>.</li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose();
}

trait Printable {
  method PrintSelf() {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose() {
    // resource cleanup
  }

  method ToString(): String {
    return "FileHandle(...)";
  }

  method Dump(): String {
    return "FileHandle(Detailed...)";
  }
}</code></pre>

      <p class="note">
        Aloe does <strong>not</strong> provide a special syntax (such as extension methods or
        <code>bound TypeName</code>) to add methods to an existing type.<br />
        To add behavior to a type, define a trait and apply it to the type via <code>with</code>.
      </p>

      <h3>4.5.4 sealed Classes</h3>
      <p>
        To forbid inheritance from specific classes, Aloe provides the <code>sealed</code> modifier.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// Compile error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li>A <code>sealed class</code> cannot be used as a base class.</li>
        <li>Even if a class is <code>sealed</code>, it can still implement interfaces
          and apply traits via <code>with</code>.</li>
        <li>In the future, sealed classes combined with unions / pattern matching may support
          exhaustiveness checking.</li>
      </ul>

      <h3>4.5.5 readonly and Classes</h3>
      <ul>
        <li>By default, fields in a class are mutable.</li>
        <li>A field marked <code>readonly</code> is immutable:
          <ul>
            <li>Assignments to it are allowed only in <strong>field initializers</strong> and
              <strong>constructors of the same class</strong>.</li>
            <li>Assignments from anywhere else are compile errors.</li>
          </ul>
        </li>
        <li><code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are implicitly treated as if they were marked <code>readonly</code>.</li>
            <li>Assignments to fields are allowed only in field initializers and constructors of that class.</li>
            <li>After the constructor finishes, code cannot modify any fields of that instance.</li>
          </ul>
        </li>
        <li><code>readonly</code> and <code>clone</code> are orthogonal:
          even a <code>readonly class</code> can be cloned.
          The clone result is a separate instance with the same immutable state.</li>
      </ul>

      <p class="small">
        This section defines the high-level policy that classes are heap reference types with single inheritance,
        multiple behaviors are composed via interface + trait, sealed expresses “no further inheritance”,
        and <code>readonly</code> expresses field-level or class-level immutability.<br />
        Details such as method resolution order and trait conflict resolution will be specified elsewhere.
      </p>
    </section>

    <!-- 4.6 Generics -->
    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, functions, methods,
        and pipe-related declarations.<br />
        The goal is to make collections and Pipe / Filter components reusable and type-safe,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

function Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // implementation omitted
}</code></pre>

      <h3>4.6.2 Generic Type Parameters</h3>
      <ul>
        <li><code>type</code>, <code>struct</code>, <code>class</code>, <code>interface</code>, <code>trait</code>,
          <code>function</code>, <code>method</code>, and producer/filter/consumer declarations
          may all take type parameters using <code>&lt;T, U, ...&gt;</code>.</li>
        <li>Type parameter names are recommended to start with uppercase
          (<code>T</code>, <code>TItem</code>, <code>TKey</code>, etc.).</li>
        <li>Type arguments are bound to concrete types at usage sites.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

function FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // implementation omitted
}</code></pre>

      <h3>4.6.3 where Type Constraints (Overview)</h3>
      <p>
        Aloe generics support arbitrary type constraints using <code>where</code> clauses.<br />
        By default there is no constraint, but version 0.1 supports several basic forms.
      </p>

      <pre><code>function Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int-only sum
}</code></pre>

      <p class="note">
        Here, <code>where</code> exists purely for <strong>compile-time type-checking</strong>.<br />
        The runtime representation (monomorphization vs shared code with type tags, etc.)
        is left to the VM specification.
      </p>

      <h3>4.6.4 Supported Kinds of Constraints</h3>
      <p>Version 0.1 supports the following constraint categories:</p>
      <ul>
        <li><strong>Value type / reference type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive type constraints</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>, etc.,
              specifying primitive type names directly.</li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – types that implement trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – <code>T</code> must be exactly struct <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – <code>T</code> must be exactly class <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Arbitrary concrete types</strong>
          <ul>
            <li>Any existing concrete type name may be used (e.g. <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Generic restricted to value types
function Zero&lt;T&gt;(): T
  where T: struct
{
  // implementation omitted
}

// Int-only pipe
function Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // implementation omitted
}

// Specific struct-only
function PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior on Constraint Violations</h3>
      <ul>
        <li>If a type argument given to a generic function/type does not satisfy the
          <code>where</code> constraints, it is a compile-time error.</li>
        <li>If multiple constraints are specified, all of them must be satisfied.</li>
        <li>Cyclic constraints and advanced typeclass-style relationships are not supported in this version.</li>
      </ul>

      <pre><code>// Example of a compile error:

// where T: Int, so T cannot be String
function Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization vs shared code with type tags, etc.)
        is defined by AloeVM.<br />
        This language spec focuses on type-safe reuse and behavior of <code>where</code>-based constraints.
      </p>
    </section>

    <!-- 5. Functions and Methods -->
    <section id="functions-methods">
      <h2>5. Functions and Methods</h2>

      <h3>5.1 function Declarations (Top-level Functions)</h3>
      <p>
        In Aloe, <strong>functions</strong> are first-class values.
        A function is declared with the <code>function</code> keyword, and can be stored in variables,
        passed as arguments, or sent through pipes.
      </p>

      <pre><code>function Add(a: Int, b: Int): Int {
  let Sum: Int = a + b;
  return Sum;
}</code></pre>

      <ul>
        <li><code>function</code> declares a “top-level function”.</li>
        <li>The parameter list and return type follow the same rules as <code>method</code>.</li>
        <li>The function body consists of multiple statements and may contain at most
          <strong>one</strong> <code>return</code> statement.</li>
        <li>The type of the <code>return</code> expression must match the declared return type.</li>
        <li>If the return type is omitted, the function is treated as void-like:
          <ul>
            <li>A single <code>return;</code> without a value is allowed.</li>
            <li>Reaching the end of the function body without <code>return</code> is also allowed.</li>
          </ul>
        </li>
        <li>At the VM level, <code>function</code> and <code>method</code> share the same calling convention
          and representation; they differ only in whether they receive an implicit <code>this</code>.</li>
      </ul>

      <h3>5.2 method Declarations (Methods Belonging to a Type)</h3>
      <p>
        <code>method</code> declares a method that belongs to a particular type
        (struct / class / interface / trait). It cannot be used at the top level;
        <code>function</code> should be used there instead.
      </p>

      <pre><code>class Calculator {
  method Add(a: Int, b: Int): Int {
    return a + b;
  }
}</code></pre>

      <ul>
        <li>A <code>method</code> declared inside a <code>struct</code>, <code>class</code>,
          <code>interface</code>, or <code>trait</code> is treated as a member of that type.</li>
        <li>If the return type is omitted, the method is treated as void.</li>
        <li>Rules about the body, number of <code>return</code> statements, and matching
          return type are the same as for <code>function</code>.</li>
        <li>Within the type, an implicit receiver (informally referred to here as <code>this</code>)
          is available, but its concrete spelling is left to AloeVM / tooling.</li>
      </ul>

      <div class="note">
        <strong>How to add methods to an existing type:</strong><br />
        Aloe does not provide extension methods or special syntaxes such as
        <code>bound TypeName { ... }</code>.<br />
        To add behavior to an existing type, define a trait and put the <code>method</code>s
        inside that trait, then apply it via <code>with TraitName</code> on the type.<br />
        “Adding methods to a type” is always done through traits.
      </div>

      <h3>5.3 Function Type Representation (Func&lt;...:...&gt;)</h3>
      <p>
        Aloe represents function types using the <code>Func&lt;...:...&gt;</code> notation.
        Function type syntax using <code>-</code> plus some arrow is not part of the language spec.
      </p>
      <ul>
        <li><code>Func&lt;T:U&gt;</code> means “a function taking <code>T</code> and returning <code>U</code>”.</li>
        <li><code>Func&lt;A, B:R&gt;</code> means “a function taking <code>A</code> and <code>B</code>
          and returning <code>R</code>”.</li>
        <li>A void-returning function is written as <code>Func&lt;T:&gt;</code> or <code>Func&lt;T:void&gt;</code>.</li>
        <li>Everything appearing on the right-hand side of the pipe operator <code>|</code> is essentially
          such a function type; <code>|</code> is just syntactic sugar to connect them.</li>
      </ul>

      <h3>5.4 main Function (Entry Point)</h3>
      <p>
        The program entry point in Aloe is a <strong>top-level <code>function main</code></strong>.
      </p>

      <pre><code>function main(): Int {
  // Program entry point
  return 0;
}</code></pre>

      <ul>
        <li><code>main</code> follows the same rules as other <code>function</code>s.</li>
        <li>The body consists of multiple statements and may contain at most one <code>return</code>.</li>
        <li>The return expression type must match the declared return type.</li>
        <li>From the language’s perspective, <code>main</code> is “just one of many top-level functions”
          with the additional property of being the entry point.</li>
        <li>Whether the return type is fixed to <code>Int</code> or also allows void, and the exact ABI,
          are left to the VM / platform specification.</li>
      </ul>
    </section>

    <!-- 6. Pipe / Filter Model -->
    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is its ability to express
        <strong>Pipe / Filter style dataflow</strong> in a type-safe and consistent way.
      </p>

      <pre><code>ReadLines("access.log")
  | Where (.StartsWith("[ERROR]"))
  | Map   (ParseLogLine)
  | Where (.Level == LogLevel.Error)
  | ToArray();</code></pre>

      <p>
        Conceptually, the above is equivalent to the following nested calls:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>
        The Aloe <code>|</code> operator is syntactic sugar for such function composition.
      </p>

      <!-- 6.1 Pipe<T> -->
      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe and corresponds to
          lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents “a pipe that carries elements of type <code>T</code>”.</li>
          <li>Its internal representation (chained iterators, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers / transformers / consumers using <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // Internal fields are implementation-dependent
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the domain of values of type <code>Pipe&lt;T&gt;</code> and
          functions that accept or return them (producers / transformers / consumers).<br />
          Consumers are the exit from this world.
        </p>
      </section>

      <!-- 6.2 Roles -->
      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, we classify functions and objects into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>:
            A function/object whose return type is <code>Pipe&lt;*&gt;</code> and that appears at the head
            of the pipeline.</li>
          <li><strong>Role</strong>:
            Read data from the external world (files, HTTP, arrays, etc.) and
            feed it into the pipe world (<code>Pipe&lt;T&gt;</code>).</li>
          <li><strong>Types</strong>:
            Typically has type <code>Func&lt;X:Pipe&lt;T&gt;&gt;</code>.
            A producer is always designed to output some <code>Pipe&lt;*&gt;</code>.</li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filters)</h4>
        <ul>
          <li><strong>Definition</strong>:
            Functions/methods of type <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>.</li>
          <li><strong>Role</strong>:
            Transform/filter/sort data within the pipe world. They do not exit the pipe world.</li>
        </ul>

        <p>
          The Pipe / Filter library is mainly provided via
          <strong><code>filter</code> declarations</strong>
          and <strong><code>pipe</code> declarations</strong> as transformers.
          If needed, traits can be used to add method-style APIs to <code>Pipe&lt;T&gt;</code>,
          but the language spec centers on pipe-related declarations.
        </p>

        <h4>6.2.3 Consumer (Terminal Filters)</h4>

        <ul>
          <li><strong>Definition</strong>:
            Functions/objects of type <code>Func&lt;Pipe&lt;T&gt;:R&gt;</code>, where <code>R</code>
            is not <code>Pipe&lt;*&gt;</code>.</li>
          <li><strong>Role</strong>:
            Exit from the pipe world: consume the pipe completely and convert it to an array,
            scalar, external I/O, etc.</li>
          <li><strong>Return type</strong>:
            <code>R</code> may be any type as long as it is not <code>Pipe&lt;*&gt;</code>:
            <code>T[]</code>, <code>Int</code>, <code>Unit</code>, <code>Bool</code>, etc.</li>
        </ul>

        <pre><code>// Consumer that materializes a pipe into an array
function ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer that counts elements
function Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>
      </section>

      <!-- 6.3 Pipe-related Declarations -->
      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms to build Pipe / Filter components:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of these are treated as “objects with constructors”, and their <code>bound</code> blocks
          run when the component is connected into a pipeline.
        </p>

        <h4>6.3.1 producer Declarations</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when the producer is connected into a pipeline
    // Read from external resources and write to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the name of the producer.</li>
          <li><code>out</code> specifies the output type in the pipe world.
            It must be a <code>Pipe&lt;*&gt;</code> type.</li>
          <li><code>bound(output)</code> defines behavior when the producer is connected.
            <code>output</code> has the type specified by <code>out</code> (e.g. <code>Pipe&lt;T&gt;</code>).</li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are visible inside the <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudocode:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe Declarations</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connect pipes and perform transfer/transformation
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the pipe name.</li>
          <li><code>in</code> is the type flowing in from upstream.</li>
          <li><code>out</code> is the type flowing downstream.</li>
          <li><code>bound(input, output)</code> describes transformation from <code>input</code> to
            <code>output</code>.</li>
        </ul>

        <p class="note">
          pipe declarations are mainly for bridging external resources such as sockets/HTTP and
          for bridging heterogeneous stream types (text → JSON, etc.).
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // decoded object

  bound(input, output) {
    // Pseudocode:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter Declarations</h4>

        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudocode:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudocode:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer Declarations</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Runs at the end of the pipeline
    // Consumes the input and returns some value
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the consumer name.</li>
          <li><code>in</code> specifies the input type.
            In the Pipe / Filter model, this is typically <strong><code>Pipe&lt;T&gt;</code></strong>.</li>
          <li><code>bound(input)</code> runs at the pipeline end, fully consumes <code>input</code>,
            and returns a value of some type <code>R</code>.</li>
          <li><code>R</code> may be any type (e.g. <code>T[]</code>, <code>Int</code>, <code>Bool</code>, <code>Unit</code>)
            but must <strong>not be <code>Pipe&lt;*&gt;</code></strong>.</li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudocode:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudocode:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, the roles of pipe-related declarations are:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code>
              (always outputs a <code>Pipe</code>)</li>
            <li><strong>pipe</strong>: bridge between heterogeneous streams and external I/O</li>
            <li><strong>filter</strong>: mainly <code>Pipe&lt;T&gt;</code> → <code>Pipe&lt;U&gt;</code> transforms</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → non-<code>Pipe</code> type (exit from pipe world)</li>
          </ul>
        </p>
      </section>

      <!-- 6.4 Pipe Operators -->
      <section id="pipe-operator">
        <h3>6.4 Pipe Operators <code>|</code> and <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition (<code>|</code>)</h4>
        <p>
          The only operator that has pipe semantics at the language level is <strong><code>|</code></strong>.<br />
          <code>|</code> is defined as syntactic sugar for <strong>simple function composition</strong>.
        </p>

        <pre><code>Expr | F | G</code></pre>

        <p>is precisely equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>Func&lt;A:B&gt;</code> and <code>G</code> has type
            <code>Func&lt;B:C&gt;</code>, then <code>Expr | F | G</code> has type <code>C</code>.</li>
          <li>This operator can be used with any types; it is not limited to <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Thus, from the type system’s perspective,
          “the return type changes in the middle of a pipeline” is not a problem in itself.<br />
          Constraints in the Pipe / Filter model are provided by
          <strong><code>Pipe&lt;T&gt;</code> and the library design of pipe-related declarations</strong>,
          not by the operator.
        </div>

        <h4>6.4.2 Relationship of <code>|&gt;</code> and <code>| with</code></h4>
        <p>
          <strong><code>|&gt;</code> is reserved as sugar for inserting a <code>with</code> block into a pipeline.</strong>
        </p>

        <p>Semantically, the language intends the following correspondence in the future:</p>

        <pre><code>Expr |&gt; X</code></pre>

        <p>is roughly equivalent to:</p>

        <pre><code>Expr | with X</code></pre>

        <p>
          The precise syntax of <code>with</code> in this pipeline context is described in section 7.
        </p>

        <p class="note">
          In this draft, concrete syntax and style around <code>| with</code> and <code>|&gt;</code>
          are deliberately left open.<br />
          The only promise is:
          <strong>“The only true pipe operator is <code>|</code>,
          and <code>|&gt;</code> is reserved as sugar to attach <code>with</code> to a pipeline.”</strong><br />
          Specific use cases and syntax will be refined in future versions.
        </p>

        <h4>6.4.3 Using Pipe&lt;T&gt; with <code>|</code></h4>

        <pre><code>ReadLines("users.json")
  | Where (.Trim().Length &gt; 0)
  | Map   (ParseUser)
  | Where (.IsActive)
  | ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>Func&lt;String:Pipe&lt;String&gt;&gt;</code>)</li>
          <li><code>Where</code>, <code>Map</code>: transformers
            (<code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>)</li>
          <li><code>ToArray</code>: consumer (<code>Func&lt;Pipe&lt;User&gt;:User[]&gt;</code>)</li>
          <li>The overall type of the pipeline is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          From the language’s point of view, it is allowed to chain more <code>|</code> after a consumer,
          but stylistically this is discouraged.<br />
          For example, patterns like <code>ToArray() | ToArray()</code> should be avoided.
        </p>
      </section>

      <!-- 6.5 Standard Filters / Producers / Consumers -->
      <section id="pipe-std">
        <h3>6.5 Standard Filters and Producers / Consumers</h3>

        <h4>6.5.1 Representative Transformers (filter)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Representative Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Representative Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns Int
}</code></pre>

        <h4>6.5.4 Built-in dump Consumer</h4>
        <p>
          Aloe provides a built-in <strong><code>dump</code> consumer</strong> for debugging.
        </p>

        <pre><code>ReadLines("users.json")
  | Map   (ParseUser)
  | Where (.IsActive)
  | dump;</code></pre>

        <ul>
          <li><code>dump</code> is defined as a <code>consumer</code> that consumes a <code>Pipe&lt;T&gt;</code> completely.</li>
          <li>For each element <code>x</code>, if <code>x</code> is a reference type,
            <code>Object.Dump()</code> is called and the result is sent to logs or stdout.</li>
          <li>For collections or trees, it is expected to recursively call <code>Dump()</code>
            on elements and children.</li>
        </ul>

        <p class="note">
          <strong>Cyclic reference detection rules:</strong><br />
          <ul>
            <li>The dump implementation must treat revisiting the same object as “cycle detected”
              and skip dumping any deeper than that node.</li>
            <li>For tree structures, subtrees under the node where a cycle is detected are omitted.</li>
            <li>For collections, if a cycle is detected for a particular element,
              dumping that element is cut off with a “truncated here” style,
              but <strong>dumping continues for subsequent elements in the collection</strong>.</li>
          </ul>
          This allows dumping self-referential object graphs without infinite loops or stack overflows,
          while still providing as much information as possible.
        </p>

        <h4>6.5.5 Example Usage</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    | Where (.Trim().Length &gt; 0)
    | Map   (ParseUser)
    | Where (.IsActive)
    | Map   (.Name)
    | ToArray();</code></pre>
      </section>
    </section>

    <!-- 7. with -->
    <section id="with">
      <h2>7. with Statement</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> statement is syntactic sugar for repeating property assignments
        and method calls on the same target object.<br />
        In Aloe it also serves as a <strong>“lifetime lock”</strong> that keeps the target
        object alive during the block.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The above <code>with</code> block is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> evaluates <code>Expr</code> <strong>exactly once</strong>.</li>
        <li>Within the block, simple assignments to bare identifiers are interpreted
          as member accesses on the target object.</li>
      </ul>

      <h3>7.3 Lifetime Lock (GC Root Behavior)</h3>
      <p>
        AloeVM is envisioned to use a combination of reference counting and sliding compaction.<br />
        In this model, a <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The result of <code>with (Expr)</code> is stored in a hidden GC-root variable.</li>
        <li>The hidden variable keeps the object alive until the block is exited.</li>
        <li>Thus, the object is guaranteed to be alive during execution of the block.</li>
      </ul>

      <h3>7.4 Relationship Between with and delete</h3>
      <ul>
        <li>It is a compile error to use <code>delete</code> on the same variable that is the
          <code>with</code> target inside that <code>with</code> block.</li>
        <li>The reason is that <code>with</code> expresses the intent “this object should stay alive here”,
          which conflicts with <code>delete</code>.</li>
        <li>However, using <code>delete</code> on a <em>different variable</em> that happens to refer to
          the same object is allowed.
          Because the GC root from <code>with</code> remains, the object itself stays alive.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is protected by with and is guaranteed to be alive in this block.

  delete Alias;   // OK: removes reference from Alias only
  Url = "https://example.com/api";  // still usable
}

// After the with block, the GC root is released.
// If no references remain, the object may eventually be freed.</code></pre>

      <p class="note">
        In short, <code>with</code> is both
        <strong>syntactic sugar for member access</strong> and
        a <strong>mechanism for temporarily keeping the target object as a GC root</strong>.<br />
        When used together with <code>lock</code>, see section 9.3’s <code>lock with</code> syntax.
      </p>
    </section>

    <!-- 8. delete -->
    <section id="delete">
      <h2>8. delete Statement</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> does <strong>not</strong> directly destroy an object.<br />
        Instead, it is a construct for <strong>removing a reference from a variable</strong>.
      </p>
      <ul>
        <li>Actual destruction of objects (memory release, finalizers, etc.) is performed by
          the runtime (AloeVM), which uses <strong>reference counting + GC</strong>.</li>
        <li><code>delete</code> is meant to express “this variable will no longer point to that object”
          in a type-safe way, as an alternative to assigning <code>null</code>.</li>
      </ul>

      <h3>8.2 Grammar</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile-time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After <code>delete</code>, it is a compile error to read from the variable,
          or to access members or call methods on it.</strong></li>
        <li>However, assigning a new value to that variable is allowed:
          conceptually, <code>delete</code> returns the variable to an “uninitialized” state.</li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// use Buf
DoSomething(Buf);

delete Buf;

// After this, reading Buf or Buf.Length is a compile error

Buf = NewBuffer();  // after reassignment, it can be used again</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> executes, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>Decrement the reference count to the object currently held by <code>Var</code>
          (assuming reference counting).</li>
        <li>Mark <code>Var</code> itself as “uninitialized/deleted”.</li>
        <li>When the object’s reference count reaches 0, it will be freed at the GC’s discretion.<br />
          <strong>In other words, the object is not guaranteed to be destroyed at the exact moment
          <code>delete</code> is executed.</strong></li>
      </ul>

      <p class="note">
        This spec leaves the exact timing of object destruction to the VM/runtime.<br />
        <code>delete</code> only removes one variable’s reference to the object.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>As stated in section 7.4, using <code>delete</code> on the <code>with</code> target variable
          within the <code>with</code> block is a compile error.</li>
        <li>Using <code>delete</code> on another variable that happens to refer to the same object is allowed,
          because the <code>with</code> GC root keeps the object alive.</li>
      </ul>

      <p class="note">
        In the future, Aloe might introduce “ownership-aware resource types” and integrate
        <code>delete</code> with that model.<br />
        In this draft, we assume <strong>no ownership model</strong>.
      </p>
    </section>

    <!-- 9. lock -->
    <section id="lock">
      <h2>9. lock Statement and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> statement acquires a lock on a specific object and guarantees
        exclusive access and optimized read barriers for that object during the block.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> acquires a lock on the object represented by
          <code>Expr</code>, guaranteeing exclusive access to it inside the <code>Body</code> block.</li>
        <li>Lock acquisition and release are implemented by the VM.</li>
        <li>Updates to data shared between threads should generally be confined within <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM is assumed to use sliding compaction for memory management.<br />
        Inside a <code>lock</code> block, the VM can optimize read barriers and reduce
        per-object checks as much as possible.
      </p>

      <h3>9.3 lock with (Combined lock + with)</h3>
      <p>
        To simultaneously apply an exclusive lock and a lifetime lock to the same object,
        Aloe provides the <code>lock with</code> syntax.
      </p>

      <pre><code>lock with (Conn) {
  // Here:
  //   - Conn is protected by an exclusive lock.
  //   - Conn is kept alive as a GC root by with.
  //   - Conn's members can be accessed without writing Conn repeatedly.
}</code></pre>

      <h4>9.3.1 Grammar</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <p>
        <code>lock with (Expr) { Body }</code> is a compound construct that evaluates
        <code>Expr</code> once and treats the result as the target of both <code>lock</code>
        and <code>with</code>.
      </p>

      <h4>9.3.2 Desugaring (Semantic Equivalent Code)</h4>
      <p>
        <code>lock with (Expr) { Body }</code> is semantically equivalent to:
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> is evaluated exactly once and its result is bound to a temporary
          variable <code>__tmp</code>.</li>
        <li><code>lock</code> and <code>with</code> are applied in a nested manner to <code>__tmp</code>.</li>
        <li>Thus, while executing <code>Body</code>:
          <ul>
            <li>Exclusive access to the target is guaranteed (<code>lock</code> semantics).</li>
            <li>The target is kept alive as a GC root (<code>with</code> semantics).</li>
            <li>Members of the target can be accessed concisely via <code>with</code>.</li>
          </ul>
        </li>
      </ul>

      <h4>9.3.3 Style and Restrictions</h4>
      <ul>
        <li><code>lock with</code> expresses “operate on a resource within a range where it is
          both exclusively locked and kept alive” in a single construct.</li>
        <li>Alternative spellings such as <code>with lock (Expr)</code> or <code>lock &amp; with (Expr)</code>
          are not defined. Only <code>lock with</code> is used for this purpose.</li>
        <li>Behavior inside a <code>lock with</code> block is interpreted as the combination of
          <code>lock</code> (section 9.2) and <code>with</code> (section 7.3).</li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// After this point, the lock is released and the with lifetime lock ends as well.</code></pre>
    </section>

    <!-- 10. Exceptions -->
    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside the <code>try</code> block can be caught by the corresponding
          <code>catch</code>.</li>
        <li>The <code>finally</code> block always runs regardless of whether an exception is thrown.</li>
        <li>The details of the exception types and their hierarchy are defined by the VM specification.</li>
      </ul>
    </section>

    <!-- 11. Runtime Model -->
    <section id="runtime">
      <h2>11. Runtime Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode VM.</li>
        <li>Function calls push frames onto a call stack.</li>
        <li>GC is assumed to be reference counting + sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>GC executes under certain conditions to compact memory by sliding live objects.</li>
        <li><code>with</code> acts as a temporary GC root that keeps the object alive,
          and combined with <code>lock</code> can allow read-barrier optimizations.</li>
        <li>Usually, there is no need to call <code>delete</code> just for memory management.
          Use <code>delete</code> only when you want to explicitly drop a reference.</li>
        <li>Many parts of application code are expected to be safely written without using
          <code>delete</code>, <code>with</code>, or <code>lock</code> directly, using pipes and
          immutable data structures instead.</li>
      </ul>

      <p class="small">
        Detailed opcode lists and GC implementation details are provided in the AloeVM specification.
      </p>
    </section>

    <!-- 12. Limitations -->
    <section id="limits">
      <h2>12. Limitations and Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>Generics are minimal; typeclasses and higher-kinded generics are not defined.</li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined in this version.</li>
      </ul>

      <h3>12.2 Future Work</h3>
      <ul>
        <li>Parallelization and fusion optimizations of Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Introducing Result-like types alongside exceptions for error handling.</li>
        <li>Extending standard libraries for distributed and streaming workloads.</li>
        <li>Integrating <code>delete</code> with ownership-aware resource types, if introduced.</li>
        <li>Integrating traits / interfaces / sealed / readonly with pattern matching and
          exhaustiveness checking.</li>
        <li>Concrete design of safe concurrency / parallelism based on functions and pipes.</li>
      </ul>

      <p class="note">
        This draft focuses particularly on:<br />
        <strong>The relationship between Pipe / Filter and Producer / Transformer / Consumer /
        pipe / consumer declarations</strong>, and<br />
        <strong>The relationship between with / delete / lock / class inheritance / readonly / clone /
        generics and the AloeVM memory model</strong>.<br />
        Functions, events, Dump/dump, and other surrounding features will be expanded gradually
        as long as they do not break the core model.
      </p>
    </section>

    <!-- 13. event -->
    <section id="event">
      <h2>13. event Syntax and Event Model</h2>

      <h3>13.1 Purpose and Positioning</h3>
      <p>
        The <code>event</code> syntax in Aloe expresses, at the language level, that
        “this is a notification point where external code may register handlers”.
      </p>
      <ul>
        <li>External code can register and unregister handlers (callbacks) for the event.</li>
        <li>Firing the event (executing notifications) is, in principle, allowed only by
          the code that declares the event.</li>
      </ul>
      <p>
        At the implementation level, <code>event</code> is treated as syntactic sugar for
        the standard library type <code>Event&lt;TArgs&gt;</code>.
      </p>
      <ul>
        <li><code>event Clicked&lt;ClickedArgs&gt;;</code> is equivalent to having a field of type
          <code>Event&lt;ClickedArgs&gt;</code>.</li>
        <li>Unlike normal fields, external code cannot reassign the event field or directly
          call <code>Raise</code> on it (these are compile errors).</li>
      </ul>

      <h3>13.2 Event&lt;TArgs&gt; and Handler Type</h3>

      <h4>13.2.1 Handler Type</h4>
      <p>
        Event handler function types are defined as a standard type alias:
      </p>
      <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>
      <ul>
        <li>Argument: <code>TArgs</code> (type of event arguments).</li>
        <li>Return: <code>Task</code><br />
          To naturally support asynchronous handlers, event handlers are modeled as functions
          that return a <code>Task</code> representing their completion.</li>
      </ul>
      <p class="note">
        In the future, variants such as <code>Event&lt;TArgs, TResult&gt;</code> for
        <code>Func&lt;TArgs:Task&lt;TResult&gt;&gt;</code> could be considered,
        but version 0.1 uses <code>Task</code> as the basic return type.
      </p>

      <h4>13.2.2 Role of Event&lt;TArgs&gt; (Conceptual)</h4>
      <p>
        <code>Event&lt;TArgs&gt;</code> is a type that holds a set of event handlers and
        the logic for invoking them.
      </p>
      <pre><code>type Event&lt;TArgs&gt; {
  Handlers: List&lt;EventHandler&lt;TArgs&gt;&gt;;

  method Add(Handler: EventHandler&lt;TArgs&gt;): Task {
    Handlers.Add(Handler);
  }

  method Remove(Handler: EventHandler&lt;TArgs&gt;): Task {
    // Details of equality for handlers are VM/runtime-defined
    Handlers.Remove(Handler);
  }

  method Raise(Args: TArgs): Task {
    // Await all handlers in order, then return a Task that completes afterwards
    foreach (H in Handlers) {
      await H(Args);
    }
  }
}</code></pre>
      <p class="note">
        From the language spec viewpoint,
        <code>Event&lt;TArgs&gt;</code> is the actual “event collection” type,
        and the <code>event</code> syntax is sugar and access rules around its field declaration.
      </p>

      <h3>13.3 event Declaration Grammar</h3>

      <h4>13.3.1 Declaration Sites</h4>
      <p><code>event</code> may be declared in:</p>
      <ul>
        <li><code>struct</code> bodies</li>
        <li><code>class</code> bodies</li>
        <li><code>interface</code> bodies</li>
      </ul>
      <p>
        In version 0.1, <code>event</code> is not defined at the top level or inside <code>trait</code>s.
      </p>

      <h4>13.3.2 Grammar (Overview)</h4>
      <pre><code>EventDeclaration ::=
    'event' Identifier '&lt;' Type '&gt;' ';'</code></pre>
      <p>Example:</p>
      <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        Semantically, this is equivalent to the following field:
      </p>
      <pre><code>struct Button {
  private Clicked: Event&lt;ClickedArgs&gt;;
}</code></pre>
      <p>But with additional constraints:</p>
      <ul>
        <li>External code cannot reassign <code>Clicked</code> (this is a compile error).</li>
        <li>External code cannot directly call <code>Clicked.Raise(...)</code>.</li>
        <li>External code cannot <code>delete Clicked;</code>.</li>
      </ul>

      <h3>13.4 Subscription / Unsubscription Syntax (<code>+=</code> / <code>-=</code>)</h3>

      <h4>13.4.1 Grammar</h4>
      <pre><code>EventAddStatement    ::= PrimaryExpression '.' Identifier '+=' EventHandlerExpression ';'
EventRemoveStatement ::= PrimaryExpression '.' Identifier '-=' EventHandlerExpression ';'</code></pre>
      <ul>
        <li><code>PrimaryExpression.Identifier</code> must be a member declared with <code>event</code>.</li>
        <li><code>EventHandlerExpression</code> must be implicitly convertible to
          <code>Func&lt;TArgs:Task&gt;</code>.</li>
      </ul>

      <h4>13.4.2 Type Rules</h4>
      <p>
        When <code>event X&lt;TArgs&gt;;</code> is declared:
      </p>
      <ul>
        <li>The type of <code>Target.X</code> is <code>Event&lt;TArgs&gt;</code>.</li>
        <li><code>Target.X += H;</code> is allowed only if the type of <code>H</code> is
          <code>Func&lt;TArgs:Task&gt;</code> (or implicitly convertible to it).</li>
        <li>The same applies to <code>Target.X -= H;</code>.</li>
      </ul>

      <h4>13.4.3 Desugaring (Semantic Equivalent)</h4>
      <p>Semantically, the following equivalences hold:</p>
      <pre><code>Target.X += H;
// means:
await Target.X.Add(H);</code></pre>
      <pre><code>Target.X -= H;
// means:
await Target.X.Remove(H);</code></pre>
      <p class="note">
        Having <code>Add</code> / <code>Remove</code> return <code>Task</code> allows <code>+=</code> /
        <code>-=</code> operations to be treated as asynchronous statements.
        In future versions, fire-and-forget variations may be considered if needed.
      </p>

      <h3>13.5 Rules for Raising Events</h3>

      <h4>13.5.1 Only Definition Side May Raise</h4>
      <p>
        Calls to <code>Raise</code> on an <code>event</code>-declared member are allowed only from:
      </p>
      <ul>
        <li>Methods of the <code>struct</code> / <code>class</code> that declares the event.</li>
        <li>Methods of traits applied to the same type via <code>with</code>.</li>
      </ul>
      <p>
        Calls such as <code>Clicked.Raise(...)</code> from other code (external modules or other classes)
        are compile errors.
      </p>
      <p class="note">
        This ensures that “only the side that declares the event has the authority to fire it”,
        enforcing separation of responsibilities.
      </p>

      <h4>13.5.2 Basic Firing Pattern</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;

  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>

      <h3>13.6 Events in Interfaces and Implementations</h3>
      <p><code>interface</code> may also declare <code>event</code>s.</p>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

interface IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        In this case, any <code>struct</code> / <code>class</code> implementing <code>IButton</code>
        must declare the corresponding <code>event</code>.
      </p>
      <pre><code>struct Button implements IButton {
  event Clicked&lt;ClickedArgs&gt;;

  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>
      <ul>
        <li>If the event name <code>Clicked</code> does not match the interface declaration, or</li>
        <li>If the type argument <code>ClickedArgs</code> is different,</li>
      </ul>
      <p>then the implementation is incomplete and a compile error is issued.</p>

      <h3>13.7 Usage Examples</h3>

      <h4>13.7.1 Button and Clicked Event</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;

  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}

function SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  // Register async handler
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  // Register another handler
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Log("button clicked");
  };
}</code></pre>

      <h4>13.7.2 Unsubscribing Events</h4>
      <pre><code>function SetupAndTearDown(Btn: Button): Task {
  let Handler: Func&lt;ClickedArgs:Task&gt; =
    async (Args: ClickedArgs): Task {
      Print("temp handler");
    };

  // Subscribe
  Btn.Clicked += Handler;

  // ... some processing ...

  // Unsubscribe
  Btn.Clicked -= Handler;
}</code></pre>

      <h3>13.8 Combining with with / lock (Reference)</h3>
      <p>
        Since <code>Event&lt;TArgs&gt;</code> is itself a reference type,
        it can be combined with <code>with</code> or <code>lock with</code>
        to safely raise events across threads.
      </p>
      <pre><code>struct Hub {
  event MessageReceived&lt;String&gt;;

  method RaiseMessage(Msg: String): Task {
    lock with (MessageReceived) {
      await MessageReceived.Raise(Msg);
    }
  }
}</code></pre>

      <h3>13.9 Summary</h3>
      <ul>
        <li><code>event</code> provides syntactic sugar and access control rules around
          <code>Event&lt;TArgs&gt;</code> fields.</li>
        <li>External code can only use <code>+=</code> / <code>-=</code> to subscribe/unsubscribe;
          firing and replacing the event reference are forbidden.</li>
        <li>Handlers have type <code>Func&lt;TArgs:Task&gt;</code>, defining an asynchronous event model.</li>
        <li>Interfaces can declare <code>event</code>s, expressing event contracts at the type level.</li>
        <li>Usability is similar to C# <code>event</code> while avoiding adding <code>delegate</code>
          as a language-level type, instead using Aloe’s function types and <code>Task</code>.</li>
      </ul>
    </section>

  </main>
</div>
</body>
</html>

