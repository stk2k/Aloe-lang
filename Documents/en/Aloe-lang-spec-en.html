
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft, English · pipe/filter/producer/consumer + delete/with/lock/clone/generics/where)</title>
  <!-- Last updated metadata -->
  <meta name="updated_at" content="2025-11-29" />
  <style>
    /* Minimal layout. Leave fonts to browser defaults. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">
      Draft · Pipe / Filter / Producer / Consumer + delete / with / lock / clone / generics / where
    </div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Overview</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#types-generics">4.6 Generics</a>
      <a href="#types-constraints">4.7 Type Constraints (where)</a>
      <a href="#functions-methods">5. Functions, Methods, Traits</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>

      <div class="section-title">Extended Syntax</div>
      <a href="#with">7. with Syntax</a>
      <a href="#delete">8. delete Syntax</a>
      <a href="#lock">9. lock Syntax and Synchronization</a>

      <div class="section-title">Control & Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model & Memory Management</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations & Future Work</a>
    </nav>
  </aside>

  <main class="content">

    <section id="intro">
      <h1>1. Overview</h1>
      <p>
        Aloe is an <strong>experimental programming language</strong> with static typing,
        a simple syntax, and a stack-based virtual machine (AloeVM).
        It is especially designed for <strong>dataflow description via Pipe / Filter</strong>
        and for high affinity with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type-checked at compile time)</li>
        <li>Syntax is close to C-like languages, but the features are kept minimal</li>
        <li>Suited for code that “streams and transforms data” such as text processing,
          REST calls, and logging
        </li>
        <li>Implementation assumes a stack-based VM (AloeVM) and future WebAssembly output</li>
      </ul>
      <p class="note">
        This document is a <strong>draft of the language specification</strong>.
        It may diverge from any actual compiler / VM implementations.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: can be read as a specification document</li>
        <li><strong>Ease of implementation</strong>: should be implementable with a small compiler / VM</li>
        <li><strong>Pipe / Filter consistency</strong>: type-safe representation of dataflow</li>
        <li><strong>Bridge to Wasm</strong>: easy integration with the Wasm component model in the future</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Being a “do everything” general-purpose language</li>
        <li>Performance competition on the level of JIT-optimized runtimes</li>
        <li>Complex metaprogramming (macros etc.) is out of scope for now</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source encoding is assumed to be UTF-8.</li>
        <li>Single-line comment: <code>// comment</code></li>
        <li>Multi-line comment: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifiers: start with an alphabetic character or <code>_</code>, followed by alphanumerics or <code>_</code>.</li>
        <li>Type names, trait names, and generic parameters are recommended to use PascalCase.</li>
        <li>Keywords are reserved and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td>
            <code>let</code>,
            <code>var</code>,
            <code>type</code>,
            <code>struct</code>,
            <code>class</code>,
            <code>enum</code>,
            <code>trait</code>
          </td>
        </tr>
        <tr>
          <td>Control flow</td>
          <td>
            <code>if</code>, <code>else</code>,
            <code>while</code>, <code>for</code>,
            <code>break</code>, <code>continue</code>,
            <code>return</code>,
            <code>try</code>, <code>catch</code>, <code>finally</code>
          </td>
        </tr>
        <tr>
          <td>Function-like</td>
          <td>
            <code>method</code>,
            <code>producer</code>,
            <code>pipe</code>,
            <code>filter</code>,
            <code>consumer</code>
          </td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td>
            <code>with</code>,
            <code>lock</code>,
            <code>delete</code>,
            <code>clone</code>,
            <code>where</code>,
            <code>readonly</code>
          </td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements must end with a semicolon <code>;</code>.</li>
        <li>Blocks are surrounded by <code>{ ... }</code>.</li>
        <li>Conditions in control flow constructs must be of type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation-defined, 32-bit assumed)</td></tr>
        <tr><td><code>Float</code></td><td>Floating point number (32 or 64-bit, implementation-defined)</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-defined, logically a reference type)</td></tr>
      </table>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-length array: <code>T[]</code></li>
        <li>Variable-length / lazy sequences are represented by <code>Pipe&lt;T&gt;</code> (see section 6).</li>
      </ul>

      <h3>4.3 Structs</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignment copies the value (shallow copy).</li>
        <li>Nested reference-type fields are shared (shallow copy semantics).</li>
      </ul>

      <h3>4.4 Classes</h3>
      <pre><code>class Buffer {
  Data: Byte[];
  Length: Int;
}</code></pre>
      <ul>
        <li><code>class</code> is always heap-allocated and is a <strong>reference type</strong>.</li>
        <li>Assignment of a class variable copies the <strong>reference</strong> (both variables point to the same instance).</li>
        <li>Fields are mutable by default; they can be made immutable with the <code>readonly</code> modifier.</li>
        <li>If a class is declared as <code>readonly class</code>, all its fields are considered readonly.</li>
      </ul>

      <pre><code>readonly class Point {
  X: Int;
  Y: Int;
}</code></pre>

      <h3>4.5 Enums</h3>
      <ul>
        <li><code>enum</code> is always represented internally as an <strong><code>Int</code></strong>.</li>
        <li>Generic enums such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are <strong>forbidden</strong>.</li>
        <li>For bit-flag enums, the number of flags is limited to at most 32.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>

      <section id="types-generics">
        <h3>4.6 Generics</h3>

        <p>
          Aloe supports <strong>generics (type parameters)</strong> on structs, classes, type aliases,
          methods, and pipe-related declarations.
        </p>

        <h4>4.6.1 Basic Syntax</h4>
        <pre><code>struct Pair&lt;TLeft, TRight&gt; {
  Left:  TLeft;
  Right: TRight;
}

class List&lt;T&gt; {
  // Internal representation is implementation-defined
}

type Option&lt;T&gt; = union {
  None;
  Some(T);
};</code></pre>

        <ul>
          <li>Type parameter names are recommended to be in PascalCase (e.g., <code>T</code>, <code>TItem</code>).</li>
          <li>Use generics as <code>Pair&lt;Int, String&gt;</code>, <code>List&lt;User&gt;</code>, etc.</li>
          <li>Using the generic name without type arguments (e.g., <code>List</code> alone) is a compile-time error.</li>
        </ul>

        <h4>4.6.2 Generic Methods</h4>
        <pre><code>method Identity&lt;T&gt;(Value: T): T {
  return Value;
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;, Default: T): T {
  // Pseudo-code:
  // for (item in Source) return item;
  // return Default;
}</code></pre>

        <ul>
          <li>Callers may specify type arguments explicitly, e.g. <code>Identity&lt;Int&gt;(10)</code>.</li>
          <li>If the type parameter can be inferred uniquely from arguments, it is allowed to omit them,
            e.g. <code>Identity("hello")</code>.</li>
          <li>If type inference cannot uniquely determine the type parameter (e.g., <code>MakePair(1, 2.0)</code>),
            it results in a compile-time error.</li>
        </ul>

        <h4>4.6.3 Combination with Pipe</h4>
        <pre><code>type Pipe&lt;T&gt; {
  // Implementation-specific internal fields
}

bound Pipe&lt;T&gt; {
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; {
    // Implementation omitted
  }

  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // Implementation omitted
  }
}</code></pre>

        <p class="note">
          <strong>Constraint:</strong><br />
          Methods declared inside <code>bound Pipe&lt;T&gt;</code> must <strong>always return a <code>Pipe&lt;*&gt;</code></strong>.
          In other words, they are restricted to be transformers of the form <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </p>
      </section>

      <section id="types-constraints">
        <h3>4.7 Type Constraints (where)</h3>

        <p>
          Type parameters on generics can have <strong>constraints</strong> using a <code>where</code> clause.
          All constraints are interpreted as a logical <strong>AND</strong>.
        </p>

        <h4>4.7.1 Syntax</h4>
        <pre><code>struct Box&lt;T&gt;
  where T: struct
{
  Value: T;
}

class RefBox&lt;T&gt;
  where T: class
{
  Value: T;
}

method Parse&lt;T&gt;(Text: String): T
  where T: Int
{
  // Implementation for Int only
}</code></pre>

        <p>General shape:</p>
        <pre><code>// Common pattern for types, methods, and pipe declarations
// TypeName&lt;T1, T2, ...&gt;
//   where T1: constraint1, constraint2
//   where T2: constraint3
// { ... }</code></pre>

        <h4>4.7.2 Supported Kinds of Constraints</h4>
        <p>In version 0.1, the following constraint kinds are supported:</p>

        <ol>
          <li>
            <strong>Kind constraints</strong><br />
            <code>where T: struct</code> / <code>where T: class</code><br />
            <ul>
              <li><code>struct</code>: T must be a value type (primitive value, <code>struct</code>, <code>enum</code>, etc.).</li>
              <li><code>class</code>: T must be a reference type (<code>class</code>, <code>String</code>, <code>Pipe&lt;T&gt;</code>, arrays, etc.).</li>
            </ul>
          </li>
          <li>
            <strong>Primitive type constraints</strong><br />
            <code>where T: Bool</code>, <code>where T: Int</code>,
            <code>where T: Float</code>, <code>where T: String</code>, etc.<br />
            <ul>
              <li>T must be that primitive type (or a simple alias of that type).</li>
              <li>Whether aliases such as <code>type MyInt = Int;</code> are accepted is left to implementations.</li>
            </ul>
          </li>
          <li>
            <strong>Trait constraints</strong><br />
            <code>where T: SomeTrait</code><br />
            <ul>
              <li><code>SomeTrait</code> is a trait declared by a <code>trait</code> definition.</li>
              <li>T must implement <code>SomeTrait</code>.</li>
              <li>Multiple trait constraints are allowed, e.g. <code>where T: Printable, Serializable</code>.</li>
            </ul>
          </li>
          <li>
            <strong>Concrete type constraints (struct / class / enum / union)</strong><br />
            <code>where T: MyStruct</code>, <code>where T: MyClass</code>, <code>where T: MyUnion</code>, etc.<br />
            <ul>
              <li>Without inheritance, this means “T must exactly be that type”.</li>
              <li>If inheritance is introduced, one might allow subclasses here, but this draft assumes
                <strong>no inheritance and exact match only</strong>.
              </li>
            </ul>
          </li>
          <li>
            <strong>Concrete generic type constraints</strong><br />
            <code>where T: Pipe&lt;Int&gt;</code>, <code>where T: List&lt;User&gt;</code>, etc.<br />
            <ul>
              <li>T must be exactly that generic type instantiation.</li>
              <li>With no subtyping or inheritance, only exact matches are valid.</li>
            </ul>
          </li>
        </ol>

        <h4>4.7.3 Multiple Constraints and Consistency</h4>
        <ul>
          <li>If multiple constraints are attached to the same type parameter, all must be satisfied (AND semantics).</li>
          <li>Logically inconsistent constraints (e.g., <code>where T: struct, MyClass</code>) produce a compile-time error.</li>
          <li>Combining primitive and kind constraints (e.g., <code>where T: Int, struct</code>) is redundant but may be permitted.</li>
        </ul>

        <pre><code>trait Printable {
  method ToString(): String;
}

// Accepts only reference types that are Printable
method LogAll&lt;T&gt;(Items: Pipe&lt;T&gt;)
  where T: class, Printable
{
  Items
    |&gt; Map(.ToString())
    |&gt; ForEach(Print);
}</code></pre>
      </section>
    </section>

    <section id="functions-methods">
      <h2>5. Functions, Methods, Traits</h2>

      <h3>5.1 method Declarations</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> declares either a top-level function or a method bound to a type.</li>
        <li>If there is no return value, the return type is considered <code>Unit</code>.</li>
      </ul>

      <h3>5.2 Traits</h3>
      <pre><code>trait Printable {
  method ToString(): String;
}</code></pre>
      <ul>
        <li><code>trait</code> is a reusable component that may contain method signatures and default implementations.</li>
        <li>Structs and classes may implement multiple traits.</li>
        <li>Traits can be used in generic constraints such as <code>where T: Printable</code>.</li>
      </ul>

      <h3>5.3 bound Method Binding</h3>
      <p>
        Aloe introduces <code>bound</code> to “attach” methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // Internal representation is VM-dependent
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // Implementation omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, the <strong>return type restriction</strong> on bound methods applies
        (see section 6.2).
      </p>

      <h3>5.4 clone Keyword</h3>
      <p>
        The <code>clone</code> keyword creates a copy of the target object and returns a reference to that copy.
      </p>

      <pre><code>var Original: Buffer = NewBuffer();

var Copy: Buffer = clone Original;  // New Buffer instance (shallow copy)</code></pre>

      <ul>
        <li><code>clone Expr</code> is mainly meaningful for reference types such as <code>class</code> instances and arrays.</li>
        <li>The default copy is a <strong>shallow copy</strong>, but types may define their own semantics.</li>
        <li>For structs, normal assignment already copies the value, so <code>clone</code> is not required.</li>
      </ul>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A key feature of Aloe is that <strong>Pipe / Filter dataflow</strong> can be written in a
        type-safe and consistent style.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, this is equivalent to:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>The <code>|&gt;</code> operator in Aloe is just syntactic sugar for such function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe.
          It corresponds to lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> is a pipe that carries elements of type <code>T</code>.</li>
          <li>Its internal representation (iterator chains, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers, transformers, and consumers built on top of <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // Implementation-specific internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> is the composition space of functions that take and return
          <code>Pipe&lt;T&gt;</code> (producers / transformers / consumers). Consumers act as gates from the
          pipe world back to the “normal” world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, we classify functions (or objects) into three categories:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>: Functions or objects returning <code>Pipe&lt;*&gt;</code> which are used at
            the head of a pipeline.
          </li>
          <li><strong>Role</strong>: Read data from the external world (files, HTTP, arrays, etc.) and pour it into
            the pipe world (<code>Pipe&lt;T&gt;</code>).
          </li>
          <li><strong>Type shape</strong>: Typically <code>X -&gt; Pipe&lt;T&gt;</code>.
            In this specification, <strong>anything designed as a producer must output <code>Pipe&lt;*&gt;</code></strong>.
          </li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filter)</h4>
        <ul>
          <li><strong>Definition</strong>: Functions or methods of type <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.</li>
          <li><strong>Role</strong>: Transform, filter, or reorder data while staying inside the pipe world.</li>
        </ul>

        <p>
          In Aloe, methods defined inside <strong><code>bound Pipe&lt;T&gt;</code></strong> are intended
          to be transformers only.
        </p>

        <div class="note">
          <strong>Restriction:</strong><br />
          Methods inside <code>bound Pipe&lt;T&gt;</code> must <strong>return <code>Pipe&lt;*&gt;</code></strong>.<br />
          That is, they must have the shape <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; { ... }

  // OK: transformer changing element type
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; { ... }

  // NG: Return type is not Pipe, violates the specification
  // method Count(): Int { ... }  // &lt;-- Should be a compile-time error
}</code></pre>

        <h4>6.2.3 Consumer (Terminal Filter)</h4>

        <ul>
          <li><strong>Definition</strong>: Functions or objects of shape <code>Pipe&lt;T&gt; -&gt; R</code> where
            <code>R</code> is not a <code>Pipe&lt;*&gt;</code>.
          </li>
          <li><strong>Role</strong>: Exit gate from the pipe world. Consume the pipe and convert it into arrays,
            single values, or external I/O.
          </li>
          <li><strong>Return type restriction</strong>: Consumers may return any type
            (<code>T[]</code>, <code>Int</code>, <code>Unit</code>, etc.), but they must not return
            <code>Pipe&lt;*&gt;</code>.
          </li>
        </ul>

        <pre><code>// Pure consumer that collects items into an array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// Consumer that counts the number of elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>
      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms for the Pipe / Filter model:
          <strong>producer / pipe / filter / consumer</strong>.
          All of them are “objects with constructors”, and their <code>bound</code> blocks are executed when
          they are connected into a pipeline.
        </p>

        <h4>6.3.1 producer Definition</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Executed when this producer is attached to a pipeline
    // Reads from external resources and writes to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the producer name.</li>
          <li><code>out</code> specifies the <strong>pipe world output type</strong> of this producer,
            and must be a <strong><code>Pipe&lt;*&gt;</code></strong>.
          </li>
          <li><code>bound(output)</code> is the implementation that runs when this producer is used at
            the head of a pipeline.</li>
        </ul>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo-code:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe Definition</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connecting pipes, bridging or transforming
  }
}</code></pre>

        <p class="note">
          Pipe declarations are intended for bridging external I/O (sockets, HTTP, etc.) or connecting
          streams with different element types (e.g., text → JSON).
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // Decoded object

  bound(input, output) {
    // Pseudo-code:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter Definition</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Filter connection logic
    // Describe how values are passed from input to output
  }
}</code></pre>

        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo-code:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer Definition</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Executed at the end of a pipeline
    // Consume all of input and return some value
  }
}</code></pre>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo-code:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo-code:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, pipe-related declarations have the following roles:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code> (must output <code>Pipe</code>)</li>
            <li><strong>pipe</strong>: bridging between streams of different types and external I/O</li>
            <li><strong>filter</strong>: usually <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> transformations</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → arbitrary non-<code>Pipe</code> type (exit from pipe world)</li>
          </ul>
        </p>
      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition</h4>
        <p>
          In Aloe, <code>|&gt;</code> is defined as <strong>pure syntactic sugar for function composition</strong>.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>A -&gt; B</code> and <code>G</code> has type <code>B -&gt; C</code>,
            then <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.
          </li>
          <li>It can be used for any types, not only <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Thus, <strong>from the type system’s perspective</strong>, “changing the return type in the middle”
          is not a problem at all.<br />
          The constraints of the Pipe / Filter model come from the <strong>library design
          (<code>Pipe&lt;T&gt;</code> and pipe-related declarations)</strong>, not from the bare language semantics.
        </div>

        <h4>6.4.2 Usage with Pipe&lt;T&gt;</h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>String -&gt; Pipe&lt;String&gt;</code>)</li>
          <li><code>Where</code>, <code>Map</code>: transformers (<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>)</li>
          <li><code>ToArray</code>: consumer (<code>Pipe&lt;User&gt; -&gt; User[]</code>)</li>
          <li>The whole pipe expression’s type is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          It is possible (by language rules) to chain further using <code>|&gt;</code> after a consumer,
          but this is generally not recommended from a style perspective.<br />
          For example, <code>ToArray() |&gt; ToArray()</code> should be avoided.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Examples of Standard Filters and Producers</h3>

        <h4>6.5.1 Typical Transformers (filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Typical Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Typical Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // Returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // Returns Int
}</code></pre>

        <h4>6.5.4 Usage Example</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with Syntax</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> syntax is syntactic sugar for concise sequences of property assignments
        and method calls on a particular object.
        In Aloe it also works as a <strong>“release lock” that guarantees the lifetime of the target object
        within the block</strong>.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The above <code>with</code> block is equivalent (at the surface level) to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li>In <code>with (Expr) { ... }</code>, <code>Expr</code> is evaluated exactly once.</li>
        <li>Simple identifier assignments inside the block are interpreted as member accesses
          on the target object.</li>
      </ul>

      <h3>7.3 Release Lock (GC Root Behavior)</h3>
      <p>
        AloeVM assumes reference counting plus sliding compaction for memory management.
        A <code>with</code> block behaves as a “release lock” in the following sense:
      </p>
      <ul>
        <li>The result of <code>with (Expr)</code> is stored in an implicit variable (GC root).</li>
        <li>This implicit root is excluded from GC collection <strong>until exiting the block</strong>.</li>
        <li>Thus, the target object is guaranteed to be alive during execution of the <code>with</code> block.</li>
      </ul>

      <h3>7.4 Relationship with delete</h3>
      <ul>
        <li>It is a compile-time error to apply <code>delete</code> to the variable used as the
          <code>with</code> target (e.g., <code>Request</code>) inside the same <code>with</code> block.
        </li>
        <li>Reason: <code>with</code> expresses the intent “this object must be alive in this block”,
          which conflicts with deleting that same variable.
        </li>
        <li>However, applying <code>delete</code> to another variable referencing the same object is allowed,
          because the <code>with</code> root keeps one reference alive.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is kept alive by with; it will exist throughout the block.

  delete Alias;   // OK: only cuts the Alias reference
  Url = "https://example.com/api";  // Still valid
}

// After this, the with GC root is removed; if there are no other references,
// the object will be freed by GC at some point.</code></pre>

      <p class="note">
        In short, <code>with</code> acts as
        <strong>“sugar for property setup” and at the same time a “temporary GC protection lock”</strong>
        on the target object.
      </p>
    </section>

    <section id="delete">
      <h2>8. delete Syntax</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> is <strong>not</strong> “destroy this object”.
        It is a construct for <strong>cutting a variable’s reference</strong>.
      </p>
      <ul>
        <li>Actual object destruction (memory reclamation, finalizers, etc.) is handled by
          the <strong>AloeVM runtime (reference counting + GC)</strong>.
        </li>
        <li><code>delete</code> expresses the intent “this variable no longer uses this object”
          and serves as a type-safe replacement for <code>null</code> assignment.
        </li>
      </ul>

      <h3>8.2 Syntax</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile Time)</h3>
      <ul>
        <li>The <code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After executing <code>delete</code>, the variable must not be used for reading,
          member access, or method calls</strong> until it is re-assigned.
        </li>
        <li>However, <strong>reassigning a new value to the variable is allowed</strong>.
          Conceptually, <code>delete</code> returns the variable to an “uninitialized / deleted” state.
        </li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Use Buf
DoSomething(Buf);

delete Buf;

// From here on, reading Buf or accessing Buf.Length is a compile-time error.

// Reassignment makes Buf usable again.
Buf = NewBuffer();</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM roughly behaves as follows:
      </p>
      <ul>
        <li>Decrement the reference count for the object currently pointed to by <code>Var</code>
          (assuming reference counting).
        </li>
        <li>Mark the variable <code>Var</code> as being in an “uninitialized / deleted” state.</li>
        <li>When the reference count of an object reaches zero, it is freed at GC time.
          <strong>The object may not be destroyed immediately at the moment of <code>delete</code></strong>.
        </li>
      </ul>

      <p class="note">
        In the Aloe language specification, <strong>the timing of object destruction is the responsibility of the VM</strong>.
        <code>delete</code> only disconnects one variable from the object.
      </p>

      <h3>8.5 Relationship with with</h3>
      <ul>
        <li>As mentioned in section 7.4, it is a compile-time error to <code>delete</code> the same variable that is used
          as the <code>with</code> target within the <code>with</code> block.
        </li>
        <li>Deleting another variable that refers to the same object is allowed, because the with block
          keeps one GC root alive for the target object.</li>
      </ul>

      <p class="note">
        In the future, if the language introduces ownership-based resource types, <code>delete</code> might be integrated
        with that ownership model. In this draft, however, the language is defined
        <strong>without an ownership model</strong>.
      </p>
    </section>

    <section id="lock">
      <h2>9. lock Syntax and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> syntax locks a particular object so that mutual exclusion and
        GC read-barrier optimization can be applied within the lock scope.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> guarantees exclusive access to the lock target specified by <code>Expr</code>
          for the duration of <code>Body</code>.
        </li>
        <li>Lock acquisition and release are handled by the VM.</li>
        <li>Updates to data shared across threads should generally be confined inside <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM assumes sliding-compaction memory management.
        Within a <code>lock</code> block, the VM is expected to optimize read barriers so that the number of checks
        on the same object can be reduced to one where possible.
      </p>
    </section>

    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown in the <code>try</code> block can be caught by a matching <code>catch</code> clause.</li>
        <li>The <code>finally</code> block is always executed, regardless of whether an exception is thrown.</li>
        <li>Details of exception types and hierarchies are defined in the VM specification.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. Execution Model & Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode virtual machine.</li>
        <li>Function calls are implemented by stacking frames.</li>
        <li>GC is assumed to use reference counting plus sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>GC is triggered under certain conditions and compacts memory while sliding live objects.</li>
        <li><code>with</code> can act as a temporary GC root to protect an object,
          and in combination with <code>lock</code>, the VM may optimize read-barrier checks.
        </li>
        <li>In normal code, programmers do not need to use <code>delete</code> for memory reclamation.
          It is only needed when they want to explicitly express “we are done with this reference”.
        </li>
      </ul>

      <p class="small">
        A detailed opcode list and GC implementation details are handled in the AloeVM specification.
      </p>
    </section>

    <section id="limits">
      <h2>12. Limitations & Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>Generics constraints are limited to the kinds described in this chapter
          (more expressive constraints may be added in the future).</li>
        <li>Module systems and package management are not covered in this specification.</li>
        <li>Metaprogramming features (macros, reflection, etc.) are undefined.</li>
        <li>The presence and semantics of class inheritance are still under discussion.
          This draft assumes a “no inheritance” model when describing constraints.</li>
      </ul>

      <h3>12.2 Topics for Future Consideration</h3>
      <ul>
        <li>Parallelization and fusion optimizations for Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Error handling with Result-like types (non-exception-based error flows).</li>
        <li>Extending the standard library for distributed and streaming workloads.</li>
        <li>Designing an ownership-based resource type model and integrating it with <code>delete</code>, if needed.</li>
        <li>More expressive type constraints (e.g., trait-based typeclass-like designs).</li>
      </ul>

      <p class="note">
        This draft particularly aims to clarify:<br />
        <strong>the relationships among Pipe / Filter, Producer / Transformer / Consumer / pipe / consumer declarations,</strong><br />
        <strong>the behavior of with / delete / lock / clone and their connection to AloeVM’s memory model,</strong><br />
        and <strong>the design of generics and where constraints.</strong>
      </p>
    </section>

  </main>
</div>
</body>
</html>

