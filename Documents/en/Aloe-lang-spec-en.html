
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – pipe/filter/producer/consumer + delete/with/lock/class inheritance/generics)</title>
  <meta name="last-updated" content="2025-11-29T11:30:00+09:00" />
  <style>
    /* Minimal layout only. Let the browser decide fonts. */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / Pipe, Filter, Producer, Consumer + delete/with/lock/class inheritance/generics</div>
    <div class="updated">Last updated: 2025-11-29 11:30:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#as-to">3.5 as binding and to cast</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#functions-methods">5. Methods and Functions</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operator <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers</a>
      <a href="#switch-pipe">6.6 switch pipe</a>

      <div class="section-title">Syntactic Extensions</div>
      <a href="#with">7. with Syntax</a>
      <a href="#delete">8. delete Syntax</a>
      <a href="#lock">9. lock Syntax and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model and Memory Management</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Work</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing, a simple syntax,
        and a stack-based virtual machine (AloeVM).
        It is designed with a strong focus on <strong>pipe / filter style data flow</strong>
        and interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (type checking is done at compile time).</li>
        <li>C-like surface syntax, but the feature set is intentionally small.</li>
        <li>Emphasis on writing <br />“data flow and transformation” such as text processing,
          REST calls, and logging in a pleasant style.</li>
        <li>Assumes a stack-based VM (AloeVM) and a future WebAssembly backend.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft language specification</strong>.<br />
        There may be differences from the actual compiler / VM implementation.
      </p>
    </section>

    <section id="goals">
      <h2>2. Design Goals</h2>
      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: the spec itself should be readable as documentation.</li>
        <li><strong>Ease of implementation</strong>: should be implementable with a small compiler and VM.</li>
        <li><strong>Consistency of Pipe / Filter</strong>: type-safe data-flow representation.</li>
        <li><strong>Bridge to Wasm</strong>: easy to connect to the future Wasm Component Model.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Becoming a “do everything” general-purpose language.</li>
        <li>Competing in performance with heavily optimized JIT compilers.</li>
        <li>Complex metaprogramming (macros, etc.) is out of scope for now.</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source files are assumed to be encoded in UTF-8.</li>
        <li>Single-line comments: <code>// comment</code></li>
        <li>Multi-line comments: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifiers: start with a letter or <code>_</code>, followed by letters, digits, or <code>_</code>.</li>
        <li>Keywords are reserved words and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declaration</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code>, <code>switch</code>, <code>case</code>, <code>default</code></td>
        </tr>
        <tr>
          <td>Functions</td>
          <td><code>method</code></td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td>
        </tr>
        <tr>
          <td>Pipe-related</td>
          <td><code>producer</code>, <code>pipe</code>, <code>filter</code>, <code>consumer</code>, <code>bound</code>, <code>as</code>, <code>to</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are enclosed in <code>{ ... }</code>.</li>
        <li>Conditions of control structures must be of type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="as-to">
      <h2>3.5 as binding and to cast</h2>

      <h3>3.5.1 Overview</h3>
      <p>
        Aloe introduces <code>as</code> and <code>to</code> as lightweight syntax for
        <strong>binding the current element</strong> and <strong>casting</strong> in contexts such as
        switch pipes and collection / pipe traversal.
      </p>

      <h3>3.5.2 as a — element binding</h3>
      <p>
        <code>as a</code> binds the current element to a local name <code>a</code>.
        It can be used in both switch pipes and collection / pipe contexts.
      </p>

      <pre><code>// in a pipe
Items
  |&gt; as a {
       // a refers to each element in the pipe
       LogDebug(a);
     }

// in a switch pipe
switch as a {
  case a.Kind == "info":   LogInfo(a);
  case a.Kind == "warn":   LogWarn(a);
  default:                 LogDebug(a);
}</code></pre>

      <ul>
        <li>The lifetime of the binding <code>a</code> is limited to the body associated with <code>as a</code>
          (the pipe body or switch body).</li>
        <li>The binding name is ordinary and can shadow outer variables with the same name.</li>
      </ul>

      <h3>3.5.3 as a:Type — typed element binding</h3>
      <p>
        <code>as a:Type</code> is a typed variant of <code>as a</code>. It binds the current element
        as a value of the specified type <code>Type</code>.
      </p>

      <pre><code>switch as r:HttpResponse {
  case r.StatusCode == 200:  HandleOk(r);
  case r.StatusCode &gt;= 500:  HandleServerError(r);
  default:                   HandleOther(r);
}</code></pre>

      <ul>
        <li>The compiler checks that the current element can be treated as <code>Type</code>.
          If not, it is a compile-time error (or a runtime cast error depending on the context; details are VM-defined).</li>
        <li>The bound name <code>a</code> (or <code>r</code> in the example) is used inside <code>case</code> conditions and bodies.</li>
      </ul>

      <h3>3.5.4 as:Type — sugar with an implicit element name</h3>
      <p>
        <code>as:Type</code> is a syntactic sugar form that omits the explicit element name.
        Conceptually it is equivalent to <code>as a:Type</code> with some implicit name.
      </p>

      <pre><code>Items
  |&gt; as:UserInfo {
       // the current element is treated as UserInfo
       // an implicit name is bound (implementation-defined)
     }</code></pre>

      <p class="note">
        In practice, it is recommended to use <code>as a:Type</code> when you want to refer to the element
        multiple times, and <code>as:Type</code> when the element is only passed through or used in a very local way.
      </p>

      <h3>3.5.5 as a to Type — sugar for typed binding</h3>
      <p>
        <code>as a to Type</code> is defined as syntactic sugar for <strong><code>as a:Type</code></strong>.
        The <code>to</code> keyword here is part of the binding syntax, not a separate cast expression.
      </p>

      <pre><code>// Equivalent forms:
switch as r to HttpResponse {
  ...
}

// is exactly sugar for:
switch as r:HttpResponse {
  ...
}</code></pre>

      <ul>
        <li>This form is useful when emphasizing “bind as <code>a</code>, and also treat it as <code>Type</code>”.</li>
        <li>The semantics (including type checks) are identical to <code>as a:Type</code>.</li>
      </ul>

      <h3>3.5.6 to Type — expression-level cast</h3>
      <p>
        Outside of <code>as</code>-binding syntax, <code>to</code> can be used as an expression-level cast:
      </p>

      <pre><code>let Value: Any = GetValue();
let Response: HttpResponse = Value to HttpResponse;

// inside a case condition
switch as v {
  case (v to Int) &gt; 0: HandlePositive(v);
  default:             HandleOther(v);
}</code></pre>

      <ul>
        <li>The exact cast semantics (checked vs. unchecked, exception type on failure, etc.) are defined by AloeVM.</li>
        <li><code>to Type</code> can be used wherever an expression is allowed.</li>
      </ul>

      <p class="small">
        In summary, <code>as</code> is used to bind the current element (optionally with a type),
        while <code>to</code> serves both as part of the sugar form <code>as a to Type</code>
        and as a general expression-level cast.
      </p>
    </section>

    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit width is implementation-defined; we assume 32-bit here).</td></tr>
        <tr><td><code>Float</code></td><td>Floating point number (32 or 64-bit, implementation-defined).</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-defined).</td></tr>
      </table>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-length arrays: <code>T[]</code></li>
        <li>Variable-length, lazily evaluated sequences are represented by <code>Pipe&lt;T&gt;</code> (see section 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignment copies the value.</li>
        <li>The copy is shallow; sharing behavior of nested reference-type fields depends on the VM.</li>
        <li>A struct may inherit from at most one other struct (single inheritance between structs).</li>
        <li>Implementing <code>interface</code> on a <code>struct</code> is <strong>forbidden</strong>.
          (How structs interact with traits and generic constraints will be specified later.)</li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as <strong><code>Int</code></strong>.</li>
        <li><code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> style generic enums are
          <strong>forbidden</strong>.</li>
        <li>Bit-flag enums are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed)</h2>

      <h3>4.5.1 Basic Class Rules</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignment performs a <strong>shallow copy of the reference</strong>.</li>
        <li>The <code>clone</code> keyword creates a shallow copy of the object and returns a new reference.</li>
        <li>Every class is <strong>cloneable</strong>; the language does not provide a way to declare a class
          as “non-cloneable”. If you want to discourage cloning, that is handled by API design and coding conventions.</li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // reference copy (A and B point to the same instance)

var C: User = clone A;  // shallow copy; returns a new instance</code></pre>

      <p class="note">
        A <strong>shallow copy</strong> means that field values are copied as is.<br />
        If a field itself is a reference type, the reference value is copied.
        For deep copies or custom duplication logic, users can define their own APIs
        (e.g. a <code>Clone</code> method) on top of <code>clone</code>.
      </p>

      <h3>4.5.2 Class Inheritance (single inheritance)</h3>
      <p>
        Aloe classes support <strong>single inheritance</strong> only.<br />
        That is, each class may specify exactly one base class.
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// This is a compile error (multiple inheritance is forbidden)
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>Class hierarchies form trees (or chains); no diamond inheritance.</li>
        <li>Class inheritance is a mechanism for reusing state and behavior.</li>
      </ul>

      <h3>4.5.3 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance for classes, Aloe provides
        <strong>interface</strong> and <strong>trait</strong> for composing behavior.
      </p>

      <ul>
        <li><code>interface</code> defines method signatures only; it does not hold implementations
          (whether default implementations are allowed is a future design topic).</li>
        <li><code>trait</code> is a mixin unit that can hold method implementations and is used to
          add behavior to existing classes.</li>
        <li>A class may have <strong>one base class</strong>, implement multiple <code>interface</code>s,
          and apply multiple <code>trait</code>s via <code>with</code>.</li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose(): Unit;
}

trait Printable {
  method PrintSelf(): Unit {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose(): Unit {
    // resource cleanup
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        Detailed rules for <code>interface</code> and <code>trait</code>
        (their own inheritance, conflict resolution when multiple traits define the same method, etc.)
        are not fully specified in this draft. Only the direction is sketched here.
      </p>

      <h3>4.5.4 sealed classes</h3>
      <p>
        To forbid inheritance from a particular class, Aloe provides the <code>sealed</code> modifier.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// Compile error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li>A <code>sealed class</code> cannot be used as a base class.</li>
        <li>Even if a class is <code>sealed</code>, it can still implement interfaces
          or apply traits via <code>with</code>.</li>
        <li>In the future, sealed classes combined with unions and pattern matching
          may be used to provide exhaustiveness checking.</li>
      </ul>

      <h3>4.5.5 readonly and classes</h3>
      <ul>
        <li>Fields of a class are mutable by default.</li>
        <li>Adding a <code>readonly</code> modifier to a field makes it immutable:
          <ul>
            <li>Assignments to that field are only allowed in the
              <strong>field initializer</strong> or in the
              <strong>constructor of the same class</strong>.</li>
            <li>Any assignment outside of those locations is a compile-time error.</li>
          </ul>
        </li>
        <li><code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are treated as if they had <code>readonly</code>.</li>
            <li>Field assignments are only allowed in field initializers and constructors of that class.</li>
            <li>After the constructor finishes, no code is allowed to modify any field of that instance.</li>
          </ul>
        </li>
        <li><code>readonly</code> and <code>clone</code> are orthogonal:
          a <code>readonly class</code> can still be cloned.
          The clone is another instance with the same immutable state.</li>
      </ul>

      <p class="small">
        This section sets the high-level policy that:
        classes are heap-allocated reference types with single inheritance, multiple behavior composition via
        interface + trait, non-inheritability via <code>sealed</code>, and immutability via
        <code>readonly</code> at the field or class level.<br />
        Details such as method resolution order or trait conflict resolution are specified elsewhere.
      </p>
    </section>

    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, structs, classes, interfaces, traits,
        methods, and pipe-related declarations.<br />
        The goal is to make collections and Pipe / Filter reusable and type-safe,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: T -&gt; U): Pipe&lt;U&gt; {
  // implementation omitted
}</code></pre>

      <h3>4.6.2 Generic Type Parameters</h3>
      <ul>
        <li>Types, structs, classes, interfaces, traits, methods,
          and producer/filter/consumer declarations can take type parameters <code>&lt;T, U, ...&gt;</code>.</li>
        <li>Generic parameter names are recommended to start with uppercase letters
          (<code>T</code>, <code>TItem</code>, <code>TKey</code>, etc.).</li>
        <li>Type arguments are bound to concrete types at use sites.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // implementation omitted
}</code></pre>

      <h3>4.6.3 where Constraints (Overview)</h3>
      <p>
        Aloe generics support arbitrary type constraints using <code>where</code> clauses.<br />
        By default there are no constraints, but version 0.1 supports a small set of basic ones.
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int-only sum implementation
}</code></pre>

      <p class="note">
        Here, <code>where</code> is purely for <strong>compile-time type checking</strong>.<br />
        The runtime representation (monomorphization vs. tagged shared code, etc.) is left to the VM specification.
      </p>

      <h3>4.6.4 Supported Constraint Kinds</h3>
      <p>
        Version 0.1 supports the following constraint kinds:
      </p>

      <ul>
        <li><strong>Value-type / Reference-type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive type constraints</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>, etc.
              A primitive type name can be used directly.</li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – types implementing the trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – exactly the struct type <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – exactly the class type <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Any concrete type</strong>
          <ul>
            <li>Any existing concrete type can be specified
              (e.g. <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Value-type-only generic
method Zero&lt;T&gt;(): T
  where T: struct
{
  // implementation omitted
}

// Pipe for Int only
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // implementation omitted
}

// Specific struct type only
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior on Constraint Violations</h3>
      <ul>
        <li>If a type argument does not satisfy the <code>where</code> constraints,
          it is a compile-time error.</li>
        <li>If multiple constraints are specified, all must be satisfied simultaneously.</li>
        <li>Cyclic constraints or advanced typeclass-like structures are not supported in this version.</li>
      </ul>

      <pre><code>// Example of compile error:

// where T: Int, so T cannot be String
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization vs. tagged shared code, etc.)
        is defined by AloeVM.<br />
        This language spec focuses on type-safe reuse and <code>where</code>-based constraint checking.
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. Methods and Functions</h2>

      <h3>5.1 method Declarations</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> defines a top-level function or a method bound to a type.</li>
        <li>If the return type is omitted, the method is assumed to return <code>Unit</code>.</li>
      </ul>

      <h3>5.2 bound for Method Binding</h3>
      <p>
        Aloe uses <code>bound</code> to add methods to existing types.
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // internal representation is VM-dependent
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // implementation omitted
  }
}</code></pre>

      <p class="note">
        For <code>Pipe&lt;T&gt;</code>, methods declared inside a <code>bound</code> block are
        subject to specific <strong>constraints on return types</strong> (see section 6.2).
      </p>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is its ability to express
        <strong>Pipe / Filter style data-flow</strong> in a type-safe and consistent way.
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        Conceptually, this is equivalent to the following nested calls:
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>The Aloe <code>|&gt;</code> operator is syntactic sugar for such function composition.</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe,
          analogous to lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents “a pipe where elements of type <code>T</code> flow”.</li>
          <li>Internal representation (chained iterators, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers / transformers / consumers based on <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // VM-dependent internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> means the space of producers/transformers/consumers
          that accept and/or return <code>Pipe&lt;T&gt;</code>.<br />
          Consumers are the exits from the pipe world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, we classify functions and objects into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition</strong>:
            a function/object whose return type is <code>Pipe&lt;*&gt;</code> and appears at the head of a pipeline.</li>
          <li><strong>Role</strong>:
            reads data from the outside world (files, HTTP, arrays, etc.) and
            “feeds” it into the pipe world as <code>Pipe&lt;T&gt;</code>.</li>
          <li><strong>Type</strong>:
            generally of the form <code>X -&gt; Pipe&lt;T&gt;</code>.
            Producers are designed to always output some <code>Pipe&lt;*&gt;</code>.</li>
        </ul>

        <h4>6.2.2 Transformer (intermediate filter)</h4>
        <ul>
          <li><strong>Definition</strong>:
            a function/method of type <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.</li>
          <li><strong>Role</strong>:
            transforms, filters, or sorts data within the pipe world; it does not exit the pipe world.</li>
        </ul>

        <p>
          In Aloe, methods declared inside <strong><code>bound Pipe&lt;T&gt;</code></strong> are
          intended to be used as transformers only.
        </p>

        <div class="note">
          <strong>Constraint:</strong><br />
          Methods declared inside a <code>bound Pipe&lt;T&gt;</code> block must
          <strong>always return <code>Pipe&lt;*&gt;</code></strong>.<br />
          In other words, their type must be <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>.
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; { ... }

  // OK: element-type-changing transformer
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; { ... }

  // NG: not returning Pipe, should be a compile error
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer (terminal filter)</h4>

        <ul>
          <li><strong>Definition</strong>:
            a function/object of type <code>Pipe&lt;T&gt; -&gt; R</code>,
            where <code>R</code> is not <code>Pipe&lt;*&gt;</code>.</li>
          <li><strong>Role</strong>:
            exits the pipe world by fully consuming the pipe and converting it into an array,
            scalar, or other external representation.</li>
          <li><strong>Return type</strong>:
            <code>R</code> may be any non-pipe type: <code>T[]</code>, <code>Int</code>, <code>Unit</code>, etc.</li>
        </ul>

        <pre><code>// consumer that materializes a pipe into an array
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// consumer that counts elements
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms to build Pipe / Filter components:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of these are treated as “objects with constructors” that run their
          <code>bound</code> blocks when connected into a pipeline.
        </p>

        <h4>6.3.1 producer Declaration</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Runs when this producer is connected into a pipeline
    // Reads from external resources and writes to output
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> is the name of the producer.</li>
          <li><code>out</code> specifies the output type in the pipe world.
            It must be of type <code>Pipe&lt;*&gt;</code>.</li>
          <li><code>bound(output)</code> defines the behavior when the producer is connected;
            <code>output</code> has the type specified by <code>out</code> (e.g. <code>Pipe&lt;T&gt;</code>).</li>
        </ul>

        <p>
          Constructor parameters (<code>Params...</code>) are accessible from within the <code>bound</code> block.
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo code:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe Declaration</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Connects input and output and defines how to transfer/transform
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> is the name of the pipe.</li>
          <li><code>in</code> is the type flowing in from upstream.</li>
          <li><code>out</code> is the type flowing downstream.</li>
          <li><code>bound(input, output)</code> describes the transformation between them.</li>
        </ul>

        <p class="note">
          A <code>pipe</code> declaration is intended for bridging between different kinds of streams
          (e.g. text → JSON) or between stream types and external I/O such as sockets or HTTP.
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON text
  out: T;        // decoded object

  bound(input, output) {
    // Pseudo code:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter Declaration</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // Defines how elements flow from input to output
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> is the name of the filter.</li>
          <li><code>in</code> / <code>out</code> specify the input and output types.</li>
          <li>In typical pipe/filter chains, both <code>in</code> and <code>out</code> are of type <code>Pipe&lt;*&gt;</code>.</li>
          <li><code>bound(input, output)</code> describes the transformation.</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo code:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo code:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer Declaration</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // Runs at the end of the pipeline
    // Consumes input and returns a value
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> is the name of the consumer.</li>
          <li><code>in</code> specifies the input type.
            In the Pipe / Filter model this is usually <strong><code>Pipe&lt;T&gt;</code></strong>.</li>
          <li><code>bound(input)</code> runs at the end of the pipeline, fully consumes <code>input</code>,
            and returns some value of type <code>R</code>.</li>
          <li><code>R</code> can be any type such as <code>T[]</code>, <code>Int</code>, <code>Bool</code>, or <code>Unit</code>,
            but <strong>must not be <code>Pipe&lt;*&gt;</code></strong>.</li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo code:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo code:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          In summary, the roles of pipe-related declarations are:
          <ul>
            <li><strong>producer</strong>: external world → <code>Pipe&lt;*&gt;</code> (always outputs a pipe)</li>
            <li><strong>pipe</strong>: bridging between heterogeneous streams and external I/O</li>
            <li><strong>filter</strong>: usually <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> transformations</li>
            <li><strong>consumer</strong>: <code>Pipe&lt;T&gt;</code> → non-pipe type (exit from pipe world)</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operator <code>|&gt;</code></h3>

        <h4>6.4.1 Language-level Definition</h4>
        <p>
          In Aloe, <code>|&gt;</code> is defined as syntactic sugar for <strong>simple function composition</strong>.
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>A -&gt; B</code> and <code>G</code> has type <code>B -&gt; C</code>,
            then <code>Expr |&gt; F |&gt; G</code> has type <code>C</code>.</li>
          <li>The operator can be used with any types; it is not limited to <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <div class="note">
          Therefore, from the type system perspective, it is not a problem for the result type
          to change in the middle of a pipeline.<br />
          Constraints of the Pipe / Filter model are provided by
          <strong><code>Pipe&lt;T&gt;</code> and the design of pipe-related libraries</strong>,
          not by the operator itself.
        </div>

        <h4>6.4.2 Using Pipe&lt;T&gt; with <code>|&gt;</code></h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: producer (<code>String -&gt; Pipe&lt;String&gt;</code>)</li>
          <li><code>Where</code>, <code>Map</code>: transformers (<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>)</li>
          <li><code>ToArray</code>: consumer (<code>Pipe&lt;User&gt; -&gt; User[]</code>)</li>
          <li>The overall type of the pipeline is <code>User[]</code>, the return type of <code>ToArray</code>.</li>
        </ul>

        <p class="warning">
          <strong>Note:</strong><br />
          From the language’s point of view, it is allowed to continue <code>|&gt;</code> after a consumer,
          but stylistically it is not recommended.<br />
          For example, patterns such as <code>ToArray() |&gt; ToArray()</code> should be avoided.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters and Producers</h3>

        <h4>6.5.1 Typical Transformers (filters)</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 Typical Producers</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 Typical Consumers</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns T[]
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // returns Int
}</code></pre>

        <h4>6.5.4 Example</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>

      <section id="switch-pipe">
        <h3>6.6 switch pipe</h3>

        <h4>6.6.1 Overview</h4>
        <p>
          Aloe extends the pipe model with a <strong>switch pipe</strong> that routes each element
          based on conditions, using a switch-like syntax integrated with <code>as</code>.
        </p>

        <pre><code>Items
  |&gt; switch as a {
       case a.Kind == "info":    LogInfo(a);
       case a.Kind == "warn":    LogWarn(a);
       default:                  LogDebug(a);
     }</code></pre>

        <p>
          For each element flowing through the pipe (conceptually <code>x</code>), the switch:
        </p>
        <ul>
          <li>Binds <code>x</code> as <code>a</code> (via <code>as a</code>).</li>
          <li>Evaluates <code>case</code> conditions from top to bottom.</li>
          <li>Executes the body of the first <code>case</code> whose condition evaluates to <code>true</code>.</li>
          <li>If none match and a <code>default</code> is present, executes the <code>default</code> body.</li>
        </ul>

        <h4>6.6.2 Types and return type of switch</h4>
        <p>
          A switch pipe itself has a type, determined by the types of the <code>case</code> and
          <code>default</code> bodies:
        </p>
        <ul>
          <li>All right-hand sides of <code>case</code> and <code>default</code> must return
            the <strong>same type</strong>.</li>
          <li>That common type is the type of the entire <code>switch</code> expression.</li>
          <li>When used in a pipe, that common type must fit into the surrounding pipeline.</li>
        </ul>

        <pre><code>// all branches return Unit
Items
  |&gt; switch as a {
       case a.Kind == "info":    LogInfo(a);   // Unit
       case a.Kind == "warn":    LogWarn(a);   // Unit
       default:                  LogDebug(a);  // Unit
     };

// all branches return Pipe&lt;T&gt;
ReadLines("log.txt")
  |&gt; switch as line {
       case line.StartsWith("[ERROR]"):
         FromArray([line])  // Pipe&lt;String&gt;
       default:
         FromArray([])      // Pipe&lt;String&gt;
     }
  |&gt; ToArray();</code></pre>

        <h4>6.6.3 Using typed binding and to</h4>
        <p>
          A switch pipe can use typed bindings and sugar forms described in section 3.5:
        </p>

        <pre><code>// using as a:Type
Responses
  |&gt; switch as r:HttpResponse {
       case r.StatusCode == 200: HandleOk(r);
       case r.StatusCode &gt;= 500: HandleServerError(r);
       default:                  HandleOther(r);
     }

// using as a to Type (sugar)
Responses
  |&gt; switch as r to HttpResponse {
       case r.StatusCode == 200: HandleOk(r);
       default:                  HandleOther(r);
     }</code></pre>

        <p class="note">
          In a switch pipe:
          <ul>
            <li><code>as a</code> binds the current element to <code>a</code>.</li>
            <li><code>as a:Type</code> additionally treats the element as <code>Type</code>.</li>
            <li><code>as a to Type</code> is defined as syntactic sugar for <code>as a:Type</code>.</li>
            <li><code>to Type</code> can also be used inside conditions as a cast expression.</li>
          </ul>
        </p>
      </section>
    </section>

    <section id="with">
      <h2>7. with Syntax</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> syntax is syntactic sugar for writing repeated property assignments
        or method calls on the same target object.<br />
        In Aloe it also serves as a <strong>“lifetime lock”</strong> that keeps the target object alive
        for the duration of the block.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The above <code>with</code> block is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> evaluates <code>Expr</code> <strong>exactly once</strong>.</li>
        <li>Simple identifier assignments inside the block are interpreted as member assignments on the target object.</li>
      </ul>

      <h3>7.3 Lifetime Lock (as a GC root)</h3>
      <p>
        AloeVM is assumed to use a combination of reference counting and sliding compaction for memory management.<br />
        In this model, the <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The value of <code>Expr</code> in <code>with (Expr)</code> is stored in a hidden variable (a GC root).</li>
        <li>The hidden variable keeps the object alive until the block ends,
          guaranteeing that the object will <strong>not be freed within the block</strong>.</li>
        <li>Thus, the object is guaranteed to be alive while the block executes.</li>
      </ul>

      <h3>7.4 Relationship with delete</h3>
      <ul>
        <li>Within a <code>with</code> block targeting a given variable, it is a compile-time error
          to issue <code>delete</code> on that same variable.</li>
        <li>This is because <code>with</code> indicates “I want this object to stay alive here”,
          which contradicts <code>delete</code>.</li>
        <li>However, it is permitted to <code>delete</code> a <em>different variable</em> that refers to the same object.
          Because the <code>with</code> GC root remains, the object itself stays alive.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is protected by with; it is guaranteed to be alive in this block.

  delete Alias;   // OK: only removes the Alias reference
  Url = "https://example.com/api";  // still usable
}

// After exiting the with block, the GC root is removed.
// If no other references remain, the object may eventually be freed.</code></pre>

      <p class="note">
        In summary, <code>with</code> is both
        <strong>syntactic sugar for member access</strong> and
        <strong>a mechanism for temporarily treating the target object as a GC root</strong>.
      </p>
    </section>

    <section id="delete">
      <h2>8. delete Syntax</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> does <strong>not</strong> directly destroy objects.<br />
        Instead, it is a construct for <strong>removing a reference from a variable</strong>.
      </p>
      <ul>
        <li>Actual object destruction (memory free, finalizers, etc.) is handled by the runtime (AloeVM)
          using <strong>reference counting + GC</strong>.</li>
        <li><code>delete</code> expresses “this variable no longer refers to this object” in a type-safe way;
          it is used as a safer alternative to assigning <code>null</code>.</li>
      </ul>

      <h3>8.2 Grammar</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile-time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After a <code>delete</code>, reading from that variable or doing member access / method calls on it
          is a compile-time error</strong>.</li>
        <li>However, it is allowed to assign a new value to the variable after deletion.
          Conceptually, <code>delete</code> returns the variable to an “uninitialized” state.</li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// use Buf
DoSomething(Buf);

delete Buf;

// After this, reading Buf or Buf.Length is a compile-time error.

Buf = NewBuffer();  // after reassignment, Buf is usable again</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>Decrement the reference count of the object currently referenced by <code>Var</code>
          (assuming a reference-counting model).</li>
        <li>Mark <code>Var</code> itself as “uninitialized / deleted”.</li>
        <li>If the object’s reference count reaches 0, the object will be freed at the discretion of the GC.<br />
          <strong>Thus, <code>delete</code> does not guarantee immediate destruction.</strong></li>
      </ul>

      <p class="note">
        In this language spec, the timing of object destruction is delegated to the VM/runtime.<br />
        <code>delete</code> merely removes one reference from the variable to the object.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>As stated in section 7.4, issuing <code>delete</code> on the variable targeted by <code>with</code>
          inside that <code>with</code> block is a compile-time error.</li>
        <li>It is allowed to <code>delete</code> another variable that refers to the same object;
          the object remains alive thanks to the <code>with</code> GC root.</li>
      </ul>

      <p class="note">
        In the future, if Aloe introduces “ownership-based resource types” or an ownership model,
        <code>delete</code> may be integrated with that model.<br />
        In this draft, we assume <strong>no ownership model</strong>.
      </p>
    </section>

    <section id="lock">
      <h2>9. lock Syntax and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> syntax acquires a lock on a specific object and guarantees
        exclusive access and optimized read barriers for that object during the block.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> acquires a lock on the object represented by <code>Expr</code>
          and guarantees exclusive access in <code>Body</code>.</li>
        <li>Lock acquire/release is implemented by the VM.</li>
        <li>Updates to data shared between threads should generally be contained within <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM assumes sliding compaction for memory management.<br />
        Inside a <code>lock</code> block, the VM may optimize read barriers and reduce per-object checks
        as much as possible.
      </p>
    </section>

    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown inside the <code>try</code> block can be caught by the corresponding <code>catch</code> block.</li>
        <li>The <code>finally</code> block is always executed regardless of whether an exception was thrown.</li>
        <li>The details of exception types and hierarchies are defined in the VM specification.</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. Execution Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode VM.</li>
        <li>Function calls push frames onto a call stack.</li>
        <li>GC is assumed to use reference counting + sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>GC runs when certain conditions are met, sliding live objects and compacting memory.</li>
        <li><code>with</code> acts as a temporary GC root that keeps objects alive, and
          in combination with <code>lock</code> allows for optimized read barriers.</li>
        <li>Normally you do not need to call <code>delete</code> for memory management.
          Use <code>delete</code> only when you explicitly want to drop a reference.</li>
      </ul>

      <p class="small">
        Detailed opcode lists and GC implementation details are provided in the AloeVM specification.
      </p>
    </section>

    <section id="limits">
      <h2>12. Limitations and Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>The expressive power of generics is minimal; typeclasses and higher-kinded generics are not defined.</li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>12.2 Future Work</h3>
      <ul>
        <li>Parallelization and fusion optimizations of Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm Component Model.</li>
        <li>Introducing Result-like types for error handling alongside exceptions.</li>
        <li>Extending the standard library for distributed processing and streaming.</li>
        <li>Integrating ownership-based resource types with <code>delete</code> where appropriate.</li>
        <li>Integrating traits / interfaces / sealed / readonly with pattern matching and exhaustiveness checks.</li>
      </ul>

      <p class="note">
        In this draft, the focus is on clarifying:<br />
        <strong>the relationships between Pipe / Filter and Producer / Transformer / Consumer / Pipe / Consumer</strong>,<br />
        and<br />
        <strong>the relationships between with / delete / lock / class inheritance / readonly / clone / generics
          and the AloeVM memory model</strong>.
      </p>
    </section>

  </main>
</div>
</body>
</html>

