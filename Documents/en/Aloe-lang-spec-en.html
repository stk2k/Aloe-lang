
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – pipe/filter/producer/consumer + delete/with/lock/class inheritance/generics/event)</title>
  <meta name="last-updated" content="2025-11-30T12:00:00+09:00" />
  <style>
    /* Minimal layout; leave fonts to browser defaults */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="tagline">Draft / Pipe, Filter, Producer, Consumer + delete/with/lock/class inheritance/generics/event</div>
    <div class="updated">Last updated: 2025-11-30 12:00:00</div>
    <nav>
      <div class="section-title">Overview</div>
      <a href="#intro">1. Introduction</a>
      <a href="#goals">2. Design Goals</a>

      <div class="section-title">Language Basics</div>
      <a href="#syntax">3. Basic Syntax</a>
      <a href="#types">4. Type System</a>
      <a href="#classes">4.5 Classes and Inheritance</a>
      <a href="#generics">4.6 Generics</a>
      <a href="#functions-methods">5. Functions and Methods</a>

      <div class="section-title">Pipes / Collections</div>
      <a href="#pipe-overview">6. Pipe / Filter Model</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; Type</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe-related Declarations</a>
      <a href="#pipe-operator">6.4 Pipe Operators <code>|</code> and <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 Standard Filters / Producers / Consumers / dump</a>

      <div class="section-title">Syntax Extensions</div>
      <a href="#with">7. with Syntax</a>
      <a href="#delete">8. delete Syntax</a>
      <a href="#lock">9. lock Syntax and Synchronization</a>

      <div class="section-title">Control / Runtime Model</div>
      <a href="#exceptions">10. Exception Handling</a>
      <a href="#runtime">11. Execution Model and Memory Management</a>

      <div class="section-title">Misc</div>
      <a href="#limits">12. Limitations and Future Work</a>

      <div class="section-title">Events</div>
      <a href="#event">13. event Syntax and Event Model</a>
    </nav>
  </aside>
  <main class="content">

    <!-- 1. Introduction -->
    <section id="intro">
      <h1>1. Introduction</h1>
      <p>
        Aloe is an experimental programming language with static typing, a simple syntax,
        and a stack-based virtual machine (AloeVM).
        It is especially designed for <strong>pipe / filter style data flow</strong>
        and good interoperability with WebAssembly.
      </p>
      <ul>
        <li>Statically typed (types are checked at compile time).</li>
        <li>C-like surface syntax, but an intentionally small feature set.</li>
        <li>Emphasis on expressing <br />“data flow and transformation” cleanly for text processing, REST calls, logging, etc.</li>
        <li>Designed with a stack-based VM (AloeVM) in mind, and with a future Wasm backend in sight.</li>
      </ul>
      <p class="note">
        This document is a <strong>draft of the language specification</strong>.<br />
        It may differ from the actual compiler / VM implementation.
      </p>
      <p class="note">
        An important design policy is that <strong>Aloe programs can be written without using delete/with/lock</strong>.<br />
        Normal code can be written using only pipes and mostly-immutable data structures, and
        races in concurrent execution are primarily avoided by the type system and pipeline design.
      </p>
    </section>

    <!-- 2. Design Goals -->
    <section id="goals">
      <h2>2. Design Goals</h2>

      <h3>2.1 Goals</h3>
      <ul>
        <li><strong>Readability</strong>: the specification itself should be readable as documentation.</li>
        <li><strong>Ease of implementation</strong>: a small compiler and VM should be sufficient.</li>
        <li><strong>Consistency of Pipe / Filter</strong>: type-safe data flow expression.</li>
        <li><strong>Bridge to Wasm</strong>: easy integration with the future Wasm component model.</li>
      </ul>

      <h3>2.2 Non-goals</h3>
      <ul>
        <li>Becoming a “do everything” general-purpose language.</li>
        <li>Competing with highly optimized JIT compilers on raw performance.</li>
        <li>Providing complex metaprogramming (Rust-like macros, etc.) at this stage.</li>
      </ul>
    </section>

    <!-- 3. Basic Syntax -->
    <section id="syntax">
      <h2>3. Basic Syntax</h2>

      <h3>3.1 Source Files</h3>
      <ul>
        <li>Source files are assumed to be UTF-8 encoded.</li>
        <li>Single-line comments: <code>// comment</code></li>
        <li>Multi-line comments: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 Tokens</h3>
      <ul>
        <li>Identifiers: first character is a letter or <code>_</code>, followed by letters, digits, or <code>_</code>.</li>
        <li>Keywords are reserved and cannot be used as identifiers.</li>
      </ul>

      <h3>3.3 Representative Keywords</h3>
      <table>
        <tr><th>Category</th><th>Keywords</th></tr>
        <tr>
          <td>Declarations</td>
          <td><code>let</code>, <code>var</code>, <code>function</code>, <code>method</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td>
        </tr>
        <tr>
          <td>Control</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td>
        </tr>
        <tr>
          <td>Auxiliary</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td>
        </tr>
      </table>

      <h3>3.4 Statements and Expressions</h3>
      <ul>
        <li>Most statements end with a semicolon <code>;</code>.</li>
        <li>Blocks are delimited by <code>{ ... }</code>.</li>
        <li>Conditions in control constructs must have type <code>Bool</code>.</li>
      </ul>

      <pre><code>// Variable declarations
let Threshold: Int = 10;
var Count: Int = 0;

// if statement
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <!-- 4. Type System -->
    <section id="types">
      <h2>4. Type System</h2>

      <h3>4.1 Primitive Types</h3>
      <table>
        <tr><th>Type</th><th>Description</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>Signed integer (bit-width is implementation-defined; assume 32-bit here).</td></tr>
        <tr><td><code>Float</code></td><td>Binary floating point (bit-width is implementation-defined).</td></tr>
        <tr><td><code>Decimal</code></td><td>Decimal floating point, mainly for amounts where rounding errors are sensitive (such as money). The internal representation and precision are implementation-defined, but the goal is to reduce rounding errors in decimal arithmetic.</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 string (internal representation is implementation-defined).</td></tr>
      </table>

      <h3>4.2 Arrays and Collections</h3>
      <ul>
        <li>Fixed-size array: <code>T[]</code></li>
        <li>For variable-sized and lazily evaluated sequences, <code>Pipe&lt;T&gt;</code> is used (see Chapter 6).</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> is a value type; assignment copies the value.</li>
        <li>The copy is shallow; sharing behavior for nested reference fields is VM-dependent.</li>
        <li>A struct may inherit from at most one other struct (single inheritance of structs).</li>
        <li>A struct is <strong>not allowed</strong> to implement <code>interface</code>.
          (How it participates in traits and generic constraints will be specified later.)</li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> is always represented internally as <strong><code>Int</code></strong>.</li>
        <li>“Generic enums” such as <code>enum&lt;String&gt;</code> or <code>enum&lt;Byte&gt;</code> are <strong>forbidden</strong>.</li>
        <li>Bitfield-style enums are limited to at most 32 flags.</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <!-- 4.5 Classes and Inheritance -->
    <section id="classes">
      <h2>4.5 Classes and Inheritance (class / interface / trait / sealed / readonly)</h2>

      <h3>4.5.1 Basic Properties of Classes</h3>
      <ul>
        <li><code>class</code> is always a <strong>heap-allocated reference type</strong>.</li>
        <li>Assignment copies the <strong>reference (shallow copy)</strong>.</li>
        <li>The <code>clone</code> keyword creates a shallow copy of the object and returns a new reference.</li>
        <li>All classes are <strong>cloneable</strong>. There is no way to declare a class as “non-cloneable” at the type level.<br />
          If cloning should be discouraged, it must be expressed via API design or coding conventions.</li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;

  method ToString(): String {
    return "User(Name=" + Name + ", Age=" + Age + ")";
  }

  method Dump(): String {
    // Default dump implementation (detailed rules are defined on Object)
    return ToString();
  }
}

var A: User = NewUser();
var B: User = A;        // reference copy (A and B point to the same instance)

var C: User = clone A;  // shallow-copied new instance</code></pre>

      <p class="note">
        A <strong>shallow copy</strong> means “copy field values as-is”.<br />
        If a field itself is a reference type, the reference value is copied.
        Types that need deep copy or custom clone logic can provide user-defined APIs such as a <code>Clone</code> method built on top of <code>clone</code>.
      </p>

      <h3>4.5.2 Class Inheritance (Single Inheritance)</h3>
      <p>
        Aloe <code>class</code> supports <strong>single inheritance</strong> only.<br />
        That is, a class can have exactly one base class.
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// The following is a compile error (multiple inheritance is forbidden)
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>The class hierarchy forms a tree (or chain); diamond inheritance does not occur.</li>
        <li>Class inheritance is a mechanism to reuse state and behavior.</li>
      </ul>

      <h3>4.5.3 interface and trait</h3>
      <p>
        Instead of allowing multiple inheritance of classes,
        Aloe uses <strong>interface</strong> and <strong>trait</strong> to compose behavior.
      </p>

      <ul>
        <li><code>interface</code> defines only method signatures, not implementations
          (whether default implementations are allowed is a separate design choice).</li>
        <li><code>trait</code> is a mixin with method implementations,
          used to add behavior to existing classes and structs.</li>
        <li>The only way to retroactively add methods to a type is via <strong>trait</strong>.<br />
          The <code>bound</code> syntax (similar to extension methods in other languages) is not introduced.</li>
        <li>A class can have <strong>one base class</strong>, implement multiple <code>interface</code>s,
          and apply multiple <code>trait</code>s.</li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose();
}

trait Printable {
  method PrintSelf() {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose() {
    // resource cleanup
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        Detailed rules for <code>interface</code> and <code>trait</code>
        (inheritance, conflict resolution when multiple traits define the same method, etc.)
        are not fully specified in this draft.
        The intent is only to show the direction here.
      </p>

      <h3>4.5.4 sealed Classes</h3>
      <p>
        Aloe provides the <code>sealed</code> modifier to prevent inheritance from a specific class.
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// Compile error (Token is sealed)
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li>A <code>sealed class</code> cannot be used as a base class.</li>
        <li>A <code>sealed</code> class may still implement interfaces and apply traits.</li>
        <li>In the future, we may combine sealed classes, unions, and pattern matching
          to support exhaustiveness checking.</li>
      </ul>

      <h3>4.5.5 readonly and Classes</h3>
      <ul>
        <li>Class fields are mutable by default.</li>
        <li>A field marked <code>readonly</code> is immutable:
          <ul>
            <li>Assignments to the field are allowed only in
              <strong>field initializers</strong> and
              <strong>constructors of the same class</strong>.</li>
            <li>Assignments from anywhere else are compile-time errors.</li>
          </ul>
        </li>
        <li><code>readonly class</code> makes the entire class logically immutable:
          <ul>
            <li>All instance fields are treated as if they were explicitly <code>readonly</code>.</li>
            <li>Assignments to fields are allowed only in field initializers and constructors of that class.</li>
            <li>After the constructor completes, no code may modify fields of that instance.</li>
          </ul>
        </li>
        <li><code>readonly</code> and <code>clone</code> are orthogonal:
          a <code>readonly class</code> can still be cloned with <code>clone</code>.
          The clone result is another instance with the same immutable state.</li>
      </ul>

      <p class="small">
        In summary, classes are heap-based reference types with single inheritance,
        behavior is composed via interface + trait, inheritance can be blocked by <code>sealed</code>,
        and immutability can be expressed at the field or class level with <code>readonly</code>. <br />
        Detailed rules for method resolution order and trait conflict resolution will be specified separately.
      </p>
    </section>

    <!-- 4.6 Generics -->
    <section id="generics">
      <h2>4.6 Generics</h2>

      <h3>4.6.1 Overview</h3>
      <p>
        Aloe provides a minimal generics mechanism for types, functions, methods, and pipe-related declarations.<br />
        The goal is to make collections and Pipe / Filter reusable in a type-safe manner,
        not to support advanced type-level computation.
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

function Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // implementation omitted
}</code></pre>

      <h3>4.6.2 Generic Type Parameters</h3>
      <ul>
        <li><code>type</code>, <code>struct</code>, <code>class</code>, <code>interface</code>, <code>trait</code>,
          <code>function</code>, <code>method</code>, and producer/filter/consumer declarations
          may take type parameters using <code>&lt;T, U, ...&gt;</code>.</li>
        <li>Type parameter names are recommended to start with uppercase letters
          (<code>T</code>, <code>TItem</code>, <code>TKey</code>, etc.).</li>
        <li>Type arguments are bound to concrete types at use sites.</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

function FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // implementation omitted
}</code></pre>

      <h3>4.6.3 where Type Constraints (Overview)</h3>
      <p>
        Aloe generics use a <code>where</code> clause to express type constraints.<br />
        By default, there is no constraint; version 0.1 supports a small set of basic constraints.
      </p>

      <pre><code>function Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int-only sum
}</code></pre>

      <p class="note">
        Here, <code>where</code> exists purely for <strong>compile-time type checking</strong>.<br />
        The runtime representation (monomorphization vs shared generic code with type tags, etc.) is up to the VM.
      </p>

      <h3>4.6.4 Supported Constraint Kinds</h3>
      <p>Version 0.1 supports the following constraint kinds:</p>

      <ul>
        <li><strong>Value-type / Reference-type constraints</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> must be a value type.</li>
            <li><code>where T: class</code> – <code>T</code> must be a reference type.</li>
          </ul>
        </li>
        <li><strong>Primitive type constraints</strong>
          <ul>
            <li>Constraints such as <code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code>
              allow referring to primitive types directly.</li>
          </ul>
        </li>
        <li><strong>User-defined type constraints</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – types implementing the trait <code>SomeTrait</code>.</li>
            <li><code>where T: MyStruct</code> – exactly the struct type <code>MyStruct</code>.</li>
            <li><code>where T: MyClass</code> – exactly the class type <code>MyClass</code>.</li>
          </ul>
        </li>
        <li><strong>Arbitrary concrete type names</strong>
          <ul>
            <li>Any existing concrete type name can be used (for example, <code>where T: Pipe&lt;Int&gt;</code>).</li>
          </ul>
        </li>
      </ul>

      <pre><code>// Generic function constrained to value types
function Zero&lt;T&gt;(): T
  where T: struct
{
  // implementation omitted
}

// Pipe specialized to Int
function Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // implementation omitted
}

// Generic restricted to a specific struct type
function PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // implementation omitted
}</code></pre>

      <h3>4.6.5 Behavior on Constraint Violation</h3>
      <ul>
        <li>If the type arguments supplied to a generic function/type do not satisfy the <code>where</code> constraints,
          it is a compile-time error.</li>
        <li>If multiple constraints are specified, all must be satisfied simultaneously.</li>
        <li>Cyclic constraints and advanced typeclass-like structures are not supported in this version.</li>
      </ul>

      <pre><code>// Example of compile error:

// where T: Int, so T cannot be String
function Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- compile error</code></pre>

      <p class="small">
        The internal representation of generics (monomorphization, type-tagged shared code, etc.) is defined by AloeVM.<br />
        This language spec focuses on type-safe reuse and <code>where</code>-based constraint checking.
      </p>
    </section>

    <!-- 5. Functions and Methods -->
    <section id="functions-methods">
      <h2>5. Functions and Methods</h2>

      <h3>5.1 function Declarations</h3>
      <pre><code>function Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>
      <ul>
        <li><code>function</code> declares a top-level function.</li>
        <li>Arguments are written as <code>Name: Type</code>.</li>
        <li>The return type is specified with <code>: Type</code> and cannot be omitted.</li>
        <li>The function body is a <code>{ ... }</code> block.</li>
        <li>The function body may contain zero or one <code>return</code> statement.<br />
          (Whether multiple returns are allowed is a design choice; version 0.1 recommends at most one.)</li>
      </ul>

      <h3>5.1.1 Entry Point main</h3>
      <pre><code>function main(): Int {
  // program entry point
  return 0;
}</code></pre>
      <ul>
        <li>A program must define exactly one <code>function main(): Int</code>.</li>
        <li><code>main</code> is treated as a normal <code>function</code>,
          but the VM treats it specially as the execution entry point.</li>
      </ul>

      <h3>5.2 method Declarations</h3>
      <pre><code>class Counter {
  Value: Int;

  method Increment(): Void {
    Value = Value + 1;
  }

  method Get(): Int {
    return Value;
  }
}</code></pre>
      <ul>
        <li><code>method</code> is used inside <code>struct</code>, <code>class</code>, <code>trait</code>, and <code>interface</code>.</li>
        <li>The signature (parameters and return type) follows the same rules as <code>function</code>.</li>
        <li>Async support and Task-returning methods are planned but not specified in detail here.</li>
      </ul>

      <h3>5.3 Function Types (Func&lt;...:...&gt;)</h3>
      <p>
        In Aloe, all function types are expressed using the <code>Func&lt;...:...&gt;</code> notation.
        Function types using any arrow symbol are not part of the language.
      </p>
      <ul>
        <li><code>Func&lt;T:U&gt;</code> denotes a function that takes an argument of type <code>T</code> and returns <code>U</code>.</li>
        <li><code>Func&lt;A, B:R&gt;</code> denotes a function that takes arguments <code>A</code> and <code>B</code>
          and returns <code>R</code>.</li>
        <li>A function that returns no value (void) is written as <code>Func&lt;T:&gt;</code> or <code>Func&lt;T:void&gt;</code>.</li>
      </ul>

      <pre><code>function Apply&lt;T, R&gt;(Value: T, F: Func&lt;T:R&gt;): R {
  return F(Value);
}</code></pre>
    </section>

    <!-- 6. Pipe / Filter -->
    <section id="pipe-overview">
      <h2>6. Pipe / Filter Model</h2>

      <p>
        A distinctive feature of Aloe is the ability to express
        <strong>pipe / filter style data flow</strong> in a type-safe and consistent way.
      </p>

      <pre><code>ReadLines("access.log")
  | Where (.StartsWith("[ERROR]"))
  | Map   (ParseLogLine)
  | Where (.Level == LogLevel.Error)
  | ToArray();</code></pre>

      <p>This is conceptually equivalent to the following nested calls:</p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p class="note">
        In Aloe, <strong>the only operator used for pipe expressions is <code>|</code></strong>.<br />
        <code>|&gt;</code> is just <strong>sugar for <code>| with</code></strong>,
        and the basic form of pipelines always uses <code>|</code>.
      </p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; Type</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> represents the “pipe world” in Aloe,
          corresponding to lazy sequences, streams, or iterators.
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> represents a pipe carrying elements of type <code>T</code>.</li>
          <li>The internal representation (chained iterators, coroutines, etc.) is VM-dependent.</li>
          <li>The standard library provides producers / transformers / consumers built on <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // implementation-dependent internal fields
}</code></pre>

        <p class="note">
          The <strong>pipe world</strong> refers to the space of functions that take and/or return <code>Pipe&lt;T&gt;</code>
          (producers / transformers / consumers).<br />
          Consumers are the exits from the pipe world.
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          In the Pipe / Filter model, functions and objects are classified into three roles:
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>Definition:</strong>
            functions/objects whose return type is <code>Pipe&lt;*&gt;</code> and which appear at the head of a pipeline.</li>
          <li><strong>Role:</strong>
            read from the external world (files, HTTP, arrays, etc.) and
            push data into the pipe world (<code>Pipe&lt;T&gt;</code>).</li>
          <li><strong>Type:</strong>
            usually of the form <code>Func&lt;X:Pipe&lt;T&gt;&gt;</code>.
            A producer is designed to always output a <code>Pipe&lt;*&gt;</code>.</li>
        </ul>

        <h4>6.2.2 Transformer (Intermediate Filter)</h4>
        <ul>
          <li><strong>Definition:</strong>
            functions/objects of type <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>.</li>
          <li><strong>Role:</strong>
            transform/filter/sort data inside the pipe world, without leaving it.</li>
        </ul>

        <h4>6.2.3 Consumer (Terminal Filter)</h4>
        <ul>
          <li><strong>Definition:</strong>
            functions/objects of type <code>Func&lt;Pipe&lt;T&gt;:R&gt;</code> where <code>R</code> is not <code>Pipe&lt;*&gt;</code>.</li>
          <li><strong>Role:</strong>
            act as exits from the pipe world, consuming the entire pipe and producing arrays, scalar values,
            or side effects in the external world.</li>
        </ul>
      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe-related Declarations (producer / pipe / filter / consumer)</h3>

        <p>
          Aloe introduces four declaration forms for building Pipe / Filter components:
          <strong>producer</strong>, <strong>pipe</strong>, <strong>filter</strong>, and <strong>consumer</strong>.<br />
          All of these are treated as “objects with constructors”; when connected into a pipeline,
          their <code>bound</code> blocks are executed by the VM.
          This specification only describes the shapes, leaving detailed VM behavior to AloeVM.
        </p>

        <h4>6.3.1 producer Declaration</h4>
        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;
  // runtime behavior is defined in the AloeVM spec
}</code></pre>

        <h4>6.3.2 pipe Declaration</h4>
        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;
}</code></pre>

        <h4>6.3.3 filter Declaration</h4>
        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;
}</code></pre>

        <h4>6.3.4 consumer Declaration</h4>
        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;
}</code></pre>

        <p class="note">
          In this draft, the exact syntax and execution rules for <code>bound</code> blocks of these declarations
          are delegated to the AloeVM specification. Here we only define the type-level relations and role separation.
        </p>
      </section>

      <section id="pipe-operator">
        <h3>6.4 Pipe Operators <code>|</code> and <code>|&gt;</code></h3>

        <h4>6.4.1 <code>|</code> Operator (Core of Pipe Expressions)</h4>
        <p>
          In Aloe, the <strong>core pipe operator is <code>|</code></strong>,
          defined as sugar for simple function composition.
        </p>

        <pre><code>Expr | F | G</code></pre>

        <p>is exactly equivalent to:</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li>If <code>F</code> has type <code>Func&lt;A:B&gt;</code> and <code>G</code> has type <code>Func&lt;B:C&gt;</code>,
            then <code>Expr | F | G</code> has type <code>C</code>.</li>
          <li>This operator is applicable to all types, not only <code>Pipe&lt;T&gt;</code>.</li>
        </ul>

        <h4>6.4.2 <code>|&gt;</code> Operator (<code>| with</code> Sugar)</h4>
        <p>
          <code>|&gt;</code> is defined as <strong>sugar for <code>| with</code></strong>.
          Concretely:
        </p>

        <pre><code>Expr |&gt; F</code></pre>
        <p>is equivalent to:</p>

        <pre><code>Expr | (with F)</code></pre>

        <p>
          Here, <code>with F</code> denotes applying <code>F</code> in a “with-block-like context”.
          At the language level, <code>|&gt;</code> is just stylistic sugar; the true pipe operator is always <code>|</code>.
        </p>

        <p class="warning">
          Although using <code>|&gt;</code> is allowed,
          we strongly recommend using <strong><code>|</code> as the main operator for pipe expressions</strong>.<br />
          The meaning of <code>|&gt;</code> may change in future versions.
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 Standard Filters / Producers / Consumers / dump</h3>

        <h4>6.5.1 Representative Transformers (Filters)</h4>
        <pre><code>// Where: filter elements by predicate
function Where&lt;T&gt;(Source: Pipe&lt;T&gt;, Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; {
  // library implementation
}

// Map: transform elements
function Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // library implementation
}</code></pre>

        <h4>6.5.2 Representative Producers</h4>
        <pre><code>function ReadLines(Path: String): Pipe&lt;String&gt; {
  // produce a pipe of lines from a file
}

function FromArray&lt;T&gt;(Items: T[]): Pipe&lt;T&gt; {
  // produce a pipe from an array
}</code></pre>

        <h4>6.5.3 Representative Consumers</h4>
        <pre><code>function ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] {
  // materialize a pipe into an array
}

function Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int {
  // count the number of elements
}</code></pre>

        <h4>6.5.4 dump Consumer and Dump Method</h4>
        <p>
          Aloe provides a built-in debugging consumer named <strong><code>dump</code></strong>.
        </p>

        <ul>
          <li><code>dump</code> is defined as a consumer that takes <code>Pipe&lt;T&gt;</code>
            and dumps the values in a human-friendly way.</li>
          <li>In addition, every object has a <strong><code>Dump</code> method</strong>
            (assumed to be defined on the base class <code>Object</code>).</li>
          <li><code>Expr | dump</code> calls <code>Dump</code> on each element when <code>Expr</code>
            has type <code>Pipe&lt;T&gt;</code>.</li>
          <li>If <code>Expr</code> is a single object, <code>Dump</code> is called once on that object.</li>
        </ul>

        <pre><code>// Pipe example
ReadLines("users.json")
  | Map (ParseUser)
  | dump;   // calls Dump on each User object

// Single-object example
var U: User = GetUser();
U.Dump();    // normal method call
// or
U | dump;    // treated as a single-element pipe and Dump is called</code></pre>

        <h4>6.5.5 Cycle Detection in Dump</h4>
        <p>
          The <code>Dump</code> specification requires that object graph cycles be detected
          to avoid infinite recursion.
        </p>
        <ul>
          <li>When traversing an object graph, Dumper records visited objects.</li>
          <li>If the same object is reached again, traversal below that point is skipped,
            and a marker such as “cycle detected” is output.</li>
          <li>For tree-shaped graphs, the traversal normally reaches all leaves.</li>
          <li>For collections (arrays, lists, maps, etc.), even if traversal for one element is cut off
            due to a cycle, <strong>dumping continues for the remaining elements</strong>.</li>
        </ul>

        <p class="note">
          The exact dump format (indentation, coloring, etc.) is implementation-defined.<br />
          This specification guarantees only that cycles are detected and not followed deeper,
          and that for collections, other elements continue to be processed.
        </p>
      </section>
    </section>

    <!-- 7. with Syntax -->
    <section id="with">
      <h2>7. with Syntax</h2>

      <h3>7.1 Overview</h3>
      <p>
        The <code>with</code> syntax is sugar for repeatedly accessing fields and methods
        on the same target object.<br />
        In Aloe, it also serves as a <strong>“lifetime lock”</strong>
        that keeps the object alive while the block is executing.
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 Semantics</h3>
      <p>
        The above <code>with</code> block is semantically equivalent to:
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> evaluates <code>Expr</code> <strong>exactly once</strong>.</li>
        <li>Simple identifier assignments in the block are interpreted as member accesses on the target object.</li>
      </ul>

      <h3>7.3 Lifetime Lock (GC Root Behavior)</h3>
      <p>
        AloeVM is assumed to use reference counting combined with sliding compaction for memory management.<br />
        Within this model, a <code>with</code> block acts as a “lifetime lock”:
      </p>
      <ul>
        <li>The result of <code>with (Expr)</code> is stored in a hidden variable that acts as a GC root.</li>
        <li>This hidden variable keeps the object alive until the block exits,
          guaranteeing that <strong>the object will not be collected during the block</strong>.</li>
        <li>Therefore, the object is guaranteed to be live while the block executes.</li>
      </ul>

      <h3>7.4 Relationship between with and delete</h3>
      <ul>
        <li>Deleting the same variable that is the target of <code>with</code> inside that <code>with</code> block
          is a compile-time error.</li>
        <li>The reason is that <code>with</code> expresses “this object should stay alive within this block”,
          while <code>delete</code> expresses the opposite intent.</li>
        <li>However, <code>delete</code> is allowed for <em>another variable</em>
          that refers to the same object as the with-target.<br />
          The <code>with</code> GC root still keeps the object alive.</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request is kept alive by with during this block

  delete Alias;   // OK: only removes the Alias reference
  Url = "https://example.com/api";  // still usable
}

// Upon leaving the with block, the GC root is removed.
// If no other references remain, the object may eventually be collected.</code></pre>

      <p class="note">
        In summary, <code>with</code> is both
        a <strong>“syntactic sugar for member access”</strong> and
        a <strong>“temporary GC root that keeps the target alive”</strong>.<br />
        To protect the same target with both lifetime and mutual exclusion,
        see Section 9.3 on <code>lock with</code>.
      </p>
    </section>

    <!-- 8. delete Syntax -->
    <section id="delete">
      <h2>8. delete Syntax</h2>

      <h3>8.1 Overview</h3>
      <p>
        In Aloe, <code>delete</code> <strong>does not directly destroy objects</strong>.<br />
        Instead, it is a construct to <strong>remove a reference from a variable</strong>.
      </p>
      <ul>
        <li>Actual object destruction (memory reclamation, finalization, etc.) is performed by
          the <strong>runtime (AloeVM)</strong> using reference counting and GC.</li>
        <li><code>delete</code> is a type-safe way to express
          “this variable no longer refers to that object”, acting as a replacement for assigning <code>null</code>.</li>
      </ul>

      <h3>8.2 Syntax</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 Static Rules (Compile Time)</h3>
      <ul>
        <li><code>Identifier</code> must be a variable declared in the current scope.</li>
        <li><strong>After <code>delete</code>, it is a compile-time error to read from that variable
          or to access members or methods through it.</strong></li>
        <li>However, assigning a new value to that variable is allowed.<br />
          Conceptually, <code>delete</code> returns the variable to an “uninitialized” state.</li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// use Buf
DoSomething(Buf);

delete Buf;

// Reading Buf or Buf.Length here is a compile error

Buf = NewBuffer();  // after re-assignment, Buf can be used again</code></pre>

      <h3>8.4 Runtime Semantics</h3>
      <p>
        When <code>delete Var;</code> is executed, the VM behaves roughly as follows:
      </p>
      <ul>
        <li>It decrements the reference count for the object currently referenced by <code>Var</code>.</li>
        <li><code>Var</code> itself is marked as “uninitialized / deleted”.</li>
        <li>If the object’s reference count drops to 0, the object is eventually destroyed at the GC’s discretion.<br />
          <strong>In other words, the object is not necessarily destroyed immediately at the moment of <code>delete</code>.</strong></li>
      </ul>

      <p class="note">
        This language specification leaves the exact timing of object destruction to the VM/runtime.<br />
        <code>delete</code> only removes one reference from a variable to an object.
      </p>

      <h3>8.5 Interaction with with</h3>
      <ul>
        <li>As described in Section 7.4, deleting the variable that is the target of a <code>with</code> block
          inside that block is a compile-time error.</li>
        <li>It is allowed to <code>delete</code> another variable that refers to the same object,
          because the GC root introduced by <code>with</code> still keeps the object alive.</li>
      </ul>

      <p class="note">
        If Aloe later introduces “owned resource types” or an ownership model,
        <code>delete</code> may be integrated with it.<br />
        In this draft, we assume <strong>no ownership model</strong>.
      </p>
    </section>

    <!-- 9. lock Syntax -->
    <section id="lock">
      <h2>9. lock Syntax and Synchronization</h2>

      <h3>9.1 Overview</h3>
      <p>
        The <code>lock</code> syntax acquires a lock on a specific object and
        guarantees exclusive access and optimized read barriers for that object during the block.
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 Semantics</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> acquires a lock on the object represented by <code>Expr</code>
          and guarantees exclusive access within <code>Body</code>.</li>
        <li>Lock acquisition and release are implemented by the VM.</li>
        <li>Updates to data shared between threads should generally be confined inside <code>lock</code> blocks.</li>
      </ul>

      <p class="note">
        AloeVM is assumed to use sliding compaction for memory management.<br />
        Inside <code>lock</code> blocks, the VM may optimize read barriers,
        reducing per-object checks as much as possible.
      </p>

      <h3>9.3 lock with Syntax (lock + with Composition)</h3>
      <p>
        For cases where you want both mutual exclusion and a lifetime lock (<code>with</code>)
        for the same target object, Aloe provides <code>lock with</code>.
      </p>

      <pre><code>lock with (Conn) {
  // Here:
  //   - Conn is protected by a lock
  //   - Conn is kept alive as a GC root by with
  //   - Members of Conn can be accessed without repeating Conn.
}</code></pre>

      <h4>9.3.1 Syntax</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <h4>9.3.2 Desugaring (Semantic Equivalent)</h4>
      <p>
        <code>lock with (Expr) { Body }</code> is semantically equivalent to:
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> is evaluated exactly once and the result is bound to a temporary <code>__tmp</code>.</li>
        <li>Then <code>lock</code> and <code>with</code> are applied to <code>__tmp</code> in a nested fashion.</li>
        <li>During <code>Body</code>:
          <ul>
            <li>Mutual exclusion is guaranteed for the target (semantics of <code>lock</code>).</li>
            <li>The target is kept alive as a GC root (semantics of <code>with</code>).</li>
            <li>Members of the target can be accessed with the same shorthand rules as in <code>with</code>.</li>
          </ul>
        </li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// After this point, the lock is released and the with-lifetime lock is also removed.</code></pre>
    </section>

    <!-- 10. Exception Handling -->
    <section id="exceptions">
      <h2>10. Exception Handling</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li>Exceptions thrown in a <code>try</code> block can be caught by <code>catch</code>.</li>
        <li>The <code>finally</code> block is always executed,
          regardless of whether an exception is thrown.</li>
        <li>The exact exception types and hierarchy are defined by the VM specification.</li>
      </ul>
    </section>

    <!-- 11. Execution Model -->
    <section id="runtime">
      <h2>11. Execution Model and Memory Management</h2>

      <h3>11.1 Overview of AloeVM</h3>
      <ul>
        <li>Stack-based bytecode VM.</li>
        <li>Function calls push frames onto a call stack.</li>
        <li>GC is assumed to use reference counting plus sliding compaction.</li>
      </ul>

      <h3>11.2 Memory Management (Overview)</h3>
      <ul>
        <li>Objects are allocated on the heap.</li>
        <li>When certain conditions are met, GC runs and compacts live objects.</li>
        <li><code>with</code> acts as a temporary GC root, keeping objects alive and,
          when combined with <code>lock</code>, allows optimizations of read barriers.</li>
        <li>Normally, you do not need to call <code>delete</code> for memory management.<br />
          Use <code>delete</code> only if you explicitly want to drop a reference from a variable.</li>
      </ul>

      <p class="small">
        Detailed opcode lists and GC internals are provided in the AloeVM specification.
      </p>
    </section>

    <!-- 12. Limitations -->
    <section id="limits">
      <h2>12. Limitations and Future Work</h2>

      <h3>12.1 Current Limitations</h3>
      <ul>
        <li>The expressiveness of generics is intentionally limited; typeclasses and advanced higher-kinded generics are not defined.</li>
        <li>The module system and package management are out of scope for this document.</li>
        <li>Metaprogramming (macros, reflection, etc.) is not defined.</li>
      </ul>

      <h3>12.2 Future Work</h3>
      <ul>
        <li>Parallelization and fusion optimizations for Pipe / Filter pipelines.</li>
        <li>Integration with the Wasm component model.</li>
        <li>Introducing Result-like types for error handling in addition to exceptions.</li>
        <li>Extending the standard library for distributed processing and streaming.</li>
        <li>Integrating <code>delete</code> with ownership-based resource types if introduced.</li>
        <li>Integrating trait / interface / sealed / readonly with pattern matching and exhaustiveness checks.</li>
      </ul>

      <p class="note">
        This draft focuses especially on:<br />
        <strong>Relations and declaration forms of Pipe / Filter, Producer / Transformer / Consumer / Pipe / Consumer</strong>, and<br />
        <strong>Connections between with / delete / lock / class inheritance / readonly / clone / generics and the AloeVM memory model</strong>.
      </p>
    </section>

    <!-- 13. event -->
    <section id="event">
      <h2>13. event Syntax and Event Model</h2>

      <h3>13.1 Purpose and Positioning</h3>
      <p>
        The <code>event</code> syntax in Aloe is used to express, at the language level,
        “this is a notification point where external code can register handlers.”
      </p>
      <ul>
        <li>External code can register and unregister event handlers (callbacks).</li>
        <li>Event raising (invoking handlers) is, in principle, only allowed on the declaring side.</li>
      </ul>
      <p>
        At the implementation level, <code>event</code> is treated as syntactic sugar
        for the standard library type <code>Event&lt;TArgs&gt;</code>.
      </p>
      <ul>
        <li><code>event Clicked&lt;ClickedArgs&gt;;</code> is equivalent to declaring
          a field of type <code>Event&lt;ClickedArgs&gt;</code>.</li>
        <li>However, unlike normal fields, external code cannot reassign this field
          or directly call <code>Raise</code> on it.</li>
      </ul>

      <h3>13.2 Event&lt;TArgs&gt; and Handler Type</h3>

      <h4>13.2.1 Handler Type</h4>
      <p>The event handler function type is defined as a standard type alias:</p>
      <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>
      <ul>
        <li>Argument: <code>TArgs</code> (the event argument type)</li>
        <li>Return type: <code>Task</code><br />
          Handlers are modeled as functions returning <code>Task</code> to naturally support asynchronous handlers.</li>
      </ul>

      <h4>13.2.2 Role of Event&lt;TArgs&gt; (Conceptual)</h4>
      <p>
        <code>Event&lt;TArgs&gt;</code> is a type that holds a collection of event handlers
        and the logic to invoke them.
        Conceptually, it can be written as:
      </p>
      <pre><code>type Event&lt;TArgs&gt; {
  Handlers: List&lt;EventHandler&lt;TArgs&gt;&gt;;
}

trait EventOperations&lt;TArgs&gt; {
  method Add(Handler: EventHandler&lt;TArgs&gt;): Task;
  method Remove(Handler: EventHandler&lt;TArgs&gt;): Task;
  method Raise(Args: TArgs): Task;
}</code></pre>

      <p class="note">
        In this language spec,
        <code>Event&lt;TArgs&gt;</code> is defined as the concrete holder of event handlers,
        and <code>event</code> syntax is a sugar on top of it with restricted access rules.
      </p>

      <h3>13.3 event Declaration Syntax</h3>

      <h4>13.3.1 Declaration Locations</h4>
      <p><code>event</code> may be declared in:</p>
      <ul>
        <li><code>struct</code> bodies</li>
        <li><code>class</code> bodies</li>
        <li><code>interface</code> bodies</li>
      </ul>
      <p>
        For version 0.1, event declarations at top level or inside <code>trait</code> are not defined.
      </p>

      <h4>13.3.2 Grammar (Overview)</h4>
      <pre><code>EventDeclaration ::=
    'event' Identifier '&lt;' Type '&gt;' ';'</code></pre>
      <p>Example:</p>
      <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>

      <p>
        This is semantically equivalent to declaring the following field:
      </p>
      <pre><code>struct Button {
  private Clicked: Event&lt;ClickedArgs&gt;;
}</code></pre>
      <p>With the following additional constraints:</p>
      <ul>
        <li>External code cannot reassign <code>Clicked</code> (compile-time error).</li>
        <li>External code cannot call <code>Clicked.Raise(...)</code> directly.</li>
        <li>External code cannot <code>delete Clicked;</code> either.</li>
      </ul>

      <h3>13.4 Event Subscription / Unsubscription (<code>+=</code> / <code>-=</code>)</h3>

      <h4>13.4.1 Grammar</h4>
      <pre><code>EventAddStatement    ::= PrimaryExpression '.' Identifier '+=' EventHandlerExpression ';'
EventRemoveStatement ::= PrimaryExpression '.' Identifier '-=' EventHandlerExpression ';'</code></pre>
      <ul>
        <li><code>PrimaryExpression.Identifier</code> must be an <code>event</code>-declared member.</li>
        <li><code>EventHandlerExpression</code> must be implicitly convertible to <code>Func&lt;TArgs:Task&gt;</code>.</li>
      </ul>

      <h4>13.4.2 Desugaring (Semantic Equivalent)</h4>
      <pre><code>Target.X += H;
// is equivalent to:
await Target.X.Add(H);

Target.X -= H;
// is equivalent to:
await Target.X.Remove(H);</code></pre>

      <h3>13.5 Raising Events and Rules</h3>

      <h4>13.5.1 Raise Allowed Only on Declaring Side</h4>
      <p>
        Calls to <code>Raise</code> on an <code>event</code>-declared member are only allowed from:
      </p>
      <ul>
        <li>Methods of the <code>struct</code> or <code>class</code> that declares the event.</li>
        <li>Methods in traits applied to the same type.</li>
      </ul>
      <p>
        Any call like <code>Clicked.Raise(...)</code> from other code (external modules or unrelated classes)
        is a compile-time error.
      </p>

      <h4>13.5.2 Example</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

trait ButtonImpl {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>

      <h3>13.6 Events on interface and Implementations</h3>
      <pre><code>interface IButton {
  event Clicked&lt;ClickedArgs&gt;;
}

struct Button implements IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        In this case, <code>Button</code> must declare a corresponding event to implement <code>IButton</code>.<br />
        If the event name or type arguments do not match, it is a compile-time error.
      </p>

      <h3>13.7 Example Usage</h3>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

function SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  Btn.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  Btn.Clicked += async (Args: ClickedArgs): Task {
    Log("button clicked");
  };
}</code></pre>

      <h3>13.8 Summary</h3>
      <ul>
        <li><code>event</code> provides syntax sugar and access control rules on top of <code>Event&lt;TArgs&gt;</code>.</li>
        <li>External code can only register and unregister handlers via <code>+=</code> / <code>-=</code>;
          it cannot raise the event or replace its underlying <code>Event&lt;TArgs&gt;</code> instance.</li>
        <li>Handlers use the unified type <code>Func&lt;TArgs:Task&gt;</code>,
          providing an asynchronous-first event model.</li>
        <li>Interfaces can declare <code>event</code>, making event contracts part of the type system.</li>
        <li>The design provides a similar feel to C# <code>event</code> without introducing separate
          <code>delegate</code> types into the language, reusing Aloe’s function types and <code>Task</code> instead.</li>
      </ul>
    </section>

  </main>
</div>
</body>
</html>

