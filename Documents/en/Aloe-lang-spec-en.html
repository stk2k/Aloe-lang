```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aloe Language Specification (Draft – pipe/filter/producer/consumer + delete/with/lock/class inheritance/generics/event/async)</title>
  <meta name="last-updated" content="2025-11-30T12:00:00+09:00" />
  <style>
    /* Minimal layout; leave fonts to browser defaults */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar p {
      margin: 0 0 0.75rem;
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      color: #d1d5db;
      text-decoration: none;
      padding: 0.2rem 0;
      white-space: nowrap;
    }
    .sidebar nav a:hover {
      color: #ffffff;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      box-sizing: border-box;
    }
    .content h1 {
      font-size: 1.6rem;
      margin-top: 0;
    }
    .content h2 {
      font-size: 1.3rem;
      margin-top: 2rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.25rem;
    }
    .content h3 {
      font-size: 1.1rem;
      margin-top: 1.4rem;
    }
    .content p {
      line-height: 1.6;
      margin: 0.4rem 0;
    }
    .content ul, .content ol {
      margin: 0.4rem 0 0.8rem 1.4rem;
    }
    code {
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.9rem;
      background: #f3f4f6;
      padding: 0.1rem 0.2rem;
      border-radius: 3px;
    }
    pre {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 0.75rem 0.9rem;
      overflow-x: auto;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0 1rem;
      width: 100%;
      max-width: 100%;
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 0.3rem 0.5rem;
      font-size: 0.9rem;
      text-align: left;
    }
    th {
      background: #f3f4f6;
    }
    .tag {
      display: inline-block;
      font-size: 0.75rem;
      background: #e5e7eb;
      color: #111827;
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      margin-right: 0.25rem;
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Aloe Language Specification</h1>
      <p>Draft / for design discussion</p>
      <nav>
        <a href="#overview">1. Overview</a>
        <a href="#goals">2. Design goals</a>
        <a href="#syntax">3. Basic syntax</a>
        <a href="#types">4. Type system</a>
        <a href="#pipe-filter">5. pipe/filter/producer/consumer</a>
        <a href="#collections">6. Collections and pipelines</a>
        <a href="#resource">7. Resource management (with / delete / lock)</a>
        <a href="#classes">8. Classes / struct / inheritance</a>
        <a href="#generics">9. Generics</a>
        <a href="#enums">10. enum and bit flags</a>
        <a href="#events">11. event and delegates</a>
        <a href="#pattern-union">12. Pattern matching and union</a>
        <a href="#async">13. Async (async/await and Task)</a>
        <a href="#future">14. Future work</a>
      </nav>
    </aside>
    <main class="content">
      <header>
        <h1 id="overview">1. Overview</h1>
        <p>
          Aloe is a small, simple, statically typed
          <span class="tag">pipe-oriented</span>
          language being designed together with a generative AI.
        </p>
        <p>
          Its primary goal is to make string/text processing, REST calls, and streaming
          pleasant to write using <code>pipe</code> and <code>filter</code>.
        </p>
        <ul>
          <li>Statically typed compiled language</li>
          <li>Stack-based VM and a bytecode format (AloeBC) designed with WebAssembly in mind</li>
          <li><code>pipe</code> / <code>filter</code> / <code>producer</code> / <code>consumer</code> as first-class features</li>
          <li>Safe scope-based memory/resource management via <code>with</code></li>
          <li>Support for class inheritance, generics, event, and async/await</li>
        </ul>
      </header>

      <section id="goals">
        <h2>2. Design goals</h2>
        <ul>
          <li><strong>Small and easy-to-remember syntax</strong>: keep grammar rules few and emphasize regularity.</li>
          <li><strong>Strong at text and I/O</strong>: standardize pipeline-based data transformations.</li>
          <li><strong>Clearly specified language behavior</strong>: avoid ambiguous behavior and define it at a spec level.</li>
          <li><strong>Good fit with Wasm</strong>: make it easy to host AloeVM on WebAssembly.</li>
          <li><strong>Reduce dependency on GC</strong>: ensure safety via <code>with</code> and resource management conventions.</li>
        </ul>
      </section>

      <section id="syntax">
        <h2>3. Basic syntax</h2>

        <h3>3.1 Comments</h3>
        <ul>
          <li><code>//</code> through the end of line is a comment.</li>
          <li>Block comments <code>/* ... */</code> may be added in the future.</li>
        </ul>

        <pre><code>// This is a single-line comment
method PrintHello(): Void {
  Print("Hello");
}</code></pre>

        <h3>3.2 Keywords</h3>
        <p>Major keywords (partial list):</p>
        <ul>
          <li><code>var</code> / <code>let</code> (variables / constants)</li>
          <li><code>method</code> (method definition)</li>
          <li><code>struct</code> / <code>class</code> / <code>union</code></li>
          <li><code>enum</code></li>
          <li><code>with</code> / <code>delete</code> / <code>lock</code></li>
          <li><code>pipe</code> / <code>filter</code> / <code>producer</code> / <code>consumer</code></li>
          <li><code>event</code></li>
          <li><code>await</code></li>
        </ul>

        <h3>3.3 Basic declaration forms</h3>

        <h4>Variables and constants</h4>
        <pre><code>var Count: Int = 0;       // Mutable
let Name: String = "Aloe"; // Immutable</code></pre>

        <h4>Methods</h4>
        <p>
          Methods are defined as <code>method Name(parameters): ReturnType</code>.
        </p>
        <pre><code>method Add(Left: Int, Right: Int): Int {
  return Left + Right;
}</code></pre>

        <h3>3.4 Blocks and scope</h3>
        <ul>
          <li><code>{ ... }</code> forms a block and a local scope.</li>
          <li><code>with</code> blocks are defined separately under “Resource management”.</li>
        </ul>
      </section>

      <section id="types">
        <h2>4. Type system</h2>

        <h3>4.1 Primitive types</h3>
        <ul>
          <li><code>Bool</code></li>
          <li><code>Int</code> (bit-width is defined in the VM spec)</li>
          <li><code>Float</code></li>
          <li><code>String</code></li>
          <li><code>Void</code> (used to mean “no return value”)</li>
        </ul>

        <h3>4.2 Arrays and collections</h3>
        <p>Representative container types:</p>
        <ul>
          <li><code>Array&lt;T&gt;</code></li>
          <li><code>List&lt;T&gt;</code></li>
        </ul>

        <h3>4.3 Function types</h3>
        <p>
          All function types are represented as <code>Func&lt;ArgTypes:ReturnType&gt;</code>.
        </p>

        <pre><code>var Callback: Func&lt;Int:String&gt;;                   // Takes Int, returns String
var AsyncCallback: Func&lt;String:Task&gt;;           // Takes String, returns Task
var AsyncWithResult: Func&lt;Int:Task&lt;String&gt;&gt;; // Takes Int, returns Task&lt;String&gt;</code></pre>

        <p>
          A function with no return value is written as <code>Func&lt;Args:Void&gt;</code>, or the
          return type may be omitted as a shorthand: <code>Func&lt;Args:&gt;</code>.
        </p>

        <h3>4.4 null and Option</h3>
        <p>
          To express presence/absence of a reference, an <code>Option&lt;T&gt;</code> type is planned.
          Details are not finalized yet.
        </p>
      </section>

      <section id="pipe-filter">
        <h2>5. pipe/filter/producer/consumer</h2>

        <h3>5.1 Core concept</h3>
        <p>
          At the core of Aloe is a stream-oriented
          <code>pipe</code> / <code>filter</code> model.
        </p>

        <ul>
          <li><span class="tag">producer</span>: generates data</li>
          <li><span class="tag">consumer</span>: consumes data</li>
          <li><span class="tag">filter</span>: transforms or filters elements in a stream</li>
        </ul>

        <h3>5.2 Pipe operator</h3>
        <p>
          Pipelines are connected with <code>|</code>.
        </p>

        <pre><code>var Lines: Array&lt;String&gt; =
  File.ReadLines("users.txt")
    | filter Trim()
    | filter Where(Name =&gt; Name != "")
    | filter ToArray();</code></pre>

        <p>
          Here <code>filter</code> is defined as syntactic sugar that registers per-element functions
          on a stream.
        </p>

        <h3>5.3 producer / consumer interfaces</h3>
        <p>Conceptually, the following two interfaces exist:</p>

        <pre><code>struct Producer&lt;T&gt; {
  method Next(): Option&lt;T&gt;;
}

struct Consumer&lt;T&gt; {
  method Push(Item: T): Void;
}</code></pre>

        <p>
          In the actual VM implementation, pipelines may be represented in an optimized form.
        </p>
      </section>

      <section id="collections">
        <h2>6. Collections and pipelines</h2>

        <h3>6.1 Collection pipelines</h3>
        <p>
          Collections are treated in a unified way with pipeline syntax.
        </p>

        <pre><code>var Numbers: Array&lt;Int&gt; = [1, 2, 3, 4, 5];

var Result: Array&lt;Int&gt; =
  Numbers
    | filter Where(X =&gt; X % 2 == 0)
    | filter Select(X =&gt; X * 10)
    | filter ToArray();</code></pre>

        <h3>6.2 Lazy vs eager</h3>
        <ul>
          <li>By default, pipelines are lazily evaluated streams.</li>
          <li>Operators like <code>ToArray</code> and <code>ToList</code> materialize actual data.</li>
        </ul>
      </section>

      <section id="resource">
        <h2>7. Resource management (with / delete / lock)</h2>

        <h3>7.1 with block</h3>
        <p>
          <code>with</code> guarantees that “the object is safely used inside the block, and is always
          cleaned up at the end of the scope.”
        </p>

        <pre><code>method UseFile(Path: String): Void {
  with File.Open(Path) as F {
    F.WriteLine("Hello");
  }
}</code></pre>

        <p>
          Types used with <code>with</code> must implement <code>Dispose</code> or an equivalent
          method that is called at the end of the scope.
        </p>

        <h3>7.2 delete</h3>
        <p>
          <code>delete</code> is reserved for explicit destruction of an object when needed.
        </p>

        <pre><code>var Buffer: ByteBuffer = ByteBuffer.Create(1024);
// use Buffer for something
delete Buffer; // any further use is a compile error or undefined behavior</code></pre>

        <h3>7.3 lock</h3>
        <p>
          <code>lock</code> is reserved as syntax for mutual exclusion.
        </p>

        <pre><code>lock Mutex {
  SharedState.Value = SharedState.Value + 1;
}</code></pre>
      </section>

      <section id="classes">
        <h2>8. Classes / struct / inheritance</h2>

        <h3>8.1 struct and class</h3>
        <ul>
          <li><code>struct</code> is a value type (copy semantics).</li>
          <li><code>class</code> is a reference type (reference semantics).</li>
        </ul>

        <pre><code>struct Point {
  var X: Int;
  var Y: Int;
}

class User {
  var Id: Int;
  var Name: String;
}</code></pre>

        <h3>8.2 Class inheritance</h3>
        <p>
          Classes support single inheritance. The syntax is <code>class Sub : Base</code>.
        </p>

        <pre><code>class Animal {
  method Speak(): Void { }
}

class Dog : Animal {
  override method Speak(): Void {
    Print("Bow");
  }
}</code></pre>

        <h3>8.3 Member naming style</h3>
        <ul>
          <li>Property and method names use <strong>PascalCase</strong> (starting with an uppercase letter).</li>
          <li>Local variables and parameters are recommended to use camelCase, but this is not enforced by the spec.</li>
        </ul>
      </section>

      <section id="generics">
        <h2>9. Generics</h2>

        <h3>9.1 Basics</h3>
        <pre><code>struct Result&lt;T&gt; {
  var Value: T;
  var IsOk: Bool;
}</code></pre>

        <h3>9.2 Generic methods</h3>
        <pre><code>method FirstOrDefault&lt;T&gt;(Items: Array&lt;T&gt;): Option&lt;T&gt; {
  if (Items.Length == 0) {
    return None;
  }
  return Some(Items[0]);
}</code></pre>
      </section>

      <section id="enums">
        <h2>10. enum and bit flags</h2>

        <h3>10.1 Basic enum</h3>
        <p>
          The underlying representation of an enum is fixed to <strong>Int</strong>, and it is
          not possible to specify another integral base type.
        </p>

        <pre><code>enum Color {
  Red = 0;
  Green = 1;
  Blue = 2;
}</code></pre>

        <h3>10.2 Bit-flag enums</h3>
        <p>
          Enums used as bit flags are limited to “at most 32 values”.
        </p>

        <pre><code>enum FileAccess {
  Read  = 0x1;
  Write = 0x2;
  Exec  = 0x4;
}</code></pre>
      </section>

      <section id="events">
        <h2>11. event and delegates</h2>

        <h3>11.1 Delegate types</h3>
        <p>
          Aloe does not have a dedicated <code>delegate</code> syntax; everything is expressed
          using <code>Func&lt;...:...&gt;</code>.
        </p>

        <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>

        <p>
          With this definition, the world is unified under the rule that “event handlers are all
          asynchronous and return <code>Task</code>”.
        </p>

        <h3>11.2 event declarations</h3>
        <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>

        <p>
          <code>event Name&lt;TArgs&gt;</code> is internally implemented as a collection of
          <code>EventHandler&lt;TArgs&gt;</code> values.
        </p>

        <h3>11.3 Subscribe and unsubscribe</h3>
        <pre><code>method Setup(ButtonInstance: Button): Task {
  ButtonInstance.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  // The exact syntax for removal is undecided (likely "-=").
}</code></pre>

        <h3>11.4 Behavior of Raise</h3>
        <p>
          <code>event</code> values are fired via a <code>Raise</code> method.<br />
          <code>Raise</code> itself returns a <code>Task</code> and internally <code>await</code>s
          the <code>Task</code> returned by each registered handler in sequence.
        </p>

        <pre><code>bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>
      </section>

      <section id="pattern-union">
        <h2>12. Pattern matching and union</h2>

        <h3>12.1 union types</h3>
        <p>
          A <code>union</code> expresses an “exclusive variant type”.
        </p>

        <pre><code>union Response {
  Ok(Value: String);
  NotFound();
  Error(Message: String);
}</code></pre>

        <h3>12.2 match expression (proposal)</h3>
        <p>
          Pattern matching on unions is written with a <code>match</code> expression.
        </p>

        <pre><code>method Handle(ResponseValue: Response): Void {
  match (ResponseValue) {
    Ok(Value) {
      Print("OK: " + Value);
    }
    NotFound() {
      Print("Not found");
    }
    Error(Message) {
      Print("Error: " + Message);
    }
  }
}</code></pre>

        <p>
          Exhaustiveness checking (whether all variants are covered) is performed at compile time.
        </p>
      </section>

      <section id="async">
        <h2>13. Async (async/await and Task)</h2>

        <h3>13.1 Basic policy</h3>
        <ul>
          <li>Async operations are represented by two types: <code>Task</code> and <code>Task&lt;T&gt;</code>.</li>
          <li>There is no dedicated <code>async</code> keyword for method declarations.</li>
          <li><code>await</code> is an expression that waits for completion of a <code>Task</code>-like value.</li>
        </ul>

        <pre><code>method DelayMs(Millis: Int): Task {
  // Implementation is provided by the runtime
}

method FetchUser(Name: String): Task&lt;User&gt; {
  // Asynchronously fetch a user
}</code></pre>

        <h3>13.2 Task and Task&lt;T&gt;</h3>
        <ul>
          <li><code>Task</code> represents an asynchronous operation with no result.</li>
          <li><code>Task&lt;T&gt;</code> represents an asynchronous operation returning a value of type <code>T</code>.</li>
        </ul>

        <h3>13.3 Type rules for await expressions</h3>
        <p>
          The type of <code>await Expr</code> depends on the type of <code>Expr</code>.
        </p>

        <table>
          <thead>
            <tr>
              <th>Type of Expr</th>
              <th>Type of await Expr</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Task&lt;T&gt;</code></td>
              <td><code>T</code></td>
            </tr>
            <tr>
              <td><code>Task</code></td>
              <td>No value (the result cannot be used in expressions)</td>
            </tr>
          </tbody>
        </table>

        <pre><code>var UserTask: Task&lt;User&gt; = FetchUser("Foo");
var U: User = await UserTask;  // await Task&lt;User&gt; yields a User

await DelayMs(1000);           // await Task yields no value</code></pre>

        <p>
          Assigning the result of <code>await</code> on a <code>Task</code> (non-generic) to a variable
          is a compile-time error.
        </p>

        <h3>13.4 Where await is allowed</h3>
        <p>
          <code>await</code> can only be used in the following contexts:
        </p>
        <ul>
          <li>Inside methods whose return type is <code>Task</code></li>
          <li>Inside methods whose return type is <code>Task&lt;T&gt;</code></li>
          <li>Inside lambdas whose type is <code>Func&lt;...:Task&gt;</code></li>
          <li>Inside lambdas whose type is <code>Func&lt;...:Task&lt;T&gt;&gt;</code></li>
        </ul>

        <pre><code>method Foo(): Task {
  await DelayMs(1000);            // OK
}

method Bar(): Task&lt;Int&gt; {
  let U: User = await FetchUser("Foo"); // OK
  return U.Id;
}

method Ng(): Int {
  await DelayMs(1000);            // Compile-time error
  return 1;
}</code></pre>

        <h3>13.5 Lambdas and await</h3>
        <p>
          In lambdas, <code>await</code> can be used when the lambda returns
          <code>Task</code> or <code>Task&lt;T&gt;</code> (i.e., its type is
          <code>Func&lt;Args:Task&gt;</code> or <code>Func&lt;Args:Task&lt;T&gt;&gt;</code>).
        </p>

        <pre><code>let Handler: Func&lt;ClickedArgs:Task&gt; =
  async (Args: ClickedArgs): Task {
    await DelayMs(500);
    Print("Clicked");
  };</code></pre>

        <p>
          Here <code>async</code> is a candidate keyword used as syntactic sugar to indicate that
          “this lambda returns <code>Task</code> or <code>Task&lt;T&gt;</code>”.
          Method definitions themselves do not need an <code>async</code> modifier.
        </p>

        <h3>13.6 Interaction with exception handling</h3>
        <p>
          If an exception occurred on the <code>Task</code> side while evaluating
          <code>await Expr</code>, that exception is re-thrown at the location of
          the <code>await</code>.
        </p>

        <pre><code>method UseAsync(): Task {
  try {
    let U: User = await FetchUser("Foo");
    Print(U.Name);
  } catch (Ex: Error) {
    LogError(Ex);
  }
}</code></pre>

        <h3>13.7 Integration with the event model</h3>
        <p>
          As mentioned earlier, the event handler type is defined as
          <code>EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;</code>.
          Therefore, it is natural to use <code>await</code> inside event handlers.
        </p>

        <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}

method SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  Btn.Clicked += async (Args: ClickedArgs): Task {
    await DelayMs(100);
    Print("Clicked: " + Args.ButtonId);
  };
}</code></pre>

        <p>
          <code>Clicked.Raise(Args)</code> returns a <code>Task</code> and internally
          <code>await</code>s the <code>Task</code> returned by each registered handler
          in sequence. This makes it natural to write code where “the side that fires an event
          waits for all handlers to complete”.
        </p>
      </section>

      <section id="future">
        <h2>14. Future work</h2>
        <ul>
          <li>Detailed design of Option types and null-safety</li>
          <li>Clarifying how far to use exceptions vs error-return types</li>
          <li>VM-level optimization of pipe/filter and Wasm support</li>
          <li>Aligning with the AloeBC (bytecode) specification</li>
          <li>Distributed execution and remote pipes (connecting streams across processes or nodes)</li>
        </ul>
      </section>
    </main>
  </div>
</body>
</html>
```
