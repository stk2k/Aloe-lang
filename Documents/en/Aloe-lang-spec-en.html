<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Aloe Language Specification (Draft, English Version)</title>
  <meta name="edit-version" content="5">
  <meta name="edit-date" content="2025-12-02T12:10:00+09:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- Sidebar -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • English version + with extension</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>Overview</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>Basic Syntax</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>Type System</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>Numbers &amp; Conversions</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>Blocks &amp; Scope</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>Variables &amp; Constants</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>Fields</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is Operator</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>Collections</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main Block</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>Temp Variable <code>_</code></a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap Keyword</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>Operators</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>Exceptions</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with blocks</a></li>
        <li><a href="#with-type">4.2.1 Type-based with</a></li>
      </ul>
    </nav>
  </aside>

  <!-- Main content -->
  <main class="content">
    <h1 id="top">Aloe Language Specification (Draft, English Version)</h1>
    <p class="note">
      This document is the English draft of the Aloe language specification.<br>
      The Japanese draft
      <code>https://stk2k.github.io/Aloe-lang/Documents/ja/Aloe-lang-spec-ja.html</code>
      is kept in sync with this document as much as possible.<br>
      On top of the original English spec, section <strong>4.2 with-blocks</strong> has been extended with
      a feature that allows <strong>type-based with on class / struct / enum (short-cut access to static
      members and enum values)</strong>.<br>
      Aside from that extension, the rest of the spec follows the original design as closely as possible.
    </p>

    <hr>

    <h2 id="ch0">0. Overview</h2>
    <p>
      Aloe is a statically-typed scripting language that aims for a simple and intuitive syntax.<br>
      It runs on a stack-based virtual machine (AloeVM) and has the following main goals:
    </p>
    <ul>
      <li>Easy to read and write for educational use and small applications</li>
      <li>Capable of running both on the C# runtime and in WebAssembly (WASM) environments</li>
      <li>Use <code>pipe</code> and <code>filter</code> to control I/O and concurrency while staying statically typed</li>
    </ul>
    <p>Characteristics:</p>
    <ul>
      <li>Static typing
        <ul>
          <li><code>var</code> for type inference</li>
          <li><code>let</code> for explicit type annotations</li>
        </ul>
      </li>
      <li>Value types / reference types
        <ul>
          <li><code>struct</code> … value types</li>
          <li><code>class</code> … reference types</li>
        </ul>
      </li>
      <li>GC-based memory management (exact algorithm is VM-implementation dependent)</li>
      <li>No direct <code>= null</code> in source code
        <ul>
          <li>Reference types can be null internally, but are handled via the sugar <code>delete</code>.</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> based, dataflow-style design</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax</h2>

    <h3>1.1 Comments</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> to the end of line is a line comment.</li>
      <li><code>/*</code> … <code>*/</code> is a multi-line comment.</li>
      <li>Nested <code>/* */</code> is undefined (assumed unsupported).</li>
    </ul>

    <h3>1.2 Identifiers</h3>
    <ul>
      <li>Allowed characters: letters (A–Z, a–z), digits (0–9), underscore <code>_</code>.</li>
      <li>The first character must be a letter or <code>_</code>.</li>
      <li>Case-sensitive.</li>
      <li>Identifiers may not use the same spelling as a keyword.</li>
      <li>Identifiers starting with <code>_</code> are treated as “private by convention” and should not be referenced from outside.</li>
      <li>Unicode characters can be used, excluding whitespace and punctuation separators.</li>
    </ul>

    <h3>1.3 Keywords</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
null
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
using
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> is not used; <code>namespace</code> is used instead.</li>
      <li><code>final</code> is removed; use <code>sealed</code> to forbid extension.</li>
      <li><code>instanceof</code> is removed; use <code>is</code> for type checking.</li>
    </ul>

    <h3>1.4 Literals</h3>
    <ul>
      <li>Integer literals: <code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code>, etc.</li>
      <li>Floating-point literals: <code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>Decimal literals: <code>10.12345678901234567890:d</code>, etc.</li>
      <li>Booleans: <code>true</code>, <code>false</code></li>
      <li>String: <code>"Hello, World!"</code></li>
      <li>Char: <code>'A'</code>, <code>'z'</code>, etc.</li>
      <li>null literal: <code>null</code></li>
      <li>Array literals: <code>[1, 2, 3]</code></li>
      <li>List literals: <code>(1, 2, 3)</code></li>
      <li>Set literals: <code>{1, 2, 3}</code></li>
      <li>Map literals: <code>["key1": 10, "key2": 20]</code></li>
      <li>enum literal: <code>EnumType.Value1</code></li>
      <li>struct literal: <code>Point { x: 0, y: 1 }</code></li>
      <li>Object creation: <code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>All statements end with a semicolon <code>;</code>.</li>
      <li>No automatic semicolon insertion based on newlines.</li>
    </ul>

    <h3>1.6 Whitespace</h3>
    <ul>
      <li>Spaces, tabs, and newlines are used as token separators.</li>
      <li>Consecutive whitespace is treated as a single separator.</li>
      <li>Indentation has no semantic meaning (unlike Python).</li>
    </ul>

    <h3>1.7 Case sensitivity</h3>
    <ul>
      <li>Identifiers and keywords are case-sensitive.</li>
      <li>All keywords are lowercase, except <code>Result</code>.</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System</h2>

    <h3>2.1 Primitive types</h3>
    <p>
      Aloe defines the following seven primitive types:
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – boolean values.</li>
      <li><code>int</code> / <code>integer</code> – signed integers.</li>
      <li><code>float</code> – floating-point numbers.</li>
      <li><code>decimal</code> – high-precision decimal numbers.</li>
      <li><code>string</code> – strings (internally Unicode).</li>
      <li><code>null</code> – a special type and value representing “no value”.</li>
      <li><code>void</code> – “no return value” (for method return types only).</li>
    </ul>
    <p>
      There is no <code>any</code> type; dynamic typing is not supported.<br>
      <code>char</code> and <code>byte</code> are supported by the language,
      but are treated as separate numeric value types discussed in chapter 3.
    </p>

    <h3>2.2 Composite / user-defined types</h3>
    <ul>
      <li>Array: <code>T[]</code></li>
      <li>List: <code>T()</code></li>
      <li>Set: <code>T{}</code></li>
      <li>Map: <code>map&lt;T&gt;</code> or <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>Asynchronous task: <code>task</code></li>
      <li>Pipe: <code>pipe&lt;T&gt;</code> (see chapter 18)</li>
      <li>Result type: <code>Result&lt;T&gt;</code> (see chapter 18)</li>
    </ul>
    <p>There is no <code>any</code> type; dynamic typing is not supported.</p>

    <h3>2.3 Value types / reference types</h3>
    <ul>
      <li>Value types:
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code> (internally int32)</li>
        </ul>
      </li>
      <li>Reference types:
        <ul>
          <li><code>class</code></li>
          <li><code>string</code> (implemented as a reference type)</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, etc.</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying</h4>
    <ul>
      <li>Fields of a struct may only be primitive types or other structs.</li>
      <li>Structs cannot have fields of reference types such as class.</li>
      <li>Assignment of a struct always copies its value.</li>
      <li>No explicit maximum size restriction is defined in the spec.</li>
    </ul>

    <h4>Class vs struct</h4>
    <ul>
      <li>A class can have struct fields.</li>
      <li>Assigning a class instance to another variable copies the reference; the object itself is shared.</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li>Expressions mixing <code>int</code> and <code>float</code> yield a <code>float</code> result:
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> is a high-precision base-10 number type.</li>
      <li>Expressions mixing <code>decimal</code> with <code>int</code> / <code>float</code>
          may be promoted to <code>decimal</code> when necessary.</li>
      <li>Overflow / underflow / precision failures are represented as <code>OverflowException</code>.</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe has no cast syntax.</li>
      <li>Both implicit and explicit conversions between enum and int are forbidden.</li>
      <li>Expressions that mix enum and numeric types are compile errors (except bit operations on bitfield enum).</li>
      <li>Internally, both enum and bitfield enum are represented as int32.</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>:
        <ul>
          <li>Range is 0–255.</li>
          <li>Operations between bytes are allowed but may overflow.</li>
          <li>Expressions mixing byte and int are promoted to int.</li>
        </ul>
      </li>
      <li><code>char</code>:
        <ul>
          <li>Arithmetic operations on char are not allowed.</li>
          <li>Comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.) are allowed only between chars.</li>
          <li>No implicit conversions between char and numeric types.</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>Numeric overflow/underflow are handled via exceptions, not NaN/Infinity.</li>
      <li><code>ZeroDivisionException</code> is thrown on division by zero (including <code>0 / 0.0</code>).</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope</h2>

    <p>
      Blocks are delimited by <code>{</code> and <code>}</code>, and each block introduces a new scope.
    </p>
    <ul>
      <li><code>main</code> block</li>
      <li>Class definition blocks</li>
      <li>Method definition blocks</li>
      <li>Arbitrary <code>{ ... }</code> blocks</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // shadows the field
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe uses static (lexical) scoping.</li>
      <li>A variable with the same name declared in an inner block shadows the outer variable.</li>
      <li>If a field name conflicts with a local variable name, the local variable wins.
        Use <code>this.</code> to reference the field.</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks (member access shorthand)</h3>
    <p>
      Aloe provides <code>with</code> blocks to simplify repetitive member access on the same object.
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li>Inside <code>with (expr) { ... }</code>:
        <ul>
          <li><code>.Member</code> is a shorthand for <code>(expr).Member</code>.</li>
          <li><code>expr</code> is evaluated only once at the beginning of the block
              and stored in an internal temporary variable.</li>
          <li>The special temporary variable <code>_</code> refers to the “with target object”.
            <ul>
              <li>For example, you can pass it as <code>log(_);</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Nested <code>with</code> blocks:
        <ul>
          <li>The inner <code>with</code> shadows the meaning of <code>.</code> and <code>_</code>.</li>
          <li>You can still access outer objects via their normal variable names.</li>
        </ul>
      </li>
      <li>Multiple <code>with</code> targets in the same header, similar to C# <code>using</code>:
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>The resolution order of which object provides the member is implementation dependent.</li>
      <li>If a member is found on multiple objects and the resolution becomes ambiguous, it is a compile error.</li>
    </ul>
    <p>
      <code>with</code> is purely syntactic sugar; semantically it can be desugared to
      explicit <code>obj.member</code> calls before type checking and code generation.
      A <code>with</code> block does <strong>not</strong> manage resources; it only guarantees
      the lexical lifetime of the bound object.
    </p>

    <h4 id="with-type">4.2.1 Type-based with (static / enum shortcuts for class / struct / enum)</h4>
    <p>
      In addition to the normal <code>with (expr)</code>, Aloe allows using a <strong>type name</strong>
      as the with target.
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>Here <code>TypeName</code> must be one of:</p>
    <ul>
      <li>a <code>class</code> type</li>
      <li>a <code>struct</code> type</li>
      <li>an <code>enum</code> or <code>bitfield enum</code></li>
    </ul>
    <p>In this case, the with is interpreted as a “type-context with”:</p>
    <ul>
      <li>The expression inside <code>()</code> is <strong>not</strong> evaluated as a runtime value.
        <ul>
          <li>The compiler resolves <code>TypeName</code> as a type; no instance is created.</li>
        </ul>
      </li>
      <li>Inside the block:
        <ul>
          <li><code>.Member</code> is a shorthand for <code>TypeName.Member</code>.
            <ul>
              <li>Valid <code>Member</code> targets are:
                <ul>
                  <li>static fields</li>
                  <li>static methods</li>
                  <li>enum / bitfield enum values</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>The temporary variable <code>_</code> behaves as a pseudo object representing
              the static context of <code>TypeName</code>.
            <ul>
              <li><code>_.Member</code> is also equivalent to <code>TypeName.Member</code>.</li>
            </ul>
          </li>
          <li>Accessing instance members inside a type-based with is a compile error.</li>
        </ul>
      </li>
    </ul>
    <p>
      Even in a type-based with, local variables or outer-scope variables with the same name
      take precedence. To explicitly refer to enum values or static members, use
      <code>TypeName.Member</code>, <code>.Member</code>, or <code>_.Member</code>.
    </p>

    <h5>Example: static access on class / struct</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
    return 0;
}
</code></pre>

    <h5>Example: enum value access</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      Type-based <code>with</code> can be mixed with instance-based targets:
    </p>
<pre><code>with (user), (Color) {
    .name = "Alice"; // user.name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      As with multiple-instance with, if resolution becomes ambiguous, it is a compile error.
    </p>

    <h3 id="using-blocks">4.3 using blocks (resource management)</h3>
    <p>
      Aloe also provides <code>using</code> blocks for deterministic resource management.
      A using block guarantees that a resource's <code>Dispose()</code> method is called
      exactly once when leaving the block, regardless of how the block is exited (normal flow
      or via exceptions).
    </p>
<pre><code>using (res) {
    res.DoWork();
} // res.Dispose() is called automatically here
</code></pre>
    <ul>
      <li><code>using (expr) { ... }</code> evaluates <code>expr</code> once at the beginning of the block.</li>
      <li>The result must be an object that exposes a parameterless <code>Dispose(): void</code> method
          (the concrete interface or trait is defined at the runtime / library level).</li>
      <li>When control leaves the block for any reason, <code>Dispose()</code> is invoked exactly once
          on that object.</li>
      <li>After the block, the resource is out of scope like any other local variable.</li>
    </ul>
    <p>
      Conceptually, a <code>using</code> block is similar to a <code>try/finally</code>:
    </p>
<pre><code>using (res) {
    // body
}

// is roughly equivalent to

let res = expr;
try {
    // body
}
finally {
    if (res is not null) {
        res.Dispose();
    }
}
</code></pre>
    <p>
      Unlike <code>with</code>, which only shortens member access and guarantees lexical lifetime,
      <code>using</code> explicitly guarantees that cleanup logic (<code>Dispose</code>) runs on block exit.
      A resource may be used in a <code>with</code> block, a <code>using</code> block, or both, but
      resource management behavior is defined only by <code>using</code>.
    </p>

    <h4>4.3.1 Multiple using targets</h4>
    <p>
      A <code>using</code> header can list multiple targets, similar to C#:
    </p>
<pre><code>using (file), (connection) {
    // use file and connection
}
</code></pre>
    <p>
      This is syntactic sugar for nested using blocks:
    </p>
<pre><code>using (file) {
    using (connection) {
        // use file and connection
    }
}
</code></pre>
    <p>
      Therefore, <code>Dispose()</code> is called on each resource, typically in the reverse order
      in which they appear in the header (as in the nested form above).
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants</h2>

    <h3>5.1 var (type inference)</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>The type of a variable is inferred from the expression on the right-hand side.</li>
      <li><code>var x = 1;</code> is always <code>int</code>.</li>
      <li><code>var x = 1.0;</code> is treated as <code>float</code>.</li>
      <li><code>var x = null;</code> is a compile error (the type cannot be inferred).</li>
    </ul>

    <h3>5.2 let (explicit type)</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants (const)</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> variables cannot be reassigned.</li>
      <li><code>const</code> requires an explicit type annotation.</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields</h2>
    <p>Fields of class / struct are declared with the <code>field</code> keyword.</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: inside the constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … regular field.</li>
      <li><code>readonly field</code> … assignable only inside the constructor; read-only afterwards.</li>
      <li>Same semantics for struct and class.</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class is a reference type.</li>
      <li><code>sealed class</code> cannot be extended via <code>extends</code>.</li>
      <li>Only single inheritance is supported.</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>struct is a value type.</li>
      <li>Fields must be primitive types or other structs (no reference-type fields allowed).</li>
      <li>Struct copy is always by value.</li>
      <li>Struct inheritance is not supported
          (<code>sealed struct</code> is just a “no further extension” marker).</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li>Use <code>implements</code> to implement an interface.</li>
      <li>Use <code>is</code> operator to check if a value implements an interface.</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>Applying trait via with</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // hello from Trait_A, if no conflicts exist
</code></pre>

    <h4>Non-destructive add/remove (+ / -)</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj stays as is; obj2 has Trait_A applied
var obj3 = obj2 - Trait_A;     // obj3 is obj2 without Trait_A
</code></pre>

    <h4>Alias via as</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: member is not flattened; use alias
</code></pre>

    <h4>Trait conflicts</h4>
    <ul>
      <li>If multiple traits define a field / method with the same name, it is a compile error.</li>
      <li>Applications with aliases such as <code>as a</code> are excluded from conflict checks.</li>
      <li>How conflicts between class body and trait members are resolved is reserved for a future version.</li>
    </ul>

    <h3>7.6 abstract / virtual / override</h3>
    <p>
      To express polymorphism in inheritance hierarchies, Aloe uses
      the three keywords <code>abstract</code>, <code>virtual</code>, and <code>override</code>.
    </p>

    <h4>abstract class / abstract method</h4>
<pre><code>abstract class Animal {
    method SayName(): void {
        print("Unknown");
    }

    abstract method Speak(): void; // abstract method without body
}
</code></pre>
    <ul>
      <li>If <code>abstract</code> appears before a class, that class is abstract.</li>
      <li>Abstract classes cannot be instantiated directly (<code>new Animal()</code> is a compile error).</li>
      <li><code>abstract method</code> declares a method without a body.</li>
      <li>A class that has any abstract methods must itself be declared as <code>abstract class</code>.</li>
    </ul>

<pre><code>class Dog extends Animal {
    override method Speak(): void {
        print("Bowwow");
    }
}
</code></pre>
    <ul>
      <li>Concrete (non-abstract) classes must implement all inherited abstract methods with <code>override</code>.</li>
    </ul>

    <h4>virtual method and override</h4>
<pre><code>class BaseLogger {
    virtual method Log(message: string): void {
        print("[Base] " + message);
    }
}

class FileLogger extends BaseLogger {
    override method Log(message: string): void {
        print("[File] " + message);
    }
}
</code></pre>
    <ul>
      <li><code>virtual</code> marks a method that can be overridden in derived classes using <code>override</code>.</li>
      <li>A virtual method has a body (unlike an abstract method).</li>
      <li>When overriding, <code>override</code> must be specified in the derived class.</li>
      <li>The signature (name, parameters, return type) of an override must match the base virtual/abstract method.</li>
      <li>If there is no corresponding virtual/abstract method in any base class, using <code>override</code> is a compile error.</li>
    </ul>

    <h4>Call behavior</h4>
<pre><code>BaseLogger logger = new FileLogger();
logger.Log("Hello");  // FileLogger.Log is called (virtual dispatch)

FileLogger fl = new FileLogger();
fl.Log("Hello");      // FileLogger.Log is called
</code></pre>
    <ul>
      <li>virtual/override methods are dispatched based on the runtime type, not the static type.</li>
      <li>To call the base implementation explicitly, a syntax such as <code>super.Log(...)</code>
          (planned future extension) is used.</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> is equivalent to <code>obj = null</code> at the VM level.</li>
      <li>You cannot write <code>obj = null;</code> directly in source code.</li>
      <li>Reference types may internally be null, but the type system does not track nullability.</li>
      <li>Accessing members on a null reference may cause <code>NullReferenceException</code>.</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> performs runtime type checks.</li>
      <li>Inheritance is taken into account (Derived is also a Base).</li>
      <li><code>is</code> also works with interfaces and traits.</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections (Array / List / Set / Map)</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // map&lt;int&gt; is an alias of map&lt;string/int&gt;
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>Internal representation is always int32.</li>
      <li>Changing the underlying type (e.g. <code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code>) is not allowed.</li>
      <li>Enums can be used as targets of type-based with;
          <code>with (Color) { Red; }</code> allows short access to its values.</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) notation</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> represents bit n (<code>1 &lt;&lt; n</code>).</li>
      <li><code>Name : b(n)</code> assigns bit n to that enum value.</li>
      <li>A <code>bitfield enum</code> may use up to 32 bits (n = 0–31).</li>
      <li>Multiple values sharing the same bit is allowed; the compiler may only warn, not fail.</li>
      <li>The underlying type is always int32;
          <code>bitfield enum&lt;byte&gt;</code> and similar are compile errors.</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block (Entry Point)</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0; // process exit code
}
</code></pre>
    <ul>
      <li>This is the program entry point.</li>
      <li><code>args</code> is the command-line argument array.</li>
      <li>The <code>main</code> block must be declared as
          <code>function main(args: string[]): int</code> and
          must return an <code>int</code> via a <code>return</code> statement.</li>
      <li>There is no special meaning for <code>_</code> in main; it is just a regular local variable name there.</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code></h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;   // treated as a normal local variable here
    return 0;
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // the type of _ becomes the type of this first assignment in this block
}
</code></pre>
    <ul>
      <li><code>_</code> can be used as a special temporary variable in any block without declaration.</li>
      <li>In main, it has no special meaning and behaves like an ordinary local variable.</li>
      <li>In non-main blocks, the type of <code>_</code> is inferred from the expression of the first assignment in that block.</li>
      <li>Inside a <code>with</code> block, <code>_</code> additionally refers to the current with target object (see 4.2).</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> swaps the values (or references) of <code>x</code> and <code>y</code>.</li>
      <li>Whether swapping is valid is checked at compile time.</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators</h2>

    <h3>15.1 Precedence (from highest)</h3>
    <ol>
      <li>Member / call: <code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>Unary: <code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>Multiply/divide: <code>*</code>, <code>/</code>, <code>%</code></li>
      <li>Add/subtract: <code>+</code>, <code>-</code></li>
      <li>Shift: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>Relational: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>Equality: <code>==</code>, <code>!=</code></li>
      <li>Bitwise AND: <code>&amp;</code></li>
      <li>Bitwise XOR: <code>^</code></li>
      <li>Bitwise OR: <code>|</code> (different meaning in pipeline statements)</li>
      <li>Logical AND: <code>&amp;&amp;</code> (alias: <code>and</code>)</li>
      <li>Logical OR: <code>||</code> (alias: <code>or</code>)</li>
      <li>Assignment: <code>=</code></li>
    </ol>
    <p>Compound assignments such as <code>+=</code> are not yet specified.</p>

    <h3>15.2 Associativity</h3>
    <ul>
      <li>Unary operators: right-associative.</li>
      <li>Assignment: right-associative.</li>
      <li>All other binary operators: left-associative.</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 Overview of standard exceptions</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> covers both overflow and underflow.</li>
      <li><code>ZeroDivisionException</code> is thrown on division by zero (<code>0 / 0.0</code> etc.).</li>
      <li>Parsing and formatting errors use <code>FormatException</code>.</li>
      <li><code>InvalidOperationException</code> is used for invalid state operations
          (for example, accessing a property of <code>Result</code> that does not match its current state).</li>
      <li>Other fatal VM-level errors are implementation-dependent.</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> defines a logical namespace.</li>
      <li><code>import</code> introduces references to other namespaces and symbols.</li>
      <li>File layout and handling of circular imports are defined in the module specification.</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters</h2>

    <p>
      Aloe uses <code>pipe&lt;T&gt;</code> and <code>filter(...)</code> to construct streaming
      processing for servers, CLI tools, and web applications.
    </p>

    <h3>18.1 Basics of pipe&lt;T&gt;</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> represents a stream of elements of type <code>T</code>.</li>
      <li><code>pipe&lt;byte&gt;</code> … byte streams such as standard input or sockets.</li>
      <li><code>pipe&lt;string&gt;</code> … string streams.</li>
      <li>Pipes assume value copying instead of shared mutable memory.</li>
    </ul>

    <h4>18.1.1 Built-in pipes</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code> (optional)</li>
    </ul>

    <h3>18.2 Result&lt;T&gt; and the outline of ROP (Railway Oriented Programming)</h3>
    <p>
      In Aloe, error handling and branching in pipelines and filters are expressed using the
      <strong>Result&lt;T&gt;</strong> type and the ideas from
      <strong>Railway Oriented Programming (ROP)</strong>.
    </p>
    <ul>
      <li><code>Result&lt;T&gt;</code> is a built-in generic type that represents either
          “success (Success = true)” or “failure (Success = false)”.</li>
      <li>Filters and pipes typically return <code>Result&lt;T&gt;</code> to explicitly encode
          success or failure.</li>
    </ul>

    <h4>18.2.1 Type outline for Result&lt;T&gt;</h4>
<pre><code>// Conceptual sketch in pseudo-code (syntax TBD)
class Result&lt;T&gt; {
    // State:
    // When Success == true: Value is valid.
    // When Success == false: ErrorMessage is valid.
    field Success: bool;
    field Value: T;
    field ErrorMessage: string;

    // Factory methods (built-in)
    static method Ok(value: T): Result&lt;T&gt;;
    static method Error(message: string): Result&lt;T&gt;;
}
</code></pre>
    <ul>
      <li>When <code>Success</code> is <code>true</code>:
        <ul>
          <li><code>Value</code> holds a valid result.</li>
          <li><code>ErrorMessage</code> is implementation-dependent (often empty), but reading it is allowed.</li>
        </ul>
      </li>
      <li>When <code>Success</code> is <code>false</code>:
        <ul>
          <li><code>ErrorMessage</code> contains an error message (or a part of it).</li>
          <li><code>Value</code> must be treated as “no value”; reading it is an invalid operation.</li>
        </ul>
      </li>
      <li>Accessing properties inconsistent with the state (for example, reading <code>Value</code> when
          <code>Success == false</code>) throws <code>InvalidOperationException</code> at runtime
          (the compiler may also detect some of these cases statically).</li>
      <li>For <code>Result&lt;void&gt;</code>, a parameterless
          <code>Result&lt;void&gt;.Ok()</code> is allowed to represent a successful operation with no value:
        <ul>
          <li><code>Success == true</code>, and <code>ErrorMessage</code> is usually empty.</li>
          <li>Reading <code>Value</code> on <code>Result&lt;void&gt;</code> is always invalid and throws <code>InvalidOperationException</code>.</li>
        </ul>
      </li>
    </ul>
    <p>
      The above is a logical model; actual field names and implementation details may be slightly adjusted
      in the VM/runtime specification. The core contract that “only state-consistent properties may be
      accessed” is guaranteed by the language spec.
    </p>

    <h4>18.2.2 Intuition of ROP (Railway Oriented Programming)</h4>
    <p>
      ROP imagines “success rails” and “failure rails” running side-by-side. Each step (filter) returns
      a <code>Result&lt;T&gt;</code>; once an error occurs, the pipeline switches over to the failure rail
      and subsequent success steps are skipped.
    </p>
<pre><code>Input
  ├─&gt; [ Filter A ] ──&gt; [ Filter B ] ──&gt; [ Filter C ] ──&gt; Output
  │         │               │               │
  │         └─&gt; Error ──────┴───────────────┴───&gt; Error path
  │
  └─&gt; (other branches such as logging)
</code></pre>
    <p>
      Filters in Aloe should aim to limit side effects and to be “quasi-idempotent”:
      given the same input, they should prefer to return the same output.
    </p>

    <h3>18.3 Basics of filter(...) and filter definitions</h3>
    <p><code>filter(F)</code> represents an intermediate transformation stage in a pipeline.</p>

    <h4>18.3.1 Defining filters (filter definition)</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // Type for options (optional)
    options: LineSplitOptions;

    // Field definitions (optional, but should be minimal for side-effect reasons)
    field _buffer: string = "";

    // Constructor (optional)
    constructor(opts: LineSplitOptions) {
        // initialize depending on options, etc.
    }

    // Body that processes input pipe to output pipe
    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Result&lt;void&gt;.Ok(); // indicates successful completion
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> specify the types of the input and output pipes.</li>
      <li><code>options</code> specifies an option type (usually a <code>bitfield enum</code> or similar) for the filter.</li>
      <li><code>field</code> can be used to keep internal filter state, but from an ROP perspective,
          stateful side effects should be minimized.</li>
      <li>The <code>constructor</code> is optional and can receive options and external parameters.</li>
      <li><code>bound(input, output): Result&lt;void&gt;</code> is the filter body; it may return
          <code>Result&lt;void&gt;.Ok()</code> on success or <code>Result&lt;void&gt;.Error(...)</code> on failure.</li>
    </ul>

    <h4>18.3.2 Filter options (filter option spec)</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>Options are listed after <code>:</code>, combined with <code>|</code>.</li>
      <li>Each filter defines its own option type (bitfield enum etc.).</li>
      <li>If the filter definition declares <code>options: JsonOptions;</code>, then when using
          that filter in a pipeline you may omit the <code>JsonOptions.</code> prefix:
      </li>
    </ul>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
    <p>
      This is equivalent to <code>JsonOptions.PrettyPrint | JsonOptions.IncludeNulls</code>, and
      the compiler verifies that the given values belong to the option type specified in <code>options</code>.
    </p>

    <h3>18.4 Pipeline statements, <code>|</code>, and the pipe-with operator <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li>In <code>A | B | C;</code>, the output of A is connected to B, and B's output is connected to C.</li>
      <li>Type checking ensures that input/output types at each stage line up.</li>
      <li>A pipeline statement itself has no value; it only connects stages as a side effect.</li>
    </ul>

    <h4>18.4.1 Pipe-with operator <span class="operator">|&gt;</span> (filter-if shortcut)</h4>
    <p>
      The operator <span class="operator">|&gt;</span> is defined as a shortcut for using
      <code>filter(if)</code> for conditional filtering.
    </p>
<pre><code>// Full form
users
    | filter(if : .Age &gt;= 20 and .Gender == Gender.Male);

// Shortcut form (equivalent)
users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>
    <ul>
      <li>The right-hand side of <span class="operator">|&gt;</span> is a condition expression
          using an implicit current-element context, similar to <code>with</code>'s <code>.</code>.</li>
      <li>In this example, only male users aged 20 or above are passed through.</li>
      <li><span class="operator">|&gt;</span> is internally desugared into <code>filter(if : ...)</code>;
          it is enough to implement a single <code>if</code> filter at the runtime level.</li>
    </ul>

    <h3>18.5 foreach and pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> internally calls <code>p.next()</code> until EOF.</li>
      <li>When the writer calls <code>close()</code>, the reader sees EOF and ends the loop.</li>
    </ul>

    <h3>18.6 Element transformation via map</h3>
    <p>
      Applying <code>map</code> to a pipe applies a function (or lambda) to each element,
      yielding a stream of another type.
    </p>
<pre><code>// Using a named function
function toName(u: User): string {
    return u.Name;
}

names = users | map(toName);

// Lambda-like notation (syntax is draft)
names = users | map (u) =&gt; u.Name;
</code></pre>
    <ul>
      <li><code>map</code> is defined as a built-in higher-order operation.</li>
      <li>The result of <code>map</code> is also a <code>pipe&lt;T&gt;</code>, so it can be connected
          to other filters.</li>
    </ul>

    <h3>18.7 Template map for collection pipes</h3>
    <p>
      For collections (e.g. <code>User()</code> or <code>User{}</code>),
      Aloe provides a template-style <code>map</code> syntax.
    </p>
<pre><code>users as u | map Customer {
    Name    = u.Name,
    Address = u.Address
}
</code></pre>
    <ul>
      <li><code>as u</code> introduces an alias for each element.</li>
      <li><code>map Customer { ... }</code> creates new <code>Customer</code> objects and
          uses the field assignments inside the block as a mapping template.</li>
      <li>The result is a collection of <code>Customer</code> with the same overall collection kind
          as the input (<code>Customer()</code>, <code>Customer{}</code>, etc.).</li>
    </ul>

    <h3>18.8 close and EOF propagation</h3>
    <ul>
      <li>Calling <code>write()</code> on a closed pipe is invalid and may be an error.</li>
      <li>When a filter detects EOF on its input, it should also <code>close()</code> its output.</li>
    </ul>

    <h3>18.9 Concurrency model with pipes</h3>
    <ul>
      <li>Pipes (<code>pipe&lt;T&gt;</code>) are the main communication mechanism between tasks.</li>
      <li>Aloe encourages a shared-nothing model, avoiding shared mutable data structures.</li>
    </ul>

    <h3>18.10 Branching on pipes with match (branching over Result&lt;T&gt;)</h3>
    <p>
      Pipelines and filters that return <code>Result&lt;T&gt;</code> can be branched using <code>match</code>.
    </p>
<pre><code>stdin
    | filter(parseUser)
    | match {
        case Ok(u):
            // Success path
            | filter(saveUser)
            | filter(logSuccess);
        case Error(e):
            // Error path
            | filter(logError);
        default:
            // Fallback for unmatched cases (future extension)
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... }</code> branches on the <code>Result&lt;T&gt;</code> produced by the previous stage.</li>
      <li>After <code>case pattern:</code>, you can continue with <code>| filter(...)</code> etc. to
          describe the branch pipeline.</li>
      <li><code>default:</code> is optional and used when no <code>case</code> matches.</li>
    </ul>
<pre><code>| match {
    case condition1:
        | filter(handleCase1);
    case condition2:
        | filter(handleCase2);
    default:
        | filter(handleDefault);
}
</code></pre>
    <p>
      Conditions can use <code>is</code> and Result patterns such as <code>Ok(...)</code> and <code>Error(...)</code>.
    </p>

    <h3>18.11 Example: simple REST-like pipeline</h3>
<pre><code>class User {
    field id: int;
    field name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    return 0;
}
</code></pre>
    <p class="note">
      <strong>Edit policy memo:</strong><br>
      • This document and its Japanese counterpart must always match in structure and meaning.<br>
      • <code>edit-version</code> is shared by the Japanese and English versions, and is incremented
        only when the content of the spec changes (never decremented).<br>
      • <code>edit-date</code> records the timestamp (date and time) when each version of the spec
        was output.<br>
      • As a rule, unrelated parts of the spec must not be changed. Do not change wording or
        identifiers arbitrarily, even if the meaning is similar.<br>
      • If it seems that “this part should also be fixed,” stop editing and confirm with the user
        before applying that change.<br>
      • Always treat the last fully output HTML as the “source of truth”, and restrict further edits
        to the minimal diff against that version.<br>
      • If the previous HTML (the latest “truth”) can no longer be seen or reconstructed, stop
        editing and consult the user.<br>
    </p>

  </main>
</div>
</body>
</html>
