```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AloeVM Specification (Draft)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }
    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM Specification</h1>
    <small>(Current draft. The contents may change or be extended in the future.)</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. Overview</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. Execution Model</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. VM Value Model</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. Call Stack and Frames</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. Heap and Memory Management Policy</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. Representation of Pipe / Filter</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC Binary Format</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. Instruction Set and WASM Mapping</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. Open Issues / TODO</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. 概要 -->
    <section id="vm-ch0" class="chapter">
      <h2>0. Overview</h2>
      <p>
        AloeVM is a <strong>stack-based virtual machine</strong> designed to execute the Aloe language.<br>
        This document defines:
      </p>
      <ul>
        <li>Execution model (stack machine / frame structure)</li>
        <li>VM-level value model (primitives, structs, classes, enums, pipe/filter, etc.)</li>
        <li>Heap and memory management policy</li>
        <li>Representation of pipe / filter on the VM</li>
        <li>AloeBC (Aloe bytecode) binary format</li>
        <li>Policy for interoperability with WebAssembly (WASM)</li>
      </ul>
      <div class="note">
        AloeVM assumes two kinds of runtimes:
        <ul>
          <li>C# implementation (VM running on .NET)</li>
          <li>WASM-native implementation (code compiled directly to WASM by aloe2wasm)</li>
        </ul>
        This specification mainly defines the behavior of the <strong>C# VM implementation + AloeBC</strong>.<br>
        For the WASM side, it outlines a policy of “mapping the instruction set almost 1:1” and “delegating GC to the WASM runtime.”
      </div>
    </section>

    <!-- 1. 実行モデル -->
    <section id="vm-ch1" class="chapter">
      <h2>1. Execution Model</h2>

      <h3>1.1 Model as a Stack Machine</h3>
      <ul>
        <li>The VM is a stack machine centered around an <strong>operand stack</strong>.</li>
        <li>Arithmetic and comparison instructions pop values from the top of the stack and push the result back.</li>
        <li>Local variables and arguments are stored in a <strong>frame-local area</strong>.</li>
      </ul>

      <h3>1.2 Unit of Execution</h3>
      <ul>
        <li>The unit of execution is a “function (method)”, corresponding to Aloe methods and the main block.</li>
        <li>Each function is registered in a <strong>function table</strong> in AloeBC, and each entry holds:
          <ul>
            <li>Code offset</li>
            <li>Number of local variables</li>
            <li>Number of arguments</li>
            <li>Reference to an exception handler table</li>
          </ul>
        </li>
      </ul>

      <h3>1.3 Exception Handling Model</h3>
      <ul>
        <li>Aloe’s <code>try / catch / finally</code> is lowered to an exception handler table at VM level.</li>
        <li>Exceptions are treated as <strong>object references</strong> in the VM, and the stack is unwound on throw.</li>
        <li>In a WASM implementation, exceptions are mapped to the host’s exception model or to a combination of multi-value returns and error codes.</li>
      </ul>

      <h3>1.4 Execution Modes</h3>
      <ul>
        <li><strong>VM Execution Mode</strong>:
          <ul>
            <li>The C# VM implementation directly loads AloeBC and interprets or JIT-compiles instructions.</li>
          </ul>
        </li>
        <li><strong>WASM Native Mode</strong>:
          <ul>
            <li>aloe2wasm converts AloeVM instruction sequences almost 1:1 into WASM instructions; AloeVM itself does not exist.</li>
            <li>GC and low-level memory management are delegated to the WASM runtime (execution environment).</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 2. VM 値モデル -->
    <section id="vm-ch2" class="chapter">
      <h2>2. VM Value Model</h2>

      <h3>2.1 Categories of VM Values</h3>
      <p>Conceptually, values handled on the VM are divided into the following categories:</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Examples</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Integer (int32)</td>
              <td><code>int</code>, <code>enum</code>, <code>bitfield enum</code></td>
              <td>Signed 32-bit integer. Enums are always int-based.</td>
            </tr>
            <tr>
              <td>Integer (other)</td>
              <td><code>byte</code></td>
              <td>May be internally packed into int32.</td>
            </tr>
            <tr>
              <td>Floating point</td>
              <td><code>float</code></td>
              <td>32-bit IEEE754.</td>
            </tr>
            <tr>
              <td>decimal</td>
              <td><code>decimal</code></td>
              <td>128-bit approximate representation with precision similar to C# decimal (implementation-dependent).</td>
            </tr>
            <tr>
              <td>bool</td>
              <td><code>bool</code></td>
              <td>Internally 1 byte or int32. Comparison instructions can reuse those for int.</td>
            </tr>
            <tr>
              <td>char</td>
              <td><code>char</code></td>
              <td>Unicode code point (implementation may be UTF-16 or UTF-32).</td>
            </tr>
            <tr>
              <td>Object reference</td>
              <td><code>class</code> instance, <code>string</code></td>
              <td>Handle to a heap object (e.g., 64-bit ID).</td>
            </tr>
            <tr>
              <td>Struct</td>
              <td><code>struct</code></td>
              <td>“Block of value” on the VM. Implementation may choose inline or boxed representation.</td>
            </tr>
            <tr>
              <td>pipe</td>
              <td><code>pipe&lt;T&gt;</code></td>
              <td>Has a dedicated VM tag. Implementation may use OS pipes / sockets, etc.</td>
            </tr>
            <tr>
              <td>filter</td>
              <td><code>filter Foo</code></td>
              <td>Has a dedicated VM tag. Wrapper of a function plus wiring information.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <strong>enum / bitfield enum</strong> are represented as <strong>int32</strong> at VM level.<br>
        The valid bits for bitfield enums are limited to 0–31 (up to 32 bits).
      </div>

      <h3>2.2 AloeObject and Heap Objects</h3>
      <p>
        In the C# VM implementation, heap objects are identified by an <strong>object ID (e.g., 64-bit integer)</strong>.
      </p>
      <ul>
        <li>Object values on the VM:
          <ul>
            <li>Only <code>objectId: long</code> is pushed to stack or stored in locals (this is the <strong>AloeObject</strong>).</li>
          </ul>
        </li>
        <li>The memory manager keeps metadata for object IDs:
          <ul>
            <li>Class / struct <strong>field list (reference slot definitions)</strong></li>
            <li>Per-field <strong>value slots</strong> (primitive values or other object IDs)</li>
            <li>Final field layout after trait composition</li>
          </ul>
        </li>
        <li>Structs can also be handled in the same scheme:
          <ul>
            <li>Even for value types, when placed on the heap, they can be managed as “field list + value slots.”</li>
            <li>Depending on VM optimization, they may be expanded inline on the stack instead.</li>
          </ul>
        </li>
      </ul>

      <h3>2.3 VM Tags for pipe / filter</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> and <code>filter</code> each have a <strong>dedicated VM value tag</strong>, separate from class instances.</li>
        <li>For WASM interoperability, their internal representation should be easily mappable to “ref types” (e.g., <code>externref</code>, <code>funcref</code>, <code>anyref</code>).</li>
        <li>A pipe holds, conceptually, “reference to tail buffer + synchronization object,” and a filter holds “bound handler function + in/out metadata,” etc.</li>
      </ul>
    </section>

    <!-- 3. コールスタックとフレーム -->
    <section id="vm-ch3" class="chapter">
      <h2>3. Call Stack and Frames</h2>

      <h3>3.1 Frame Structure</h3>
      <p>Each function call creates a “frame”. A frame contains at least:</p>
      <ul>
        <li>Return address (PC of the next instruction to execute)</li>
        <li>Link to the previous frame</li>
        <li>Local variable area</li>
        <li>Argument area</li>
        <li>Temporary value slots (if needed)</li>
      </ul>

      <h3>3.2 Calling Convention (Overview)</h3>
      <ul>
        <li>Call instructions (e.g., <code>CALL</code>) are executed with arguments already pushed on the stack.</li>
        <li>After a frame is created, arguments are either moved into the local area or left on the stack and accessed via indices.</li>
        <li>The return value is a single value on top of the stack.</li>
        <li>Void functions do not push a return value.</li>
      </ul>

      <h3>3.3 Exception Frames</h3>
      <ul>
        <li>Based on the exception handler table, the VM decides how far to unwind the stack.</li>
        <li>After unwinding, control jumps to the start of a catch block, and the exception object is passed to locals or the stack.</li>
      </ul>
    </section>

    <!-- 4. ヒープとメモリ管理方針 -->
    <section id="vm-ch4" class="chapter">
      <h2>4. Heap and Memory Management Policy (C# VM Implementation)</h2>

      <h3>4.1 Slot-Based Heap Layout</h3>
      <ul>
        <li>The heap in the C# VM implementation is managed as an array of fixed-size slots.</li>
        <li>The number of bytes per slot is given by configuration <code>memory.slot_size_bytes</code>;
          the default value when omitted is <strong>16 bytes</strong>.</li>
        <li>All heap objects start at a slot boundary (slot start address) and occupy
          one or more <strong>contiguous slots</strong>.
          <ul>
            <li>The “length” of an object is managed in units of slots (<code>lengthSlots</code>).</li>
            <li>The actual byte size is <code>lengthSlots × slot_size_bytes</code>.</li>
          </ul>
        </li>
        <li>Implementation-wise, the heap may be divided into one or more “arenas.”
          <ul>
            <li>Single arena: all objects are managed in one slot array.</li>
            <li>As an optional optimization, separate arenas per size class (16/32/64 bytes, etc.) are allowed.</li>
          </ul>
        </li>
      </ul>

      <h3>4.2 Handles and Variable Table</h3>
      <ul>
        <li>As described in Chapter 2, heap objects are identified by <strong>object IDs (handles)</strong>.</li>
        <li>Inside the VM, a <strong>variable table (or object table)</strong> is used to map handles to physical positions on the heap.
          Typically, it holds the following information:
          <ul>
            <li>Owning arena ID</li>
            <li>Index of the first slot (integer)</li>
            <li>Number of occupied slots (<code>lengthSlots</code>)</li>
            <li>Reference count (refcount)</li>
            <li>Reference to type info (class/struct metadata ID)</li>
          </ul>
        </li>
        <li>VM opcodes and runtime always operate on <strong>handles instead of raw pointers</strong>.
          <ul>
            <li>Physical memory is reached in two steps: handle → table → first slot address.</li>
            <li>When an object is moved (compacted), only the slot index in the variable table needs to be updated.</li>
          </ul>
        </li>
      </ul>

      <h3>4.3 Lifetime Management via Reference Counting</h3>
      <ul>
        <li>Each heap object has a <strong>reference count</strong>.</li>
        <li>Typical points where reference count changes:
          <ul>
            <li>Increment when a handle is stored into a local variable or a field.</li>
            <li>Decrement when a variable goes out of scope or a field is overwritten by another value.</li>
          </ul>
        </li>
        <li>When the reference count becomes 0, the object is considered “unreachable,” and the slots it occupies are handled as follows:
          <ul>
            <li>Zero out the slot contents (for easier logical treatment as “free”).</li>
            <li>Update the slot state table (e.g., <code>slot_used[i] = false</code>) to mark them as free slots.</li>
          </ul>
        </li>
        <li>Cyclic references (e.g., <code>A → B → A</code>) cannot be collected by reference counting alone,
          so they are handled by <strong>language-level constraints or an auxiliary GC in future implementations</strong>:
          <ul>
            <li>Recommend language-level design that makes strong cycles difficult (ownership / weak references).</li>
            <li>Optionally use low-priority mark-and-sweep to reclaim only cycles.</li>
          </ul>
        </li>
      </ul>

      <h3>4.4 Sliding Compaction on Access</h3>
      <p>
        To prevent fragmentation, the AloeVM heap performs a <strong>“sliding compaction on access”</strong> strategy.
        When an object is accessed, it may be slid forward, and free slots are gradually accumulated towards the front.
      </p>
      <ul>
        <li>Conceptually, an instruction that accesses a variable handle works as follows:
          <ol>
            <li>Look up the variable table from the handle to obtain <code>(arenaId, slotIndex, lengthSlots)</code>.</li>
            <li>In the same arena, check whether all slots from <code>slotIndex - lengthSlots</code> to <code>slotIndex - 1</code>
              are free (unused).
              <ul>
                <li>For simplicity, implementations may just check flags in the slot state table.</li>
              </ul>
            </li>
            <li>If that range is entirely free:
              <ul>
                <li>Slide the object forward by <code>lengthSlots</code> slots (copy).</li>
                <li>Zero out and mark as free the old region (<code>slotIndex … slotIndex + lengthSlots - 1</code>).</li>
                <li>Update the variable table entry so that <code>slotIndex</code> becomes <code>slotIndex - lengthSlots</code>.</li>
              </ul>
            </li>
            <li>Access the object fields from the new first slot.</li>
          </ol>
        </li>
        <li>With this rule, the amount of memory touched per access is at most “its own size” (<code>lengthSlots</code> slots).
          <ul>
            <li>This avoids a stop-the-world GC that scans the entire heap at once, and instead <strong>distributes the cost of defragmentation across accesses</strong>.</li>
          </ul>
        </li>
        <li>Because all objects start on slot boundaries, a consistent layout aligned on slot boundaries is maintained even after sliding.</li>
        <li>This “sliding on access” is not mandatory. Implementations may:
          <ul>
            <li>Lower its frequency (e.g., only run it once every N accesses).</li>
            <li>Impose a maximum number of slots that can be moved per access.</li>
          </ul>
        </li>
      </ul>

      <h3>4.5 Allocation Strategy</h3>
      <ul>
        <li>When allocating a new object, the memory manager performs:
          <ol>
            <li>Compute the required number of slots <code>lengthSlots</code> as <code>ceil(objectSizeBytes / slot_size_bytes)</code>.</li>
            <li>Search the current arena, or multiple arenas, for <strong>enough contiguous free slots</strong>.</li>
            <li>Place the object at the found first slot, and update the slot state table and variable table.</li>
          </ol>
        </li>
        <li>Free slot management is implementation-dependent. Typical approaches:
          <ul>
            <li>Simple linear scan (for prototype phase)</li>
            <li>Free list of ranges of contiguous slots</li>
            <li>Bitmap plus first-fit / best-fit algorithms</li>
          </ul>
        </li>
        <li>If no arena has sufficient contiguous free slots:
          <ul>
            <li>Temporarily increase the frequency of sliding-on-access to reduce fragmentation.</li>
            <li>Or extend the heap by adding a new arena.</li>
          </ul>
        </li>
      </ul>

      <h3>4.6 <code>delete</code> and Timing of Deallocation</h3>
      <ul>
        <li>Aloe’s <code>delete x;</code> means “disconnect the reference from variable <code>x</code> to its handle.” It does <strong>not guarantee</strong>
          that physical memory is freed at that moment.</li>
        <li>Objects whose reference count becomes 0 are processed for deallocation at the following timing:
          <ul>
            <li>Immediately when the counter hits 0, zero out and mark as free the slots occupied by that object.</li>
            <li>Or process them gradually in a low-priority background task (implementation-dependent).</li>
          </ul>
        </li>
        <li>Therefore, Aloe programs must not rely on “heap usage dropping immediately after <code>delete</code>.”
          It is merely a <strong>logical declaration that “this object is no longer used”</strong>.</li>
      </ul>

      <h3>4.7 Memory Management in WASM Implementations</h3>
      <div class="note">
        In WASM native mode, AloeVM’s custom slot-based memory management and reference counting are not mandatory.<br>
        GC and memory allocation/deallocation are <strong>delegated to the WASM runtime and host environment</strong>.
      </div>
      <ul>
        <li>Aloe objects can be mapped directly to WASM <code>struct</code> / <code>array</code> / <code>ref</code> types.</li>
        <li>Because WASM GC or host GCs (e.g., .NET, JVM, JS) are responsible, the slot layout and sliding-on-access described in this chapter
          are internal details specific to the C# VM implementation.</li>
        <li>Compilers such as aloe2wasm are recommended to respect AloeVM’s abstract memory model
          while delegating actual GC behavior to the target environment.</li>
      </ul>
    </section>

    <!-- 5. パイプ / フィルタ -->
    <section id="vm-ch5" class="chapter">
      <h2>5. VM Representation of Pipe / Filter</h2>

      <h3>5.1 <code>pipe&lt;T&gt;</code></h3>
      <ul>
        <li>Represented as a value with a dedicated <strong>PIPE</strong> tag at VM level.</li>
        <li>Internally assumed to hold:
          <ul>
            <li>Buffer (ring buffer / queue)</li>
            <li>Synchronization primitives (locks / condition variables, etc.)</li>
            <li>Type information of elements (reference to runtime type info)</li>
          </ul>
        </li>
        <li>Implementations must be thread-safe so that multiple threads can access pipes safely.</li>
        <li>Possible concrete implementations:
          <ul>
            <li>OS pipes / sockets</li>
            <li>Ring buffer on a memory-mapped file</li>
          </ul>
        </li>
      </ul>

      <h3>5.2 <code>filter</code></h3>
      <ul>
        <li>A filter is represented as a value with a dedicated FILTER tag.</li>
        <li>Conceptually, a filter value is a structure that bundles:
          <ul>
            <li>Pointer to a bound function</li>
            <li>Filter definition metadata (in/out types)</li>
          </ul>
        </li>
        <li>User-defined filters are represented in the same way.</li>
      </ul>

      <h3>5.3 Execution Model of Pipeline Statements</h3>
      <pre><code class="language-aloe">
A | filter(F) | B;
      </code></pre>
      <ul>
        <li>The VM expands this statement into a sequence of “connection-construction instructions.”</li>
        <li>Typical flow:
          <ol>
            <li>Resolve the output pipe of <code>A</code>.</li>
            <li>Create an instance of <code>filter(F)</code> and start <code>bound(input, output)</code> as a separate task/thread.</li>
            <li>Connect the output pipe to <code>B</code>.</li>
          </ol>
        </li>
        <li>Some implementations may optimize by running multiple filters sequentially on a single thread.</li>
      </ul>
    </section>

    <!-- 6. AloeBC バイナリ形式 -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC Binary Format</h2>

      <h3>6.1 Overall Structure</h3>
      <p>AloeBC (Aloe Byte Code) is a binary format that stores compilation results for AloeVM.</p>

      <h3>6.2 Header</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Offset</th>
              <th>Size</th>
              <th>Field</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 byte</td>
              <td>Magic</td>
              <td>ASCII string <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>Major version</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>Minor version</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>Build number</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Reserved</td>
              <td>Reserved (0)</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 byte</td>
              <td>HeaderSize</td>
              <td>Total header size (little-endian)</td>
            </tr>
            <tr>
              <td>14</td>
              <td>4 byte</td>
              <td>ConstPoolOffset</td>
              <td>Offset of constant pool</td>
            </tr>
            <tr>
              <td>18</td>
              <td>4 byte</td>
              <td>TypeTableOffset</td>
              <td>Offset of type table</td>
            </tr>
            <tr>
              <td>22</td>
              <td>4 byte</td>
              <td>FuncTableOffset</td>
              <td>Offset of function table</td>
            </tr>
            <tr>
              <td>26</td>
              <td>4 byte</td>
              <td>CodeSectionOffset</td>
              <td>Offset of code section</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Little-endian is assumed.</p>

      <h3>6.3 Constant Pool (Overview)</h3>
      <ul>
        <li>Centralized storage for string literals, numeric literals, type information, etc.</li>
        <li>Each entry is a variable-length record composed of “tag + length + body.”</li>
        <li>Examples of tags:
          <ul>
            <li>0x01: UTF-8 string</li>
            <li>0x02: int32</li>
            <li>0x03: float32</li>
            <li>0x04: decimal</li>
          </ul>
        </li>
      </ul>

      <h3>6.4 Type Table (Overview)</h3>
      <ul>
        <li>Assigns IDs to each Aloe type (class / struct / enum / bitfield enum / <code>pipe&lt;T&gt;</code>, etc.).</li>
        <li>Enums / bitfield enums are flagged as <strong>int32 value types</strong> at VM level.</li>
        <li>The number of valid bits (0–31) for a bitfield enum may be stored as metadata (for warnings, etc.).</li>
      </ul>

      <h3>6.5 Function Table / Code Section</h3>
      <ul>
        <li>Function table:
          <ul>
            <li>Function signature (argument types, return type)</li>
            <li>Number of local variables</li>
            <li>Offset and length in the code section</li>
          </ul>
        </li>
        <li>Code section:
          <ul>
            <li>Stores VM instruction streams as byte arrays.</li>
            <li>For details of the instruction set, see Chapter 7.</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 7. 命令セットと WASM 対応 -->
    <section id="vm-ch7" class="chapter">
      <h2>7. Instruction Set and WASM Mapping (Overview)</h2>

      <h3>7.1 Instruction Categories</h3>
      <p>The instruction set is roughly divided into the following categories:</p>
      <ul>
        <li>Stack manipulation
          <ul>
            <li>PUSH, POP, DUP, SWAP, etc.</li>
          </ul>
        </li>
        <li>Arithmetic / logical instructions
          <ul>
            <li>ADD, SUB, MUL, DIV, MOD</li>
            <li>AND, OR, XOR, SHL, SHR</li>
          </ul>
        </li>
        <li>Comparison instructions
          <ul>
            <li>CMPEQ, CMPNE, CMPLT, CMPLE, CMPGT, CMPGE</li>
          </ul>
        </li>
        <li>Control flow
          <ul>
            <li>JMP, JMP_IF_TRUE, JMP_IF_FALSE</li>
          </ul>
        </li>
        <li>Function calls
          <ul>
            <li>CALL, RET</li>
          </ul>
        </li>
        <li>Object operations
          <ul>
            <li>NEWOBJ, GETFIELD, SETFIELD, etc.</li>
          </ul>
        </li>
        <li>Array / collection operations (future)</li>
        <li>pipe / filter operations (connect, read/write)</li>
      </ul>

      <div class="note">
        The “numeric opcode values” and “exact binary layout” of instructions<br>
        are defined in the provisional table in 7.4 below. These may change in future
        due to optimizations or implementation constraints.
      </div>

      <h3>7.2 1:1 Mapping Policy to WASM</h3>
      <ul>
        <li>Basic arithmetic and comparison instructions are mapped 1:1 to WASM instructions such as <code>i32.add</code>, <code>i32.lt_s</code>, etc., wherever possible.</li>
        <li>Stack operations conceptually match WASM’s stack machine, so they can be converted almost directly.</li>
        <li>Exception handling is represented by WASM’s exception-handling extension or by a combination of error codes and structured blocks.</li>
        <li>pipe / filter are typically implemented using WASM <code>ref</code> types plus host functions.</li>
      </ul>

      <h3>7.3 Role of aloe2wasm</h3>
      <ul>
        <li>Apart from the path “Aloe source → AloeBC → execution on AloeVM,” we also provide:
          <ul>
            <li>A native WASM build path: “Aloe source → intermediate IR → WASM.”</li>
          </ul>
        </li>
        <li>The closer AloeVM’s instruction set is to WASM’s, the simpler the compiler implementation becomes.</li>
        <li>Ideally, we aim for a level where we can “serialize AloeVM instruction sequences as-is into WASM” to run them.</li>
      </ul>

      <h3>7.4 Instruction Set Table (Draft)</h3>
      <p>
        This section defines a <strong>core instruction set</strong> required to implement a minimal AloeVM prototype.<br>
        Opcodes are assumed to be 1 byte, denoted in hexadecimal (0xNN).
      </p>
      <p>
        Stack effects are written like <code>… , A , B → … , R</code> (left: before execution, right: after execution).<br>
        <code>…</code> represents the rest of the stack.
      </p>

      <h4>7.4.1 Stack Operations / Constant Loading</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="4">Stack</td>
              <td>NOP</td>
              <td>0x00</td>
              <td>None</td>
              <td>… → …</td>
              <td>Do nothing.</td>
            </tr>
            <tr>
              <td>POP</td>
              <td>0x01</td>
              <td>None</td>
              <td>… , A → …</td>
              <td>Discard the top of stack.</td>
            </tr>
            <tr>
              <td>DUP</td>
              <td>0x02</td>
              <td>None</td>
              <td>… , A → … , A , A</td>
              <td>Duplicate the top of stack.</td>
            </tr>
            <tr>
              <td>SWAP</td>
              <td>0x03</td>
              <td>None</td>
              <td>… , A , B → … , B , A</td>
              <td>Swap the top two stack elements.</td>
            </tr>
            <tr>
              <td rowspan="7">Constants</td>
              <td>LDC_I4_S</td>
              <td>0x10</td>
              <td>int8 (signed)</td>
              <td>… → … , i32</td>
              <td>Push a signed 8-bit immediate as an int32 (for small integers).</td>
            </tr>
            <tr>
              <td>LDC_I4</td>
              <td>0x11</td>
              <td>int32</td>
              <td>… → … , i32</td>
              <td>Push a 32-bit integer immediate.</td>
            </tr>
            <tr>
              <td>LDC_F</td>
              <td>0x12</td>
              <td>float32</td>
              <td>… → … , f32</td>
              <td>Push a 32-bit floating-point immediate.</td>
            </tr>
            <tr>
              <td>LDC_DEC</td>
              <td>0x13</td>
              <td>decimal (16 bytes)</td>
              <td>… → … , decimal</td>
              <td>Push a decimal immediate (may also be a constant-pool reference; implementation-dependent).</td>
            </tr>
            <tr>
              <td>LDC_STR</td>
              <td>0x14</td>
              <td>uint16 (constant-pool index)</td>
              <td>… → … , obj</td>
              <td>Load a string from the constant pool and push a string object reference.</td>
            </tr>
            <tr>
              <td>LDC_BOOL</td>
              <td>0x15</td>
              <td>byte (0 or 1)</td>
              <td>… → … , bool</td>
              <td>Push a bool immediate.</td>
            </tr>
            <tr>
              <td>LDC_NULL</td>
              <td>0x16</td>
              <td>None</td>
              <td>… → … , null</td>
              <td>Push a null reference.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.2 Local Variable / Argument Access</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">Locals</td>
              <td>LDLOC</td>
              <td>0x20</td>
              <td>uint16 (index)</td>
              <td>… → … , V</td>
              <td>Load the value of the local variable at the given index in the current frame.</td>
            </tr>
            <tr>
              <td>STLOC</td>
              <td>0x21</td>
              <td>uint16 (index)</td>
              <td>… , V → …</td>
              <td>Store the top of stack into the local variable at the given index.</td>
            </tr>
            <tr>
              <td>LDLOC_ADDR</td>
              <td>0x22</td>
              <td>uint16 (index)</td>
              <td>… → … , ref</td>
              <td>Push a reference (address) to the local variable (optional, for future optimization).</td>
            </tr>
            <tr>
              <td rowspan="2">Arguments</td>
              <td>LDARG</td>
              <td>0x28</td>
              <td>uint16 (index)</td>
              <td>… → … , V</td>
              <td>Load the value of the argument at the given index in the current frame.</td>
            </tr>
            <tr>
              <td>STARG</td>
              <td>0x29</td>
              <td>uint16 (index)</td>
              <td>… , V → …</td>
              <td>Write the top of stack back to an argument slot (for <code>ref</code> arguments, etc.).</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.3 Arithmetic, Comparison, Logic</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="6">Arithmetic (int32)</td>
              <td>ADD_I4</td>
              <td>0x30</td>
              <td>None</td>
              <td>… , A , B → … , (A + B)</td>
              <td>int32 addition.</td>
            </tr>
            <tr>
              <td>SUB_I4</td>
              <td>0x31</td>
              <td>None</td>
              <td>… , A , B → … , (A - B)</td>
              <td>int32 subtraction.</td>
            </tr>
            <tr>
              <td>MUL_I4</td>
              <td>0x32</td>
              <td>None</td>
              <td>… , A , B → … , (A * B)</td>
              <td>int32 multiplication.</td>
            </tr>
            <tr>
              <td>DIV_I4</td>
              <td>0x33</td>
              <td>None</td>
              <td>… , A , B → … , (A / B)</td>
              <td>int32 division (division by zero throws an exception).</td>
            </tr>
            <tr>
              <td>MOD_I4</td>
              <td>0x34</td>
              <td>None</td>
              <td>… , A , B → … , (A % B)</td>
              <td>int32 remainder.</td>
            </tr>
            <tr>
              <td>NEG_I4</td>
              <td>0x35</td>
              <td>None</td>
              <td>… , A → … , (-A)</td>
              <td>Negation (sign flip).</td>
            </tr>
            <tr>
              <td rowspan="3">Comparison</td>
              <td>CMPEQ</td>
              <td>0x40</td>
              <td>None</td>
              <td>… , A , B → … , bool</td>
              <td>Equality comparison.</td>
            </tr>
            <tr>
              <td>CMPNE</td>
              <td>0x41</td>
              <td>None</td>
              <td>… , A , B → … , bool</td>
              <td>Inequality comparison.</td>
            </tr>
            <tr>
              <td>CMPLT_I4</td>
              <td>0x42</td>
              <td>None</td>
              <td>… , A , B → … , bool</td>
              <td>Signed comparison A &lt; B.</td>
            </tr>
            <tr>
              <td rowspan="3">Logical / Bitwise</td>
              <td>AND_I4</td>
              <td>0x48</td>
              <td>None</td>
              <td>… , A , B → … , (A &amp; B)</td>
              <td>Bitwise AND.</td>
            </tr>
            <tr>
              <td>OR_I4</td>
              <td>0x49</td>
              <td>None</td>
              <td>… , A , B → … , (A | B)</td>
              <td>Bitwise OR.</td>
            </tr>
            <tr>
              <td>XOR_I4</td>
              <td>0x4A</td>
              <td>None</td>
              <td>… , A , B → … , (A ^ B)</td>
              <td>Bitwise XOR.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.4 Control Flow, Calls, Exceptions</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">Branching</td>
              <td>JMP</td>
              <td>0x50</td>
              <td>int32 (relative offset)</td>
              <td>… → …</td>
              <td>Unconditional jump.</td>
            </tr>
            <tr>
              <td>JMP_TRUE</td>
              <td>0x51</td>
              <td>int32 (relative offset)</td>
              <td>… , cond → …</td>
              <td>If <code>cond</code> is true, jump and POP the condition.</td>
            </tr>
            <tr>
              <td>JMP_FALSE</td>
              <td>0x52</td>
              <td>int32 (relative offset)</td>
              <td>… , cond → …</td>
              <td>If <code>cond</code> is false, jump and POP the condition.</td>
            </tr>
            <tr>
              <td rowspan="2">Calls</td>
              <td>CALL</td>
              <td>0x58</td>
              <td>uint16 (function ID)</td>
              <td>… , args → … , ret</td>
              <td>Call a function in the function table. Argument count and types follow metadata.</td>
            </tr>
            <tr>
              <td>RET</td>
              <td>0x59</td>
              <td>None</td>
              <td>… , ret? → … , ret?</td>
              <td>Exit the current frame and return to caller (with 0 or 1 return value).</td>
            </tr>
            <tr>
              <td rowspan="2">Exceptions</td>
              <td>THROW</td>
              <td>0x5C</td>
              <td>None</td>
              <td>… , ex → (stack unwound)</td>
              <td>Throw exception object <code>ex</code>.</td>
            </tr>
            <tr>
              <td>RETHROW</td>
              <td>0x5D</td>
              <td>None</td>
              <td>… , ex → (stack unwound)</td>
              <td>Rethrow an exception from within a catch block.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.5 Object / Field / pipe / filter</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">Object</td>
              <td>NEWOBJ</td>
              <td>0x60</td>
              <td>uint16 (type ID), uint8 (arg count)</td>
              <td>… , args → … , obj</td>
              <td>Create an instance of the specified class/struct and call its constructor.</td>
            </tr>
            <tr>
              <td>GETFIELD</td>
              <td>0x61</td>
              <td>uint16 (field ID)</td>
              <td>… , obj → … , value</td>
              <td>Get the value of a field from an object.</td>
            </tr>
            <tr>
              <td>SETFIELD</td>
              <td>0x62</td>
              <td>uint16 (field ID)</td>
              <td>… , obj , value → …</td>
              <td>Set the value of a field on an object.</td>
            </tr>
            <tr>
              <td rowspan="3">pipe</td>
              <td>PIPE_NEW</td>
              <td>0x70</td>
              <td>uint16 (type ID)</td>
              <td>… → … , pipe</td>
              <td>Create a <code>pipe&lt;T&gt;</code> of type T.</td>
            </tr>
            <tr>
              <td>PIPE_SEND</td>
              <td>0x71</td>
              <td>None</td>
              <td>… , pipe , value → …</td>
              <td>Write one element into a pipe (blocking/non-blocking behavior is implementation-dependent).</td>
            </tr>
            <tr>
              <td>PIPE_RECV</td>
              <td>0x72</td>
              <td>None</td>
              <td>… , pipe → … , value</td>
              <td>Read one element from a pipe (behavior when no data is available is implementation-defined).</td>
            </tr>
            <tr>
              <td rowspan="2">filter</td>
              <td>FILTER_NEW</td>
              <td>0x78</td>
              <td>uint16 (filter definition ID)</td>
              <td>… → … , filter</td>
              <td>Create a filter instance based on a filter definition.</td>
            </tr>
            <tr>
              <td>FILTER_BIND</td>
              <td>0x79</td>
              <td>None</td>
              <td>… , filter , inPipe , outPipe → … , filter</td>
              <td>Bind input/output pipes to a filter (for pipeline construction).</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.6 Debug / Extension</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>Operand</th>
              <th>Stack Effect</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Debug</td>
              <td>BREAK</td>
              <td>0x7F</td>
              <td>None</td>
              <td>… → …</td>
              <td>Debugger breakpoint. May notify the host and pause execution.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        The instruction set table above is a <strong>draft for the minimal core</strong> used in a prototype implementation.<br>
        The actual implementation may add, remove, or rearrange opcodes.<br>
        As long as the “stack effects” and “semantics” remain compatible, consistency with the Aloe language specification is preserved.
      </div>
    </section>

    <!-- 8. 未決事項・TODO -->
    <section id="vm-ch8" class="chapter">
      <h2>8. Open Issues / TODO</h2>

      <h3>8.1 Unresolved Items</h3>
      <ul>
        <li>Final opcode assignments and exact binary format (the definitive version of the instruction set table in 7.4)</li>
        <li>Concrete format of the exception handler table (range specification, catch types, etc.)</li>
        <li>Inline expansion of structs and handling of box/unbox</li>
        <li>Details of the slot arena configuration (single arena vs multiple size classes)</li>
        <li>Algorithm when combining reference counting with cyclic detection (auxiliary GC)</li>
        <li>Thread model for pipe / filter (one thread per filter vs shared worker threads)</li>
        <li>Standard ABI for pipe / filter on WASM (interface with the host)</li>
      </ul>

      <h3>8.2 Possible Future Extensions</h3>
      <ul>
        <li>JIT compilation layer (native code for hot functions)</li>
        <li>Debugger hooks (breakpoints, step execution, variable watch)</li>
        <li>Profiler API (measure execution time, allocated memory, etc.)</li>
        <li>Distributed execution (support for pipes spanning multiple processes/nodes)</li>
      </ul>

      <div class="note">
        The current contents of this specification aim to be sufficient to implement
        a <strong>prototype Aloe compiler, C# AloeVM implementation, and aloe2wasm</strong>.<br>
        However, details of the instruction set and memory management are expected to be refined through experimentation.
      </div>
    </section>

  </main>
</div>
</body>
</html>
```
