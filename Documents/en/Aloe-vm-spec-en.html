```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AloeVM Specification (Draft)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }

    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM Spec</h1>
    <small>(Current draft; subject to change/extension.)</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. Overview</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. Execution Model</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. Value Model</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. Stack & Frames</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. Instruction Set Overview</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. Selected Instructions</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC Binary Format</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. Modules & Linking</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. Memory & GC</a></li>
        <li><a class="nav-link" data-target="vm-ch9">9. Pipes & Filters in VM</a></li>
        <li><a class="nav-link" data-target="vm-ch10">10. WASM Mapping</a></li>
        <li><a class="nav-link" data-target="vm-ch11">11. Errors & Traps</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. Overview -->
    <section id="vm-ch0" class="chapter">
      <h2>0. Overview</h2>
      <p>
        AloeVM is the execution engine for the Aloe language. It is designed as a stack-based virtual machine
        with a bytecode format called <strong>AloeBC</strong>. AloeVM has two main deployment modes:
      </p>
      <ul>
        <li><strong>Native AloeVM</strong> – implemented directly in a host language (e.g., C#), running AloeBC.</li>
        <li><strong>WASM-native Aloe</strong> – Aloe source compiled directly to WebAssembly instructions
          with a 1:1 mapping from AloeVM instructions to WASM opcodes (or short instruction macros), using
          the WebAssembly runtime’s memory model and GC.</li>
      </ul>
      <p>
        This document describes the VM-level model and the AloeBC binary format. Language-level semantics
        (syntax, types, etc.) are defined in the separate “Aloe Language Specification” document.
      </p>
      <div class="note">
        Design goal: keep AloeVM close to WASM’s stack machine model, so that
        <em>“AloeVM → WASM”</em> can be implemented mechanically, and in the long term
        Aloe bytecode can be skipped for WASM-native builds.
      </div>
    </section>

    <!-- 1. Execution Model -->
    <section id="vm-ch1" class="chapter">
      <h2>1. Execution Model</h2>

      <h3>1.1 Stack machine</h3>
      <ul>
        <li>AloeVM is a classic stack-based machine:
          <ul>
            <li>Instructions consume operands from the operand stack.</li>
            <li>Results are pushed back onto the operand stack.</li>
          </ul>
        </li>
        <li>There is a separate <strong>call stack</strong> for frames (method calls).</li>
        <li>The VM is <strong>structured</strong>: control flow uses blocks and branches similar to WASM.</li>
      </ul>

      <h3>1.2 Execution units</h3>
      <ul>
        <li><strong>Module</strong>: unit of deployment (roughly “assembly”). Contains:
          <ul>
            <li>Type table (classes, structs, interfaces, traits).</li>
            <li>Constant pool (literals, metadata references, etc.).</li>
            <li>Method table and method bodies.</li>
            <li>Optional debug/extra metadata.</li>
          </ul>
        </li>
        <li><strong>Function / method</strong>:
          <ul>
            <li>Has a signature: parameter types + return type.</li>
            <li>Has local variable declarations.</li>
            <li>Has a bytecode body (sequence of AloeVM instructions).</li>
          </ul>
        </li>
      </ul>

      <h3>1.3 Program startup</h3>
      <ul>
        <li>The VM loads a root AloeBC module.</li>
        <li>It locates the <code>main(args: string[])</code> entry point (according to language-level metadata).</li>
        <li>It creates an initial frame for <code>main</code> and begins execution.</li>
      </ul>
    </section>

    <!-- 2. Value Model -->
    <section id="vm-ch2" class="chapter">
      <h2>2. Value Model</h2>

      <h3>2.1 VM value kinds</h3>
      <p>At runtime, values on the operand stack are tagged with a small set of VM-level kinds:</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Kind</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td>I32</td><td>32-bit signed integer (covers Aloe <code>int</code>, enums, bitfield enums, booleans as 0/1).</td></tr>
            <tr><td>F64</td><td>64-bit floating-point (covers Aloe <code>float</code> at VM level).</td></tr>
            <tr><td>DEC</td><td>High-precision decimal (implementation-specific, e.g. 128-bit decimal).</td></tr>
            <tr><td>BYTE</td><td>Unsigned 8-bit integer (0–255), used for <code>byte</code>.</td></tr>
            <tr><td>CHAR</td><td>Unicode scalar value (implementation may store as 32-bit int internally).</td></tr>
            <tr><td>REF_STRING</td><td>Reference to a string object in the heap.</td></tr>
            <tr><td>REF_OBJECT</td><td>Reference to a class instance.</td></tr>
            <tr><td>REF_STRUCT</td><td>Reference/handle to a struct instance (if stored on heap; small structs may be inlined).</td></tr>
            <tr><td>REF_PIPE</td><td>Handle to a pipe instance (<code>pipe&lt;T&gt;</code>).</td></tr>
            <tr><td>REF_FILTER</td><td>Handle to a filter instance (runtime representation of a <code>filter</code> definition).</td></tr>
            <tr><td>REF_TASK</td><td>Handle to an async task.</td></tr>
            <tr><td>NULL</td><td>Null reference (for any reference-kind type).</td></tr>
          </tbody>
        </table>
      </div>
      <p>
        At the language level, many of these are grouped (e.g. “class types”), but at VM level they are represented via
        these core kinds plus type descriptors.
      </p>

      <h3>2.2 Type descriptors</h3>
      <ul>
        <li>Each runtime value with a reference kind is associated with a <strong>type descriptor ID</strong>:
          <ul>
            <li>Class ID, struct ID, interface ID, trait ID, etc.</li>
          </ul>
        </li>
        <li>The VM keeps a type table in the module (and/or at runtime across modules).</li>
        <li>Instructions that operate on fields or methods refer to these type IDs and their metadata indices.</li>
      </ul>

      <h3>2.3 Null handling</h3>
      <ul>
        <li><code>delete x;</code> at the language level becomes setting the corresponding stack slot or field to the <strong>NULL</strong> value.</li>
        <li>Any attempt to dereference NULL (field access, method call) raises a <code>NullReferenceException</code>.</li>
        <li>The type system itself is not null-aware; nullness is a runtime property only.</li>
      </ul>
    </section>

    <!-- 3. Stack & Frames -->
    <section id="vm-ch3" class="chapter">
      <h2>3. Stack and Frames</h2>

      <h3>3.1 Operand stack</h3>
      <ul>
        <li>Each frame has its own operand stack.</li>
        <li>Instructions operate on the top of this stack (push/pop).</li>
        <li>The maximum stack depth per method is provided in metadata and may be validated at load time.</li>
      </ul>

      <h3>3.2 Local variables</h3>
      <ul>
        <li>Each frame has a local variable array:
          <ul>
            <li>Slots for parameters (0..N-1).</li>
            <li>Slots for <code>let</code>/<code>var</code> locals, temps, etc.</li>
          </ul>
        </li>
        <li>Locals are addressed by index (0-based) in instructions like <code>LDLOC</code> / <code>STLOC</code>.</li>
      </ul>

      <h3>3.3 Call stack</h3>
      <ul>
        <li>Method calls push a new frame:
          <ul>
            <li>Program counter (PC) of caller.</li>
            <li>Reference to current method metadata.</li>
            <li>Local variable array + operand stack.</li>
          </ul>
        </li>
        <li><code>RET</code> pops the current frame, returns a value (if any) to the caller’s operand stack.</li>
      </ul>

      <h3>3.4 Blocks and branches</h3>
      <ul>
        <li>AloeVM uses structured control flow:
          <ul>
            <li>Block-based constructs (<code>BLOCK</code>/<code>END</code>, <code>LOOP</code>/<code>END</code>).</li>
            <li>Branch instructions target block depths rather than raw PCs, similar to WASM.</li>
          </ul>
        </li>
        <li>This design simplifies the mapping to WebAssembly structured control flow.</li>
      </ul>
    </section>

    <!-- 4. Instruction Set Overview -->
    <section id="vm-ch4" class="chapter">
      <h2>4. Instruction Set Overview</h2>

      <p>
        The exact opcode numbers are part of the AloeBC format and can evolve, but the conceptual groups are:
      </p>

      <h3>4.1 Constants and locals</h3>
      <ul>
        <li><code>PUSH_I32 constId</code> – push integer constant from constant pool.</li>
        <li><code>PUSH_F64 constId</code> – push floating constant.</li>
        <li><code>PUSH_DEC constId</code> – push decimal constant.</li>
        <li><code>PUSH_STRING constId</code> – push string reference from constant pool (interned or allocated).</li>
        <li><code>LDLOC index</code> – load local by index onto stack.</li>
        <li><code>STLOC index</code> – pop value and store into local by index.</li>
      </ul>

      <h3>4.2 Arithmetic</h3>
      <ul>
        <li><code>ADD_I32</code>, <code>SUB_I32</code>, <code>MUL_I32</code>, <code>DIV_I32</code>, <code>REM_I32</code></li>
        <li><code>ADD_F64</code>, <code>SUB_F64</code>, <code>MUL_F64</code>, <code>DIV_F64</code>, <code>REM_F64</code></li>
        <li><code>ADD_DEC</code>, <code>SUB_DEC</code>, <code>MUL_DEC</code>, <code>DIV_DEC</code></li>
        <li>Bit operations: <code>AND_I32</code>, <code>OR_I32</code>, <code>XOR_I32</code>, <code>SHL_I32</code>, <code>SHR_I32</code></li>
      </ul>

      <h3>4.3 Comparison and branching</h3>
      <ul>
        <li><code>EQ_I32</code>, <code>NE_I32</code>, <code>LT_I32</code>, <code>GT_I32</code>, <code>LE_I32</code>, <code>GE_I32</code> (similarly for F64, DEC).</li>
        <li><code>BR blockDepth</code> – unconditional structured branch.</li>
        <li><code>BR_IF blockDepth</code> – conditional branch (consumes a boolean from the stack).</li>
        <li><code>RETURN</code> – return from current method.</li>
      </ul>

      <h3>4.4 Object and field access</h3>
      <ul>
        <li><code>NEWOBJ typeId, ctorId</code> – allocate new object of class type, call constructor.</li>
        <li><code>NEWSTRUCT typeId, ctorId</code> – construct a struct value (may be heap-allocated or inlined).</li>
        <li><code>LD_FIELD fieldId</code> – load instance field value.</li>
        <li><code>ST_FIELD fieldId</code> – store instance field value.</li>
      </ul>

      <h3>4.5 Method calls</h3>
      <ul>
        <li><code>CALL methodId</code> – direct call to method.</li>
        <li><code>CALL_VIRT slotId</code> – virtual call via vtable slot.</li>
        <li><code>CALL_INTF ifaceId, slotId</code> – call via interface dispatch.</li>
      </ul>

      <h3>4.6 Pipes and filters</h3>
      <ul>
        <li><code>PIPE_CREATE typeDescriptorId</code> – create a new <code>pipe&lt;T&gt;</code>.</li>
        <li><code>PIPE_WRITE</code> – write top-of-stack value into pipe, pop the value.</li>
        <li><code>PIPE_CLOSE</code> – close a pipe (no further writes).</li>
        <li><code>PIPE_NEXT</code> – read next item; push value or null sentinel.</li>
        <li><code>PIPE_PEEK</code> – peek next item without consuming.</li>
        <li><code>PIPE_TAKE</code> – take N items into a collection (according to language-level mapping).</li>
        <li><code>FILTER_CREATE filterId</code> – create filter instance.</li>
        <li><code>FILTER_BIND</code> – bind filter <code>in</code>/<code>out</code> to pipes and schedule execution.</li>
      </ul>

      <h3>4.7 Exceptions</h3>
      <ul>
        <li><code>THROW exceptionTypeId</code> – throw new exception.</li>
        <li><code>RETHROW</code> – rethrow the current exception.</li>
        <li>Exception handlers are defined in method metadata (try/catch/finally ranges).</li>
      </ul>

      <div class="note">
        This chapter is intentionally high-level. The exact opcode numbers and formats are defined in
        Chapter 6 (AloeBC Binary Format), and additional instructions may be introduced later.
      </div>
    </section>

    <!-- 5. Selected Instructions -->
    <section id="vm-ch5" class="chapter">
      <h2>5. Selected Instruction Semantics</h2>

      <h3>5.1 Example: integer addition</h3>
      <pre><code>
// Stack before: [..., a, b]
ADD_I32
// Stack after:  [..., (a + b)]
      </code></pre>
      <ul>
        <li>Pops two I32 values, adds them with overflow checks (throws <code>OverflowException</code> on overflow).</li>
        <li>Pushes the result as I32.</li>
      </ul>

      <h3>5.2 Example: method call</h3>
      <pre><code>
// call instance method M(this, arg1, arg2): R

// Stack before: [..., this, arg1, arg2]
CALL methodId
// Stack after:  [..., result]   // if R != void
// or           [...]           // if R == void
      </code></pre>
      <ul>
        <li>The VM looks up method metadata by <code>methodId</code>.</li>
        <li>Creates a new frame, moves parameters into the callee’s locals, and starts executing at the callee’s entry point.</li>
        <li>On <code>RETURN</code>, pops the frame and pushes the result onto the caller’s operand stack.</li>
      </ul>

      <h3>5.3 Example: pipe next / take / peek</h3>
      <pre><code>
// p : pipe&lt;T&gt;

// next
LDLOC p
PIPE_NEXT    // pushes T or NULL

// take
LDLOC p
PUSH_I32 n
PIPE_TAKE    // pushes list of up to n elements

// peek
LDLOC p
PIPE_PEEK    // pushes next T or NULL, without consuming
      </code></pre>
      <ul>
        <li>These instructions implement the language-level <code>next()</code>, <code>take()</code>, <code>peek()</code> methods on <code>pipe&lt;T&gt;</code>.</li>
        <li>EOF handling is VM-defined but must align with language semantics (e.g. nullable result, or raising <code>EndOfStreamException</code> for some APIs).</li>
      </ul>

      <h3>5.4 Example: filter binding</h3>
      <pre><code>
// Given: filter lineSplit { in: pipe&lt;string&gt;; out: pipe&lt;string&gt;; ... }

// Pseudo bytecode for:
// input | filter(lineSplit) | output;

LDLOC inputPipe
LDLOC outputPipe
FILTER_CREATE lineSplitFilterId
FILTER_BIND   // logically: run bound(inputPipe, outputPipe)
      </code></pre>
      <ul>
        <li><code>FILTER_BIND</code> may run synchronously or schedule the filter on a worker, depending on implementation.</li>
        <li>Once bound, the filter body’s <code>bound(in,out)</code> is invoked to move data from <code>in</code> to <code>out</code>.</li>
      </ul>
    </section>

    <!-- 6. AloeBC Binary Format -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC Binary Format</h2>

      <p>
        AloeBC is the binary representation of AloeVM modules. It is designed to be simple and extensible,
        with a clear magic header and versioning.
      </p>

      <h3>6.1 File header</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Offset</th><th>Size</th><th>Field</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 bytes</td>
              <td>Magic</td>
              <td>ASCII literal <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>Major version of the AloeBC format</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>Minor version</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>Build/revision number</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Flags</td>
              <td>Reserved for future use (e.g. endianness, compression). Currently 0.</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 bytes</td>
              <td>SectionCount</td>
              <td>Number of following sections (uint32, little-endian)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>6.2 Section layout</h3>
      <p>After the header, the file contains <strong>SectionCount</strong> sections:</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Field</th><th>Size</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>SectionId</td>
              <td>1 byte</td>
              <td>Section kind (see below)</td>
            </tr>
            <tr>
              <td>Reserved</td>
              <td>1 byte</td>
              <td>Alignment / flags (currently 0)</td>
            </tr>
            <tr>
              <td>Length</td>
              <td>4 bytes</td>
              <td>Length of section payload in bytes (uint32, little-endian)</td>
            </tr>
            <tr>
              <td>Payload</td>
              <td>Length bytes</td>
              <td>Section-specific data</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>6.3 Section kinds</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Id</th><th>Name</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td>0x01</td><td>TYPE</td><td>Type table (classes, structs, interfaces, traits).</td></tr>
            <tr><td>0x02</td><td>CONST</td><td>Constant pool (literals, strings, etc.).</td></tr>
            <tr><td>0x03</td><td>METHODSIG</td><td>Method signatures (parameter/return types).</td></tr>
            <tr><td>0x04</td><td>METHODBODY</td><td>Method bodies (bytecode, max stack, locals, exception tables).</td></tr>
            <tr><td>0x05</td><td>METADATA</td><td>Custom metadata (e.g. debug info, language-level attributes).</td></tr>
            <tr><td>0x06</td><td>LINK</td><td>Import/export information for linking modules.</td></tr>
            <tr><td>0x07</td><td>PIPEDEF</td><td>Reserved for pipe-related runtime metadata.</td></tr>
            <tr><td>0x08</td><td>FILTERDEF</td><td>Filter definitions (in/out types, option enums, etc.).</td></tr>
          </tbody>
        </table>
      </div>

      <h3>6.4 Method body encoding (METHODBODY section)</h3>
      <p>Each method body entry contains:</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>Field</th><th>Type</th><th>Description</th></tr>
          </thead>
          <tbody>
            <tr><td>MethodId</td><td>uint32</td><td>Index into the method table.</td></tr>
            <tr><td>MaxStack</td><td>uint16</td><td>Maximum operand stack depth for this method.</td></tr>
            <tr><td>LocalCount</td><td>uint16</td><td>Number of local variables (excluding parameters).</td></tr>
            <tr><td>CodeSize</td><td>uint32</td><td>Length in bytes of the bytecode that follows.</td></tr>
            <tr><td>Code</td><td>byte[CodeSize]</td><td>Sequence of opcodes and immediates.</td></tr>
            <tr><td>ExceptionCount</td><td>uint16</td><td>Number of exception handler entries.</td></tr>
            <tr><td>ExceptionTable</td><td>...</td><td>Handler entries (try/catch/finally ranges).</td></tr>
          </tbody>
        </table>
      </div>

      <h3>6.5 Versioning policy</h3>
      <ul>
        <li>Backward-compatible changes (e.g., adding new section kinds that can be safely ignored by older VMs) increment <strong>VersionMinor</strong>.</li>
        <li>Breaking changes (e.g., restructuring existing sections, changing opcode semantics) increment <strong>VersionMajor</strong>.</li>
        <li><strong>VersionBuild</strong> is for implementation-specific revisions and does not change the logical format.</li>
      </ul>
    </section>

    <!-- 7. Modules & Linking -->
    <section id="vm-ch7" class="chapter">
      <h2>7. Modules and Linking</h2>

      <h3>7.1 Imports and exports</h3>
      <ul>
        <li>Each module can:
          <ul>
            <li><strong>Export</strong> types, methods, and constants.</li>
            <li><strong>Import</strong> external symbols from other modules.</li>
          </ul>
        </li>
        <li>The LINK section encodes:
          <ul>
            <li>Module-level identifier (name, version).</li>
            <li>Export table (symbol kind + name + local index).</li>
            <li>Import table (symbol kind + name + expected signature).</li>
          </ul>
        </li>
      </ul>

      <h3>7.2 Linking strategies</h3>
      <ul>
        <li><strong>Static link (ahead-of-time):</strong>
          <ul>
            <li>Multiple AloeBC modules linked into a single combined image.</li>
            <li>Method and type IDs may be remapped to a global index space.</li>
          </ul>
        </li>
        <li><strong>Dynamic link (at load time):</strong>
          <ul>
            <li>VM loads multiple modules and resolves imports against exports.</li>
            <li>A simple table maps imported symbols to concrete method/type IDs.</li>
          </ul>
        </li>
      </ul>

      <h3>7.3 WASM-level linking</h3>
      <p>
        For WASM-native builds, it is desirable to link Aloe-generated WASM with other language WASM libraries:
      </p>
      <ul>
        <li>The Aloe compiler can:
          <ul>
            <li>Emit WASM modules with explicit imports/exports.</li>
            <li>Use existing WASM linkers/tooling to assemble a final executable module.</li>
          </ul>
        </li>
        <li>This is conceptually separate from AloeBC linking and is specific to the WASM backend.</li>
      </ul>
      <div class="note">
        In the ideal WASM-native path, the VM interpreter is skipped and the resulting .wasm module
        is executed directly by the host runtime.
      </div>
    </section>

    <!-- 8. Memory & GC -->
    <section id="vm-ch8" class="chapter">
      <h2>8. Memory Management and GC</h2>

      <h3>8.1 Overview</h3>
      <ul>
        <li>Aloe language semantics assume:
          <ul>
            <li>Objects are allocated on a managed heap.</li>
            <li><code>delete</code> sets references to null but does not immediately free memory.</li>
            <li>The VM (or underlying runtime) eventually reclaims unreachable objects.</li>
          </ul>
        </li>
        <li>VM-level memory management differs between:
          <ul>
            <li>Native AloeVM implementations.</li>
            <li>WASM-native execution, which can rely on WASM GC (where available).</li>
          </ul>
        </li>
      </ul>

      <h3>8.2 Native AloeVM heap model</h3>
      <p>
        A typical native AloeVM can use a segmented heap model:
      </p>
      <ul>
        <li>Heap is divided into <strong>blocks</strong> (fixed-size regions).</li>
        <li>Within each block, objects are allocated via a bump-pointer allocator.</li>
        <li>Objects are identified by an internal handle (e.g., 64-bit ID) stored in VM references.</li>
      </ul>

      <h3>8.3 Object metadata (conceptual)</h3>
      <ul>
        <li>The memory manager maintains a mapping from object handle to:
          <ul>
            <li>Type descriptor ID.</li>
            <li>Block ID and offset.</li>
            <li>Field layout information (number of reference/value slots).</li>
            <li>Optional reference counts / GC flags.</li>
          </ul>
        </li>
        <li>Structs and classes:
          <ul>
            <li>Struct values may be stored in-place (e.g., as raw bytes in the heap or inside another object).</li>
            <li>Classes are always heap-allocated objects referenced by handles.</li>
          </ul>
        </li>
      </ul>

      <h3>8.4 GC policy (native AloeVM)</h3>
      <p>
        The language spec does not fully fix the GC algorithm, but recommends a pragmatic strategy:
      </p>
      <ul>
        <li><strong>Block-level reclamation:</strong>
          <ul>
            <li>Track how many live objects exist in each heap block.</li>
            <li>If a block’s live count becomes zero, the entire block can be reclaimed at once.</li>
          </ul>
        </li>
        <li><strong>Compaction trigger:</strong>
          <ul>
            <li>If a block’s live object count falls below a small threshold (e.g. ≤ 10 objects), the VM is allowed to:
              <ul>
                <li>Move the remaining objects to a new block.</li>
                <li>Update all references to those objects.</li>
                <li>Free the original block.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Reference tracking:</strong>
          <ul>
            <li>VM must track references from:
              <ul>
                <li>Stacks and locals of all VM threads/tasks.</li>
                <li>Fields of heap objects.</li>
                <li>Static/global variables and constant pools as needed.</li>
              </ul>
            </li>
            <li>The exact algorithm (mark-sweep, reference counting, hybrid, etc.) is left to VM implementations.</li>
          </ul>
        </li>
      </ul>
      <div class="note">
        The Aloe language spec does not expose GC details to user code.
        User code only sees <code>delete</code> (nulling references) and exceptions such as
        <code>OutOfMemoryException</code> when allocation fails.
      </div>

      <h3>8.5 WASM-native GC</h3>
      <ul>
        <li>When Aloe is compiled directly to WASM with GC support:
          <ul>
            <li>Objects, arrays, etc. can be represented as WASM GC-managed references.</li>
            <li>GC is then fully handled by the WASM runtime; AloeVM does not implement its own GC.</li>
          </ul>
        </li>
        <li>Pipes and filters in WASM mode can be represented as <code>externref</code> / <code>funcref</code> values.</li>
        <li>AloeVM bytecode may be bypassed entirely (source → WASM opcodes), but the observable behavior must match Aloe semantics.</li>
      </ul>
    </section>

    <!-- 9. Pipes & Filters in VM -->
    <section id="vm-ch9" class="chapter">
      <h2>9. Pipes and Filters in AloeVM</h2>

      <h3>9.1 Pipe representation</h3>
      <ul>
        <li>A <code>pipe&lt;T&gt;</code> is represented by a <strong>REF_PIPE</strong> handle.</li>
        <li>VM implementation responsibilities:
          <ul>
            <li>Provide thread-safe operations on each pipe (write/next/peek/close).</li>
            <li>Guarantee correct behavior in typical 1-producer / 1-consumer scenarios.</li>
          </ul>
        </li>
        <li>For multi-threaded use:
          <ul>
            <li>Language semantics are defined for the 1–1 case.</li>
            <li>Multi-producer / multi-consumer semantics are either undefined or implementation-specific.</li>
          </ul>
        </li>
      </ul>

      <h3>9.2 Filter representation</h3>
      <ul>
        <li>Filters are not ordinary objects; they have dedicated VM value kind <strong>REF_FILTER</strong>.</li>
        <li>A filter instance points to:
          <ul>
            <li>Filter definition metadata (in/out types, options, bound method).</li>
            <li>Runtime state, if any (e.g., partial buffers for line splitting).</li>
          </ul>
        </li>
      </ul>

      <h3>9.3 Binding filters</h3>
      <p>
        A typical filter definition at the language level:
      </p>
      <pre><code class="language-aloe">
filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(input, output) {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
    }
}
      </code></pre>
      <p>At the VM level:</p>
      <ul>
        <li><code>FILTER_CREATE</code> creates a REF_FILTER handle linked to the <code>lineSplit</code> definition.</li>
        <li><code>FILTER_BIND</code> connects concrete input/output pipes and invokes the <code>bound</code> method.</li>
        <li>Execution strategy:
          <ul>
            <li>Either run synchronously in the caller thread,</li>
            <li>Or schedule on an internal worker (e.g., task pool), depending on implementation and host environment.</li>
          </ul>
        </li>
      </ul>

      <h3>9.4 Standard filter library</h3>
      <div class="note">
        Details for individual standard filters (e.g., <code>utf8</code>, <code>json&lt;T&gt;</code>, <code>lineSplit</code>,
        and their options like <code>JsonOptions.PrettyPrint</code>) are intentionally <strong>not</strong> part of this VM spec.
        They are defined separately in the “Standard Filter Library Specification”.
      </div>
    </section>

    <!-- 10. WASM Mapping -->
    <section id="vm-ch10" class="chapter">
      <h2>10. Mapping AloeVM to WebAssembly</h2>

      <h3>10.1 Design goal</h3>
      <ul>
        <li>Keep AloeVM instructions close to WASM so that:
          <ul>
            <li>Each VM instruction corresponds to either a single WASM opcode or a short sequence.</li>
            <li>For WASM-native builds, the compiler can skip AloeBC and emit WASM directly.</li>
          </ul>
        </li>
      </ul>

      <h3>10.2 Basic mapping examples</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr><th>AloeVM</th><th>WASM (conceptual)</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><code>ADD_I32</code></td>
              <td><code>i32.add</code></td>
            </tr>
            <tr>
              <td><code>SUB_I32</code></td>
              <td><code>i32.sub</code></td>
            </tr>
            <tr>
              <td><code>ADD_F64</code></td>
              <td><code>f64.add</code></td>
            </tr>
            <tr>
              <td><code>EQ_I32</code></td>
              <td><code>i32.eq</code></td>
            </tr>
            <tr>
              <td><code>BR</code></td>
              <td><code>br</code> (with appropriate label index)</td>
            </tr>
            <tr>
              <td><code>BR_IF</code></td>
              <td><code>br_if</code></td>
            </tr>
            <tr>
              <td><code>CALL</code></td>
              <td><code>call</code></td>
            </tr>
            <tr>
              <td><code>RETURN</code></td>
              <td><code>return</code></td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>10.3 Ref types</h3>
      <ul>
        <li>Class, struct, string, pipe, filter references can be represented as:
          <ul>
            <li>WASM <code>externref</code> / <code>anyref</code> (host-managed objects), or</li>
            <li>Indices into a linear memory table, with explicit memory loads/stores.</li>
          </ul>
        </li>
        <li>WASM GC proposal allows direct GC-managed references for Aloe objects; otherwise, a manual heap can be implemented.</li>
      </ul>

      <h3>10.4 Native WASM path</h3>
      <ul>
        <li>In the ideal deployment:
          <ul>
            <li>Aloe compiler translates high-level Aloe constructs → AloeVM-like IR → WASM opcodes.</li>
            <li>No bytecode interpreter is used at runtime.</li>
            <li>Other WASM libraries (from different languages) are linked via WASM tooling.</li>
          </ul>
        </li>
        <li>For debugging or legacy platforms, AloeBC + a WASM-based AloeVM interpreter are still possible:
          <ul>
            <li>AloeVM itself is compiled to WASM, reads AloeBC, and interprets it.</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 11. Errors & Traps -->
    <section id="vm-ch11" class="chapter">
      <h2>11. Errors, Traps, and Exceptions</h2>

      <h3>11.1 VM-level traps</h3>
      <p>
        VM-level traps are unrecoverable faults at the AloeVM level (not language-level exceptions). Examples:
      </p>
      <ul>
        <li>Invalid opcode.</li>
        <li>Stack overflow or stack underflow.</li>
        <li>Corrupted metadata or type tables.</li>
      </ul>
      <p>
        A VM-level trap typically terminates the current program (or aborts the current execution context)
        and may map to a host-level error.
      </p>

      <h3>11.2 Language-level exceptions</h3>
      <ul>
        <li>Language-level exceptions (such as <code>NullReferenceException</code>, <code>OverflowException</code>,
          <code>ZeroDivisionException</code>, etc.) are raised by VM instructions:
          <ul>
            <li>Dereferencing NULL → <code>NullReferenceException</code>.</li>
            <li>Numeric overflow/underflow → <code>OverflowException</code>.</li>
            <li>Division by zero → <code>ZeroDivisionException</code>.</li>
            <li>Invalid format (JSON, etc.) → <code>FormatException</code>.</li>
          </ul>
        </li>
        <li>These exceptions are handled by <code>try/catch/finally</code> constructs at the language level, backed
          by exception tables in method metadata.</li>
      </ul>

      <h3>11.3 Out-of-memory conditions</h3>
      <ul>
        <li>If allocation fails (no free block and GC cannot reclaim enough space), the VM throws <code>OutOfMemoryException</code>.</li>
        <li>In WASM-native mode, behavior depends on the WASM runtime:
          <ul>
            <li>Failure to grow memory, or host-level OOM, may also surface as <code>OutOfMemoryException</code> or a host trap.</li>
          </ul>
        </li>
      </ul>

      <h3>11.4 Guarantees</h3>
      <ul>
        <li>AloeVM guarantees:
          <ul>
            <li>Well-formed AloeBC files (matching the current version) are either:
              <ul>
                <li>Accepted and executed according to this spec, or</li>
                <li>Rejected at load time with a clear reason (unsupported version, inconsistent metadata, etc.).</li>
              </ul>
            </li>
            <li>Within a well-formed program, any undefined behavior at the language level must correspond to
              either:
              <ul>
                <li>A language-level exception, or</li>
                <li>A VM-level trap (in extreme cases such as engine bugs or internal inconsistencies).</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>

      <hr />
      <p>
        This concludes the current draft of the AloeVM Specification. Further chapters (e.g., a complete opcode table,
        formal typing rules, formal semantics) can be added as the implementation evolves.
      </p>
    </section>

  </main>
</div>
</body>
</html>
```
