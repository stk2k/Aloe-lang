```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AloeVM Specification (Draft)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }
    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM Specification</h1>
    <small>(Current draft. Subject to change and extension in the future.)</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. Overview</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. Execution Model</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. VM Value Model</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. Call Stack and Frames</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. Heap and Memory Management Policy</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. Representation of Pipe / Filter</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC Binary Format</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. Instruction Set and WASM Mapping</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. Open Issues / TODO</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. Overview -->
    <section id="vm-ch0" class="chapter">
      <h2>0. Overview</h2>
      <p>
        AloeVM is a <strong>stack-based virtual machine</strong> designed for executing the Aloe language.<br>
        This document defines:
      </p>
      <ul>
        <li>Execution model (stack machine / frame structure)</li>
        <li>VM-level value model (primitives, structs, classes, enums, pipe/filter, etc.)</li>
        <li>Heap and memory management policy</li>
        <li>Representation of pipe / filter on the VM</li>
        <li>AloeBC (Aloe bytecode) binary format</li>
        <li>Policy for integration with WebAssembly (WASM)</li>
      </ul>
      <div class="note">
        AloeVM assumes two runtime variants:
        <ul>
          <li>C# implementation (VM running on .NET)</li>
          <li>WASM-native implementation (code compiled directly to WASM by aloe2wasm)</li>
        </ul>
        This specification mainly defines the behavior of the <br>
        <strong>C# VM implementation + AloeBC</strong>, and for WASM it outlines the policy of<br>
        “mapping the instruction set almost 1:1” and “leaving GC to the WASM runtime”.
      </div>
    </section>

    <!-- 1. Execution Model -->
    <section id="vm-ch1" class="chapter">
      <h2>1. Execution Model</h2>

      <h3>1.1 Stack-machine Model</h3>
      <ul>
        <li>The VM is a stack machine centered around an <strong>operand stack</strong>.</li>
        <li>Arithmetic and comparison instructions pop values from the stack top and push the result back onto the stack.</li>
        <li>Local variables and arguments are stored in a <strong>frame-local area</strong>.</li>
      </ul>

      <h3>1.2 Unit of Execution</h3>
      <ul>
        <li>The unit of execution is a “function (method)”, corresponding to Aloe methods and the main block.</li>
        <li>Each function is registered in a <strong>function table</strong> in AloeBC, and each entry holds:
          <ul>
            <li>Code offset</li>
            <li>Number of local variables</li>
            <li>Number of arguments</li>
            <li>Reference to the exception handler table</li>
          </ul>
        </li>
      </ul>

      <h3>1.3 Exception Handling Model</h3>
      <ul>
        <li>Aloe’s <code>try / catch / finally</code> is lowered into an exception handler table at the VM level.</li>
        <li>Exceptions are handled as <strong>object references</strong> in the VM and trigger stack unwinding when thrown.</li>
        <li>In the WASM implementation, they are mapped to the host’s exception model or to a multi-value return + error-code pattern.</li>
      </ul>

      <h3>1.4 Execution Modes</h3>
      <ul>
        <li><strong>VM Execution Mode</strong>:
          <ul>
            <li>The C# VM implementation directly reads AloeBC and interprets the instructions (or JIT-compiles them) sequentially.</li>
          </ul>
        </li>
        <li><strong>WASM-native Mode</strong>:
          <ul>
            <li>aloe2wasm converts AloeVM instruction sequences to WASM instructions in an almost 1:1 manner, and AloeVM itself does not exist as a separate runtime.</li>
            <li>GC and low-level memory management are delegated to the WASM runtime.</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 2. VM Value Model -->
    <section id="vm-ch2" class="chapter">
      <h2>2. VM Value Model</h2>

      <h3>2.1 Categories of VM Values</h3>
      <p>Values handled on the VM are conceptually divided into the following categories.</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Examples</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Integer (int32)</td>
              <td><code>int</code>, <code>enum</code>, <code>bitfield enum</code></td>
              <td>32-bit signed integer. Enums are always int-based.</td>
            </tr>
            <tr>
              <td>Other integers</td>
              <td><code>byte</code></td>
              <td>May be packed internally into int32.</td>
            </tr>
            <tr>
              <td>Floating point</td>
              <td><code>float</code></td>
              <td>32-bit IEEE 754.</td>
            </tr>
            <tr>
              <td>decimal</td>
              <td><code>decimal</code></td>
              <td>A 128-bit approximate representation with precision roughly comparable to C# decimal (implementation-dependent).</td>
            </tr>
            <tr>
              <td>bool</td>
              <td><code>bool</code></td>
              <td>Internally 1 byte or int32. Comparison instructions can reuse those for int.</td>
            </tr>
            <tr>
              <td>char</td>
              <td><code>char</code></td>
              <td>Unicode code point (implementation may use UTF-16 or UTF-32).</td>
            </tr>
            <tr>
              <td>Object reference</td>
              <td><code>class</code> instance, <code>string</code></td>
              <td>Handle to a heap object (e.g., 64-bit ID).</td>
            </tr>
            <tr>
              <td>Struct</td>
              <td><code>struct</code></td>
              <td>“Chunk of value” on the VM. Implementation may choose inline or boxed representation.</td>
            </tr>
            <tr>
              <td>pipe</td>
              <td><code>pipe&lt;T&gt;</code></td>
              <td>Has a dedicated VM value tag. Implementation may use OS pipes, sockets, etc.</td>
            </tr>
            <tr>
              <td>filter</td>
              <td><code>filter Foo</code></td>
              <td>Has a dedicated VM tag. Wraps a function plus connection metadata.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <strong>enum / bitfield enum</strong> are represented at the VM level <strong>always as int32</strong>.<br>
        The active bits of a bitfield enum are limited to 0–31 (maximum 32 bits).
      </div>

      <h3>2.2 AloeObject and Heap Objects</h3>
      <p>
        In the C# VM implementation, objects on the heap are identified by an <strong>object ID (e.g., 64-bit integer)</strong>.
      </p>
      <ul>
        <li>Objects as VM values:
          <ul>
            <li>On the stack and in locals, only <code>objectId: long</code> is stored (this is the <strong>AloeObject</strong>).</li>
          </ul>
        </li>
        <li>The memory manager maintains metadata mapped from object ID:
          <ul>
            <li>Class/struct <strong>field list (reference slot definitions)</strong></li>
            <li><strong>Value slots</strong> per field (primitive value or another object ID)</li>
            <li>Final field layout after trait composition</li>
          </ul>
        </li>
        <li>Structs can also be handled under the same framework:
          <ul>
            <li>Even for value types, when placed on the heap they can be managed as “field list + value slots”.</li>
            <li>Depending on VM optimizations, they may or may not be inlined on the stack.</li>
          </ul>
        </li>
      </ul>

      <h3>2.3 VM Tags for pipe / filter</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> and <code>filter</code> have <strong>dedicated VM value tags</strong>, separate from ordinary class instances.</li>
        <li>For WASM compatibility, the internal representation should be easy to map to “ref types” (e.g., <code>externref</code>, <code>funcref</code>, <code>anyref</code>).</li>
        <li>A pipe holds, for example, “tail buffer + synchronization primitive”, and a filter holds “bound handler function + in/out metadata”.</li>
      </ul>
    </section>

    <!-- 3. Call Stack and Frames -->
    <section id="vm-ch3" class="chapter">
      <h2>3. Call Stack and Frames</h2>

      <h3>3.1 Frame Structure</h3>
      <p>Each function call creates a “frame”. A frame contains at least:</p>
      <ul>
        <li>Return address (PC of the next instruction to execute)</li>
        <li>Link to the previous frame</li>
        <li>Local variable area</li>
        <li>Argument area</li>
        <li>Temporary value slots (if needed)</li>
      </ul>

      <h3>3.2 Calling Convention (Overview)</h3>
      <ul>
        <li>Call instructions (e.g., <code>CALL</code>) are executed with arguments pushed on the stack.</li>
        <li>After creating the frame, arguments are moved into the local area (or referenced by index while staying on the stack).</li>
        <li>The return value is pushed as a single item onto the stack top.</li>
        <li>Void functions do not push a return value.</li>
      </ul>

      <h3>3.3 Exception Frames</h3>
      <ul>
        <li>Based on the exception handler table, the VM decides how far to unwind the stack.</li>
        <li>After unwinding, it jumps to the catch block entry point and passes the exception object to a local or the stack.</li>
      </ul>
    </section>

    <!-- 4. Heap and Memory Management Policy -->
    <section id="vm-ch4" class="chapter">
      <h2>4. Heap and Memory Management Policy (C# VM Implementation)</h2>

      <h3>4.1 Slot-based Heap Layout</h3>
      <ul>
        <li>The heap in the C# VM implementation is managed as an array of fixed-size slots.</li>
        <li>The bytes per slot are configured via <code>memory.slot_size_bytes</code> in the config file,
          and if it is not specified, the default is <strong>16 bytes</strong>.</li>
        <li>All heap objects start at a slot boundary (slot start address) and occupy
          one or more <strong>contiguous slots</strong>.
          <ul>
            <li>An object’s “length” is managed as a slot count (<code>lengthSlots</code>).</li>
            <li>The actual byte length is <code>lengthSlots × slot_size_bytes</code>.</li>
          </ul>
        </li>
        <li>In the implementation, the heap may be divided into one or more “arenas”.
          <ul>
            <li>Single arena: all objects are managed in one slot array.</li>
            <li>Future optimization may allow separate arenas per size class (16/32/64 bytes, etc.).</li>
          </ul>
        </li>
      </ul>

      <h3>4.2 Handles and the Variable Table</h3>
      <ul>
        <li>As described in Chapter 2, heap objects are identified by an <strong>object ID (handle)</strong>.</li>
        <li>Inside the VM, a <strong>variable table (or object table)</strong> is used to resolve handles to actual heap locations.
          Typically it stores:
          <ul>
            <li>Arena ID</li>
            <li>Head slot index (integer)</li>
            <li>Number of occupied slots (<code>lengthSlots</code>)</li>
            <li>Reference count (refcount)</li>
            <li>Reference to type metadata (class/struct metadata ID)</li>
          </ul>
        </li>
        <li>VM instructions and the runtime handle <strong>handles instead of raw pointers</strong>.
          <ul>
            <li>Access to physical memory is a two-step process: handle → table → head slot address.</li>
            <li>When an object is moved (compacted), only the slot index in the variable table needs updating.</li>
          </ul>
        </li>
      </ul>

      <h3>4.3 Lifetime Management via Reference Counting</h3>
      <ul>
        <li>Each heap object has a <strong>reference count</strong>.</li>
        <li>Typical increments and decrements of the reference count:
          <ul>
            <li>Increment when storing a handle into a local variable or field.</li>
            <li>Decrement when a variable goes out of scope or when a field is overwritten with another value.</li>
          </ul>
        </li>
        <li>When an object’s reference count becomes 0, it is considered “unreachable”, and the slots occupied by that object are handled as follows:
          <ul>
            <li>Clear the contents of its slots to 0 for easy logical treatment as “free”.</li>
            <li>Update the slot state table (e.g., <code>slot_used[i] = false</code>) to mark them as free.</li>
          </ul>
        </li>
        <li>Cyclic references (e.g., <code>A → B → A</code>) cannot be freed by reference counting alone, so they are handled by
          <strong>implementation constraints or future auxiliary GC</strong>:
          <ul>
            <li>The language design is encouraged to make strong cycles harder (ownership / weak references).</li>
            <li>Alternatively a low-priority mark-and-sweep can be used in combination, dedicated to reclaiming cycles only.</li>
          </ul>
        </li>
      </ul>

      <h3>4.4 On-access Sliding Compaction</h3>
      <p>
        To prevent fragmentation, AloeVM performs <strong>“on-access incremental sliding compaction”</strong> on the heap.<br>
        This means that when an object is accessed, the VM may slide that object forward, gradually collecting free slots toward the front.
      </p>
      <ul>
        <li>Instructions that access a variable handle conceptually perform the following steps:
          <ol>
            <li>Look up the variable table from the handle and obtain <code>(arenaId, slotIndex, lengthSlots)</code>.</li>
            <li>Within the same arena, check whether the slots from <code>slotIndex - lengthSlots</code> to <code>slotIndex - 1</code>
              are all free (unused).
              <ul>
                <li>For simplicity, the implementation may just check flags in a “slot state table”.</li>
              </ul>
            </li>
            <li>If that range is completely free:
              <ul>
                <li>Slide the object forward by <code>lengthSlots</code> slots (copy).</li>
                <li>Zero out and mark as free the old region (<code>slotIndex … slotIndex + lengthSlots - 1</code>).</li>
                <li>Update <code>slotIndex</code> in the variable table to <code>slotIndex - lengthSlots</code>.</li>
              </ul>
            </li>
            <li>Access the actual object fields from the updated head slot.</li>
          </ol>
        </li>
        <li>This rule keeps the memory touched per access bounded by “its own size (<code>lengthSlots</code> slots)”.
          <ul>
            <li>It avoids a stop-the-world GC that traverses the entire heap at once,
              and <strong>distributes the cost of defragmentation across accesses</strong>.</li>
          </ul>
        </li>
        <li>Because all objects start on slot boundaries, the layout remains consistent and aligned to slot boundaries after sliding.</li>
        <li>This “on-access sliding” is not mandatory. Implementations may, for example:
          <ul>
            <li>Reduce frequency (perform it only once every N accesses)</li>
            <li>Impose a cap on the maximum number of slots moved per access</li>
          </ul>
        </li>
      </ul>

      <h3>4.5 Allocation Strategy</h3>
      <ul>
        <li>When allocating a new object, the memory manager:
          <ol>
            <li>Computes the required number of slots <code>lengthSlots</code> (<code>ceil(objectSizeBytes / slot_size_bytes)</code>).</li>
            <li>Searches the current arena or across arenas for <strong>enough contiguous free slots</strong>.</li>
            <li>Places the object at the found head slot and updates the slot state table and variable table.</li>
          </ol>
        </li>
        <li>The method of managing free slots is implementation-dependent, but typical approaches include:
          <ul>
            <li>Naive linear scan (for prototype implementation)</li>
            <li>Free-list of contiguous slot ranges</li>
            <li>Bitmap with first-fit / best-fit algorithms</li>
          </ul>
        </li>
        <li>If no sufficient contiguous free slots can be found in any arena:
          <ul>
            <li>Temporarily increase the frequency of on-access sliding to reduce fragmentation.</li>
            <li>Or expand the heap by adding a new arena.</li>
          </ul>
        </li>
      </ul>

      <h3>4.6 <code>delete</code> and Timing of Deallocation</h3>
      <ul>
        <li>The Aloe statement <code>delete x;</code> means “cut the reference from variable <code>x</code> to the handle it holds”,
          and it <strong>does not guarantee</strong> that physical memory is freed at that moment.</li>
        <li>Objects whose reference count has reached 0 become deallocation candidates at the following timing:
          <ul>
            <li>Immediately when the count becomes 0, zero out the slots and mark them as free.</li>
            <li>Or let a low-priority background task free them in order (implementation-dependent).</li>
          </ul>
        </li>
        <li>Therefore, Aloe programs must not assume that heap usage will necessarily drop immediately after <code>delete</code>.
          It is merely a <strong>logical declaration that “this object will not be used anymore”</strong>.</li>
      </ul>

      <h3>4.7 Memory Management in WASM Implementations</h3>
      <div class="note">
        In WASM-native mode, AloeVM’s own slot-based memory management and reference counting are not required.<br>
        GC and memory allocation/deallocation are <strong>delegated to the WASM runtime and host environment</strong>.
      </div>
      <ul>
        <li>Aloe objects can be mapped directly to WASM <code>struct</code> / <code>array</code> / <code>ref</code> types.</li>
        <li>Since GC is handled by WASM GC or the host runtime (e.g., .NET, JVM, JS),
          the slot layout and on-access sliding described in this chapter remain an internal detail of the C# VM implementation only.</li>
        <li>Compilers such as aloe2wasm are recommended to preserve the abstract AloeVM memory model,
          while leaving actual GC to the target environment.</li>
      </ul>
    </section>

    <!-- 5. Pipe / Filter -->
    <section id="vm-ch5" class="chapter">
      <h2>5. VM Representation of Pipe / Filter</h2>

      <h3>5.1 <code>pipe&lt;T&gt;</code></h3>
      <ul>
        <li>At the VM level, <code>pipe&lt;T&gt;</code> is represented as a value with a dedicated <strong>PIPE</strong> tag.</li>
        <li>Internally it is expected to hold:
          <ul>
            <li>Buffer (ring buffer / queue)</li>
            <li>Synchronization primitive (locks, condition variables, etc.)</li>
            <li>Type information of the elements (reference to runtime type info)</li>
          </ul>
        </li>
        <li>The implementation must be thread-safe so that multiple threads can access it safely.</li>
        <li>Possible implementations include:
          <ul>
            <li>OS pipes / sockets</li>
            <li>Ring buffers on memory-mapped files</li>
          </ul>
        </li>
      </ul>

      <h3>5.2 <code>filter</code></h3>
      <ul>
        <li>A filter is represented as a value with a dedicated FILTER tag.</li>
        <li>Conceptually a filter value is a struct that bundles:
          <ul>
            <li>Pointer to a bound function</li>
            <li>Filter definition metadata (input/output types)</li>
          </ul>
        </li>
        <li>User-defined filters are represented using this same mechanism.</li>
      </ul>

      <h3>5.3 Execution Model of Pipeline Statements</h3>
      <pre><code class="language-aloe">
A | filter(F) | B;
      </code></pre>
      <ul>
        <li>The VM lowers this statement into a sequence of “connection construction” instructions.</li>
        <li>A typical flow:
          <ol>
            <li>Resolve the output pipe of <code>A</code>.</li>
            <li>Create an instance of <code>filter(F)</code> and start <code>bound(input, output)</code> as a separate task/thread.</li>
            <li>Connect the output pipe to <code>B</code>.</li>
          </ol>
        </li>
        <li>Depending on the implementation, multiple filters may be processed sequentially in a single thread as an optimization.</li>
      </ul>

      <h3>5.4 Pipe Lifecycle and VM Instructions</h3>
      <p>
        Conceptually, a pipe has a four-phase lifecycle: <strong>create → connect → disconnect → delete</strong>.<br>
        AloeVM clarifies which of these phases are handled by <strong>dedicated instructions</strong> and which are left to the <strong>runtime API</strong>.
      </p>

      <ul>
        <li>Creation</li>
        <li>Connection</li>
        <li>Disconnection</li>
        <li>Deletion (dispose)</li>
      </ul>

      <h4>5.4.1 Creation and Deletion</h4>
      <ul>
        <li><code>pipe&lt;T&gt;</code> itself is represented as a normal heap object on the VM.
          <ul>
            <li>It is placed on the <strong>slot-based heap</strong> (Chapter 4) as a kind of class instance.</li>
          </ul>
        </li>
        <li>Creation:
          <ul>
            <li>At a minimum, a generic object creation instruction (e.g., <code>NEWOBJ</code>) must be sufficient to construct <code>pipe&lt;T&gt;</code>.</li>
            <li>If desired, a dedicated convenience instruction such as <code>PIPE_NEW</code> can be added (see the provisional opcode table in Chapter 7).</li>
          </ul>
        </li>
        <li>Deletion:
          <ul>
            <li>At the language level, <code>delete x;</code> means “cut the reference from variable <code>x</code> to the pipe handle it holds”.</li>
            <li>When the reference count reaches 0, the pipe object is treated as a deallocation candidate just like any other heap object (see Chapter 4).</li>
            <li><strong>No pipe-specific delete instruction (e.g., <code>PIPE_DELETE</code>) is defined</strong>.
              The delete phase is unified under heap management and <code>delete</code>.</li>
          </ul>
        </li>
      </ul>

      <h4>5.4.2 Connection and Disconnection</h4>
      <ul>
        <li>“Connection” and “disconnection” between producers / filters / consumers and pipes are primarily the <strong>responsibility of the runtime</strong>.
          <ul>
            <li>Example: library functions such as <code>Pipe.Connect(pipe, endpoint)</code>, <code>Pipe.Disconnect(pipe, endpoint)</code>.</li>
          </ul>
        </li>
        <li>At the VM level, the following dedicated instructions may be defined as <strong>optional</strong>:
          <ul>
            <li><code>PIPE_CONNECT</code>:
              <ul>
                <li>Stack: <code>…, pipeHandle, endpointHandle → …</code></li>
                <li>Semantics: invokes the runtime’s connection API to logically connect the pipe and the endpoint.</li>
              </ul>
            </li>
            <li><code>PIPE_DISCONNECT</code>:
              <ul>
                <li>Stack: <code>…, pipeHandle, endpointHandle → …</code></li>
                <li>Semantics: invokes the runtime’s disconnection API to detach the endpoint from the pipe.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>These instructions are useful when the compiler wants to <strong>make pipeline construction explicit as instructions</strong>,
          or when it wants to <strong>align the ABI with WASM</strong>.<br>
          Implementations may also treat them as thin wrappers over runtime function calls.</li>
      </ul>

      <h4>5.4.3 Core Pipe-related Instructions</h4>
      <p>The core set of pipe-related VM instructions can be summarized as follows:</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Instruction</th>
              <th>Stack I/O (conceptual)</th>
              <th>Role</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>PIPE_NEW</td>
              <td>… → …, pipeHandle</td>
              <td>Creates a <code>pipe&lt;T&gt;</code> instance and pushes its handle onto the stack.</td>
              <td>Can be emulated with <code>NEWOBJ</code> if not implemented.</td>
            </tr>
            <tr>
              <td>PIPE_SEND</td>
              <td>…, pipeHandle, value → …</td>
              <td>Writes a single element into the pipe (producer-side send).</td>
              <td>Blocking / non-blocking behavior is implementation-dependent.</td>
            </tr>
            <tr>
              <td>PIPE_RECV</td>
              <td>…, pipeHandle → …, value</td>
              <td>Reads a single element from the pipe (consumer-side recv).</td>
              <td>Handling of EOF (special value / exception, etc.) is determined by the runtime spec.</td>
            </tr>
            <tr>
              <td>PIPE_CLOSE</td>
              <td>…, pipeHandle → …</td>
              <td>Closes the writing side of the pipe and notifies EOF downstream.</td>
              <td>Implementation may set a “no more values” flag internally.</td>
            </tr>
            <tr>
              <td>PIPE_CONNECT</td>
              <td>…, pipeHandle, endpointHandle → …</td>
              <td>Logically connects the pipe to a producer / filter / consumer.</td>
              <td>Optional instruction; may be a thin wrapper over a runtime API.</td>
            </tr>
            <tr>
              <td>PIPE_DISCONNECT</td>
              <td>…, pipeHandle, endpointHandle → …</td>
              <td>Detaches the endpoint from the pipe.</td>
              <td>Optional instruction; may be a thin wrapper over a runtime API.</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <ul>
          <li><code>PIPE_CONNECT</code> / <code>PIPE_DISCONNECT</code> are not strictly required. In a minimal AloeVM implementation it is valid to assume “bytecode is executed in a state where pipeline connections have already been established”.</li>
          <li>Defining these as instructions, however, makes it easier for debuggers and tracers to record “when and which endpoints were connected/disconnected”.</li>
          <li>The concrete opcode numbers and 1:1 mapping to WASM instructions are discussed in Chapter 7.</li>
        </ul>
      </div>
    </section>

    <!-- 6. AloeBC Binary Format -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC Binary Format</h2>

      <h3>6.1 Overall Structure</h3>
      <p>AloeBC (Aloe Byte Code) is the binary format that stores compilation results for AloeVM.</p>

      <h3>6.2 Header</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Offset</th>
              <th>Size</th>
              <th>Field</th>
              <th>Contents</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 bytes</td>
              <td>Magic</td>
              <td>ASCII string <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>Major version</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>Minor version</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>Build number</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Reserved</td>
              <td>Reserved (fixed to 0)</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 bytes</td>
              <td>HeaderSize</td>
              <td>Total header size (little-endian)</td>
            </tr>
            <tr>
              <td>14</td>
              <td>4 bytes</td>
              <td>ConstPoolOffset</td>
              <td>Offset to the constant pool</td>
            </tr>
            <tr>
              <td>18</td>
              <td>4 bytes</td>
              <td>TypeTableOffset</td>
              <td>Offset to the type table</td>
            </tr>
            <tr>
              <td>22</td>
              <td>4 bytes</td>
              <td>FuncTableOffset</td>
              <td>Offset to the function table</td>
            </tr>
            <tr>
              <td>26</td>
              <td>4 bytes</td>
              <td>CodeSectionOffset</td>
              <td>Offset to the code section</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>The assumed endianness is <strong>little-endian</strong>.</p>

      <h3>6.3 Constant Pool (Overview)</h3>
      <ul>
        <li>Manages string literals, numeric literals, type information, etc. in a single place.</li>
        <li>Each entry is a variable-length record composed of “tag + length + payload”.</li>
        <li>Example tags:
          <ul>
            <li>0x01: UTF-8 string</li>
            <li>0x02: int32</li>
            <li>0x03: float32</li>
            <li>0x04: decimal</li>
          </ul>
        </li>
      </ul>

      <h3>6.4 Type Table (Overview)</h3>
      <ul>
        <li>Every Aloe type (class / struct / enum / bitfield enum / <code>pipe&lt;T&gt;</code>, etc.) is assigned an ID.</li>
        <li>Enums and bitfield enums are flagged as <strong>int32 value types</strong> at the VM level.</li>
        <li>The number of active bits for a bitfield enum (0–31) may optionally be stored as metadata (used, for example, for warnings).</li>
      </ul>

      <h3>6.5 Function Table and Code Section</h3>
      <ul>
        <li>Function table:
          <ul>
            <li>Function signature (argument types, return type)</li>
            <li>Number of local variables</li>
            <li>Offset and length in the code section</li>
          </ul>
        </li>
        <li>Code section:
          <ul>
            <li>Stores VM instruction sequences as a byte array.</li>
            <li>See Chapter 7 for the details of the instruction set.</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 7. Instruction Set and WASM Mapping -->
    <section id="vm-ch7" class="chapter">
      <h2>7. Instruction Set and WASM Mapping (Overview)</h2>

      <h3>7.1 Instruction Categories</h3>
      <p>The instruction set is expected to be divided roughly into the following categories:</p>
      <ul>
        <li>Stack manipulation
          <ul>
            <li>PUSH, POP, DUP, SWAP, etc.</li>
          </ul>
        </li>
        <li>Arithmetic / bitwise logic
          <ul>
            <li>ADD, SUB, MUL, DIV, MOD</li>
            <li>AND, OR, XOR, SHL, SHR</li>
          </ul>
        </li>
        <li>Comparisons
          <ul>
            <li>CMPEQ, CMPNE, CMPLT, CMPLE, CMPGT, CMPGE</li>
          </ul>
        </li>
        <li>Control flow
          <ul>
            <li>JMP, JMP_IF_TRUE, JMP_IF_FALSE</li>
          </ul>
        </li>
        <li>Function call
          <ul>
            <li>CALL, RET</li>
          </ul>
        </li>
        <li>Object manipulation
          <ul>
            <li>NEWOBJ, GETFIELD, SETFIELD, etc.</li>
          </ul>
        </li>
        <li>Array / collection manipulation (future)</li>
        <li>pipe / filter manipulation (connect, read/write)</li>
      </ul>

      <div class="note">
        The exact opcode numbers and binary layout of the instruction set are<br>
        not yet fixed and will be defined later as a dedicated “instruction set table”.
      </div>

      <h3>7.2 1:1 Mapping Policy to WASM</h3>
      <ul>
        <li>Basic arithmetic and comparison instructions should be mapped to WASM instructions such as <code>i32.add</code>, <code>i32.lt_s</code> in a 1:1 fashion as much as possible.</li>
        <li>Since the stack model matches that of WASM, stack operations can be converted almost directly.</li>
        <li>Exceptions are represented using WASM’s exception handling extension or a combination of error codes and block structures.</li>
        <li>pipe / filter are often implemented using WASM <code>ref</code> types plus host functions.</li>
      </ul>

      <h3>7.3 Role of aloe2wasm</h3>
      <ul>
        <li>Besides the path “Aloe source → AloeBC → AloeVM execution”, there is another path:
          <ul>
            <li>Aloe source → intermediate IR → WASM, a <strong>native WASM build</strong> path.</li>
          </ul>
        </li>
        <li>The closer AloeVM’s instruction set is to WASM, the simpler the compiler implementation can be.</li>
        <li>Ideally, we aim to reach the point where “serializing AloeVM instruction sequences to WASM is enough to run the program”.</li>
      </ul>

      <h3>7.4 Provisional Opcode Table (Excerpt)</h3>
      <p>
        The following is a <strong>provisional opcode table</strong> summarizing representative instructions of AloeVM.<br>
        The numeric opcode assignments are not fixed yet and may change in the future.
      </p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Category</th>
              <th>Instruction</th>
              <th>Stack I/O (conceptual)</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="4">Stack manipulation</td>
              <td>PUSH_CONST</td>
              <td>… → …, value</td>
              <td>Loads a value from the constant pool and pushes it onto the stack.</td>
            </tr>
            <tr>
              <td>POP</td>
              <td>…, value → …</td>
              <td>Discards the stack top.</td>
            </tr>
            <tr>
              <td>DUP</td>
              <td>…, value → …, value, value</td>
              <td>Duplicates the stack top and pushes it once more.</td>
            </tr>
            <tr>
              <td>SWAP</td>
              <td>…, a, b → …, b, a</td>
              <td>Swaps the top two stack elements.</td>
            </tr>

            <tr>
              <td rowspan="3">Integer arithmetic</td>
              <td>ADD_I4</td>
              <td>…, a, b → …, (a + b)</td>
              <td>Adds two int32 values.</td>
            </tr>
            <tr>
              <td>SUB_I4</td>
              <td>…, a, b → …, (a - b)</td>
              <td>Subtracts two int32 values.</td>
            </tr>
            <tr>
              <td>MUL_I4</td>
              <td>…, a, b → …, (a * b)</td>
              <td>Multiplies two int32 values.</td>
            </tr>

            <tr>
              <td rowspan="2">Comparisons</td>
              <td>CMPEQ</td>
              <td>…, a, b → …, bool</td>
              <td>Returns true if <code>a == b</code>, otherwise false.</td>
            </tr>
            <tr>
              <td>CMPLT</td>
              <td>…, a, b → …, bool</td>
              <td>Returns true if <code>a &lt; b</code>.</td>
            </tr>

            <tr>
              <td rowspan="3">Control flow</td>
              <td>JMP</td>
              <td>… → …</td>
              <td>Unconditional jump.</td>
            </tr>
            <tr>
              <td>JMP_IF_TRUE</td>
              <td>…, cond → …</td>
              <td>Jumps if <code>cond</code> is true.</td>
            </tr>
            <tr>
              <td>JMP_IF_FALSE</td>
              <td>…, cond → …</td>
              <td>Jumps if <code>cond</code> is false.</td>
            </tr>

            <tr>
              <td rowspan="2">Calls</td>
              <td>CALL</td>
              <td>…, argN, …, arg1 → …, ret?</td>
              <td>Invokes a function table entry and creates a new frame.</td>
            </tr>
            <tr>
              <td>RET</td>
              <td>…, ret? → …, ret?</td>
              <td>Destroys the current frame and returns to the caller.</td>
            </tr>

            <tr>
              <td rowspan="3">Objects</td>
              <td>NEWOBJ</td>
              <td>…, ctorArgN, …, ctorArg1 → …, objHandle</td>
              <td>Allocates a new instance of the specified type on the heap and runs its constructor.</td>
            </tr>
            <tr>
              <td>GETFIELD</td>
              <td>…, objHandle → …, value</td>
              <td>Reads the value of a field.</td>
            </tr>
            <tr>
              <td>SETFIELD</td>
              <td>…, objHandle, value → …</td>
              <td>Writes a value to a field.</td>
            </tr>

            <tr>
              <td rowspan="6">pipe / filter</td>
              <td>PIPE_NEW</td>
              <td>… → …, pipeHandle</td>
              <td>Creates a <code>pipe&lt;T&gt;</code>. Can be emulated with <code>NEWOBJ</code> if not implemented.</td>
            </tr>
            <tr>
              <td>PIPE_SEND</td>
              <td>…, pipeHandle, value → …</td>
              <td>Writes one element into the pipe.</td>
            </tr>
            <tr>
              <td>PIPE_RECV</td>
              <td>…, pipeHandle → …, value</td>
              <td>Reads one element from the pipe.</td>
            </tr>
            <tr>
              <td>PIPE_CLOSE</td>
              <td>…, pipeHandle → …</td>
              <td>Closes the writing side of the pipe and notifies EOF.</td>
            </tr>
            <tr>
              <td>PIPE_CONNECT</td>
              <td>…, pipeHandle, endpointHandle → …</td>
              <td>Connects the pipe to a producer / filter / consumer (optional instruction).</td>
            </tr>
            <tr>
              <td>PIPE_DISCONNECT</td>
              <td>…, pipeHandle, endpointHandle → …</td>
              <td>Disconnects the endpoint from the pipe (optional instruction).</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="note">
        <ul>
          <li>The instructions listed here are only a “representative excerpt”; the complete instruction set table is expected to be extended in a separate document.</li>
          <li>Opcode number assignments will be finalized together with a detailed examination of the AloeBC binary layout.</li>
          <li>pipe / filter related instructions are defined minimally, consistent with the lifecycle explained in Chapter 5.
            Implementations may treat them as a second interface (syntactic sugar) over runtime APIs.</li>
        </ul>
      </div>
    </section>

    <!-- 8. Open Issues / TODO -->
    <section id="vm-ch8" class="chapter">
      <h2>8. Open Issues / TODO</h2>

      <h3>8.1 Unresolved Topics</h3>
      <ul>
        <li>Opcode assignments and precise binary formats for each instruction (instruction set table)</li>
        <li>Concrete format of the exception handler table (range specification, catch kinds, etc.)</li>
        <li>Inline expansion of structs and the treatment of box/unbox</li>
        <li>Details of slot arena configuration (single arena vs multiple size classes)</li>
        <li>Algorithms when combining reference counting with cycle detection (auxiliary GC)</li>
        <li>Threading model for pipe / filter (one thread per filter vs shared worker threads)</li>
        <li>Standard ABI for pipe / filter on WASM (interfaces with the host)</li>
      </ul>

      <h3>8.2 Future Extensions</h3>
      <ul>
        <li>JIT compilation layer (native code for hot functions)</li>
        <li>Debugger hooks (breakpoints, step execution, variable watch)</li>
        <li>Profiler APIs (measuring execution time and allocated memory)</li>
        <li>Distributed execution (pipes spanning multiple processes/nodes)</li>
      </ul>

      <div class="note">
        The current specification is already aimed at a level where it is possible to implement<br>
        a <strong>prototype Aloe compiler, C# AloeVM implementation, and aloe2wasm</strong>.<br>
        However, the details of the instruction set and memory management are assumed to be refined through experimentation.
      </div>
    </section>

  </main>
</div>
</body>
</html>
```
