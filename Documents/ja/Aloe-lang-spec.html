<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Aloe 言語仕様書（ドラフト、日本語版）</title>
  <meta name="edit-version" content="31">
  <meta name="edit-date" content="2025-12-18T00:36:44+09:00">
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout { display: flex; min-height: 100vh; }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 { font-size: 1.1rem; margin: 0 0 0.4rem; }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li { margin: 0.15rem 0; }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover { background: #1f2937; }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 { margin-top: 1.6em; color: #111827; }
    h1 { margin-top: 0; }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol { padding-left: 1.4em; }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note { font-size: 0.9rem; color: #4b5563; }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- 左側メニュー -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft - Japanese translation + with 拡張 (edit-version 31)</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>概要 (Overview)</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>基本文法 (Basic Syntax)</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>型システム (Type System)</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>数値と変換 (Numbers &amp; Conversions)</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>ブロックとスコープ (Blocks &amp; Scope)</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>変数と定数 (Variables &amp; Constants)</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>フィールド (Fields)</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; valid/invalid</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is 演算子 (is Operator)</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>コレクション (Collections)</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main ブロック (main Block)</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>識別子 <code>_</code> について</a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap キーワード</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>演算子 (Operators)</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>例外 (Exceptions)</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with ブロック</a></li>
        <li><a href="#with-type">4.2.1 型名対象 with 拡張</a></li>
        <li><a href="#valid-invalid">8.1 valid / invalid</a></li>
        <li><a href="#result-access-principle">18.2.3 Result の不正アクセス原則</a></li>
      </ul>
    </nav>
  </aside>

  <!-- 本文 -->
  <main class="content">
    <h1 id="top">Aloe 言語仕様書（ドラフト、日本語版）</h1>
    <p class="note">
      edit-version: 31<br>
      edit-date: 2025-12-18T00:36:44+09:00
    </p>
    <p class="note">
      この文書は、英語版仕様
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>
      をベースにした日本語ドラフトです。<br>
      その上で <strong>4.2 with-blocks</strong> に
      <strong>class / struct / enum を対象にした型ベース with（static メンバー／列挙子への短縮アクセス）</strong>
      の拡張を追加しています。<br>
      さらに、参照の無効状態を <strong>valid/invalid</strong> として扱い、仕様書から <strong>null を排除</strong>しています。<br>
      それ以外の仕様は原文にできるだけ忠実に訳しています。
    </p>

    <hr>

    <h2 id="ch0">0. Overview（概要）</h2>
    <p>
      Aloe は静的型付けのスクリプト言語であり、シンプルで直感的な構文を目指している。<br>
      スタックベースの仮想マシン（AloeVM）上で動作し、主に次のような目標を持つ。
    </p>
    <ul>
      <li>教育用途や小規模アプリケーションで読み書きしやすいこと</li>
      <li>C# ランタイムおよび WebAssembly (WASM) 環境で動作すること</li>
      <li><code>pipe</code> と <code>filter</code> によって、I/O と並行処理を静的型付けのまま制御できること</li>
    </ul>
    <p>特徴：</p>
    <ul>
      <li>静的型付け
        <ul>
          <li><code>var</code> による型推論</li>
          <li><code>let</code> による明示的な型指定</li>
        </ul>
      </li>
      <li>値型 / 参照型
        <ul>
          <li><code>struct</code> ... 値型</li>
          <li><code>class</code> ... 参照型</li>
        </ul>
      </li>
      <li>GC ベースのメモリ管理（具体的なアルゴリズムは VM 実装依存）</li>
      <li>参照の無効状態を <code>invalid</code> として扱う
        <ul>
          <li>参照型は「有効（valid）」「無効（invalid）」の状態を取り得る。</li>
          <li>ソースコード中に null は存在しない（仕様として排除）。</li>
          <li>無効化は <code>delete</code> による糖衣構文で扱う（8章参照）。</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> によるデータフロースタイルの設計</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax（基本文法）</h2>

    <h3>1.1 Comments（コメント）</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> から行末までが行コメント。</li>
      <li><code>/*</code> ～ <code>*/</code> が複数行コメント。</li>
      <li>
        複数行コメントは、開始 <code>/*</code> から最初に現れる <code>*/</code> までを
        まるごとコメントとして扱う。
        コメントの内部に追加の <code>/*</code> や <code>*/</code> が現れても、
        それらはすべてコメントの一部として無視される（ネストしたコメントの構文解析は行わない）。<br>
        したがって、コメント内の「コメント構文」が破綻していても、
        いったん <code>/*</code> が始まってから最初の <code>*/</code> が来るまでは常にコメント扱いとなる。
      </li>
    </ul>

    <h3>1.2 Identifiers（識別子）</h3>
    <ul>
      <li>使用可能文字：英字 (A-Z, a-z)、数字 (0-9)、アンダースコア <code>_</code></li>
      <li>先頭文字は英字または <code>_</code> でなければならない。</li>
      <li>大文字小文字は区別される。</li>
      <li>キーワードと同じ綴りは使用できない。</li>
      <li><code>_</code> で始まる識別子は「プライベート」扱い（外部からは参照しない慣習）。</li>
      <li>ユニコード文字も使用できる（空白や区切り記号などは除外）。</li>
    </ul>

    <h3>1.3 Keywords（キーワード）</h3>
<pre><code>abstract
and
any
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
valid
invalid
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> は使わず、<code>namespace</code> を使用する。</li>
      <li><code>final</code> は廃止され、拡張禁止には <code>sealed</code> を用いる。</li>
      <li><code>instanceof</code> は廃止され、型チェックには <code>is</code> を用いる。</li>
      <li><code>valid</code> / <code>invalid</code> は参照の有効性判定専用の特別なリテラル（8章、9章参照）。</li>
    </ul>

    <h3>1.4 Literals（リテラル）</h3>
    <ul>
      <li>整数リテラル：<code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code> など</li>
      <li>浮動小数点リテラル：<code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>10進リテラル：<code>10.12345678901234567890:d</code> など</li>
      <li>真偽値：<code>true</code>, <code>false</code></li>
      <li>参照有効性：<code>valid</code>, <code>invalid</code>（代入には使えない。判定専用）</li>
      <li>文字列：<code>"Hello, World!"</code></li>
      <li>文字：<code>'A'</code>, <code>'z'</code> など</li>
      <li>配列リテラル：<code>[1, 2, 3]</code></li>
      <li>リストリテラル：<code>(1, 2, 3)</code></li>
      <li>セットリテラル：<code>{1, 2, 3}</code></li>
      <li>マップリテラル：<code>["key1": 10, "key2": 20]</code></li>
      <li>enum リテラル：<code>EnumType.Value1</code></li>
      <li>struct リテラル：<code>Point { x: 0, y: 1 }</code></li>
      <li>オブジェクト生成：<code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator（文の終端）</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>すべての文はセミコロン <code>;</code> で終わる。</li>
      <li>改行による自動セミコロン挿入は行わない。</li>
    </ul>

    <h3>1.6 Whitespace（空白）</h3>
    <ul>
      <li>スペース、タブ、改行はトークン区切りとして扱われる。</li>
      <li>連続する空白は 1 つの区切りとみなされる。</li>
      <li>インデントに意味はない（Python とは異なる）。</li>
    </ul>

    <h3>1.7 Case sensitivity（大文字小文字）</h3>
    <ul>
      <li>識別子とキーワードは大文字小文字を区別する。</li>
      <li>キーワードはすべて小文字（<code>Result</code> を除く）。</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System（型システム）</h2>

    <h3>2.1 Primitive types（プリミティブ型）</h3>
    <p>
      Aloe における「プリミティブ型」は、次の 8 種類とする。
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> - 真偽値。</li>
      <li><code>int</code> / <code>integer</code> - 符号付き整数。</li>
      <li><code>float</code> - 浮動小数点数。</li>
      <li><code>decimal</code> - 高精度 10 進数。</li>
      <li><code>string</code> - 文字列（内部的には Unicode）。</li>
      <li><code>byte</code> - 0-255 の符号なし整数。</li>
      <li><code>char</code> - 1 文字（Unicode スカラ値の一部を表す。詳細は実装依存）。</li>
      <li><code>void</code> - 戻り値なし（戻り値専用）。</li>
    </ul>
    <p>
      <code>any</code> 型を導入し、必要な箇所で任意の型の値を扱える。<br>
      参照の有効性判定には <code>valid</code> / <code>invalid</code> を用いる（8章、9章参照）。<br>
      仕様として null は存在しない。
    </p>

    <h3>2.2 Composite / user-defined types（合成型 / ユーザー定義型）</h3>
    <ul>
      <li>配列：<code>T[]</code></li>
      <li>リスト：<code>T()</code></li>
      <li>セット：<code>T{}</code></li>
      <li>マップ：<code>map&lt;T&gt;</code> または <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>非同期タスク：<code>task</code></li>
      <li>パイプ：<code>pipe&lt;T&gt;</code>（18章参照）</li>
      <li>結果型：<code>Result&lt;T&gt;</code>（18章参照）</li>
    </ul>
    <p><code>any</code> は任意の型の値を扱うための特別な型であり、必要な箇所で利用できる。</p>

    <h3>2.3 Value types / reference types（値型 / 参照型）</h3>
    <ul>
      <li>値型：
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code>（内部表現は int32）</li>
        </ul>
      </li>
      <li>参照型：
        <ul>
          <li><code>class</code></li>
          <li><code>string</code>（実装上は参照型）</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code> など</li>
        </ul>
      </li>
    </ul>

    <h4>any type（any 型）</h4>
    <ul>
      <li><code>any</code> は、<code>void</code> を除く任意の値を保持できる特別な型である。</li>
      <li>任意の型 T の値は <code>any</code> へ暗黙に変換できる（代入・引数渡し）。</li>
      <li><code>any</code> から具体型 T への暗黙変換はない。</li>
      <li><code>if (x is T) { ... }</code> のブロック内では、<code>x</code> を T として扱ってよい（フロー依存の型絞り込み）。</li>
    </ul>

    <h4>Struct restrictions and copying（struct の制約とコピー）</h4>
    <ul>
      <li>struct のフィールドにはプリミティブ型と他の struct のみを持てる。</li>
      <li>class などの参照型フィールドは持てない。</li>
      <li>struct の代入は常に値コピー。</li>
      <li>最大サイズなどは仕様で制限しない。</li>
    </ul>

    <h4>Class vs struct（class と struct）</h4>
    <ul>
      <li>class は struct をフィールドとして持てる。</li>
      <li>class インスタンスを別変数に代入すると参照がコピーされる（オブジェクト本体は共有）。</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions（数値と暗黙変換）</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li><code>int</code> と <code>float</code> を混在させた式の結果は <code>float</code> になる。
        <ul>
          <li><code>int + float -&gt; float</code></li>
          <li><code>int - float -&gt; float</code></li>
          <li><code>int * float -&gt; float</code></li>
          <li><code>int / float -&gt; float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> は高精度な 10 進数。</li>
      <li><code>int</code> / <code>float</code> と混在する式は、必要に応じて <code>decimal</code> に昇格しうる。</li>
      <li>オーバーフロー / アンダーフロー / 精度問題は <code>OverflowException</code> として扱う。</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe にはキャスト構文がない。</li>
      <li>enum と int の暗黙 / 明示変換はいずれも禁止。</li>
      <li>enum と数値型の混在式はコンパイルエラー（bitfield enum のビット演算を除く）。</li>
      <li>内部表現としては enum / bitfield enum はすべて int32。</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>：
        <ul>
          <li>範囲は 0-255。</li>
          <li>byte 同士の演算は許されるが、範囲外はエラーになり得る。</li>
          <li>byte と int の混在式は int に昇格。</li>
        </ul>
      </li>
      <li><code>char</code>：
        <ul>
          <li>char の算術演算は不可。</li>
          <li>比較演算（<code>==</code>, <code>&lt;</code>, <code>&gt;</code> 等）は char 同士のみ。</li>
          <li>数値型との暗黙変換はない。</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>数値オーバーフロー/アンダーフローは NaN/Infinity ではなく例外で扱う。</li>
      <li><code>ZeroDivisionException</code> は 0 / 0.0 で常に投げる。</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope（ブロックとスコープ）</h2>

    <p>
      ブロックは <code>{</code> と <code>}</code> で区切られ、各ブロックが新しいスコープを導入する。
    </p>
    <ul>
      <li><code>main</code> ブロック</li>
      <li>クラス定義ブロック</li>
      <li>メソッド定義ブロック</li>
      <li>任意の <code>{ ... }</code> ブロック</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing（静的スコープとシャドウイング）</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // フィールドをシャドウ
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe は静的（レキシカル）スコープ。</li>
      <li>内側ブロックで同名変数を宣言すると、外側の変数をシャドウする。</li>
      <li>フィールド名とローカル変数名がぶつかった場合、ローカル変数が優先される。
        フィールドは <code>this.</code> で参照する。</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks（メンバー省略記法）</h3>
    <p>
      Aloe には、同一オブジェクトのメンバーアクセスを簡潔に書くための
      <code>with</code> ブロックがある。
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li><code>with (expr) { ... }</code> ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>(expr).Member</code> の省略形。</li>
          <li><code>expr</code> はブロックの先頭で 1 度だけ評価され、内部一時変数に保持される。</li>
        </ul>
      </li>
      <li>ネストした <code>with</code> ブロック：
        <ul>
          <li>内側の <code>with</code> が <code>.</code> の解決対象をシャドウする。</li>
          <li>外側オブジェクトへは通常の変数名でアクセスできる。</li>
        </ul>
      </li>
      <li>C# の <code>using</code> スタイルのように、同じブロックに複数の <code>with</code> を並べられる：</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";
}
</code></pre>
    <ul>
      <li><strong>解決順序は「左から右」</strong>とする。</li>
      <li><code>.Member</code> は、左の対象から順に探索して最初に見つかったものに解決される。</li>
      <li>同じ <code>.Member</code> が複数対象に存在して解決が曖昧になる場合は、<strong>必ずコンパイルエラー</strong>。</li>
    </ul>
    <p>
      <code>with</code> はあくまで構文糖衣であり、意味的にはすべて
      明示的な <code>obj.member</code> 呼び出しに書き換えた上で
      型チェック・コード生成を行うことができる。
    </p>

    <h4 id="with-type">4.2.1 Type-based with（class / struct / enum の static / 列挙子ショートカット）</h4>
    <p>
      通常の <code>with (expr)</code> に加えて、<strong>型名</strong> を対象にした
      <code>with</code> を利用できる。
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>ここで <code>TypeName</code> は次のいずれか：</p>
    <ul>
      <li><code>class</code> 型</li>
      <li><code>struct</code> 型</li>
      <li><code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>この場合、<code>with</code> は「型コンテキスト with」として解釈される：</p>
    <ul>
      <li><code>()</code> 内の式は実行時に値として評価されない。
        <ul>
          <li>コンパイラは <code>TypeName</code> を型として解決し、インスタンス生成などは行わない。</li>
        </ul>
      </li>
      <li>ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>TypeName.Member</code> の省略形。</li>
          <li>対象となる <code>Member</code> は
            <ul>
              <li>static フィールド</li>
              <li>static メソッド</li>
              <li>enum / bitfield enum の列挙子</li>
            </ul>
          </li>
          <li>型ベース with 内でインスタンスメンバーにアクセスすることはコンパイルエラー。</li>
        </ul>
      </li>
    </ul>
    <p>
      型ベース with も複数ターゲット構文に混在させられる。
      この場合も解決順序は左から右であり、曖昧であればコンパイルエラーとする。
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants（変数と定数）</h2>

    <h3>5.1 var（型推論）</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>変数の型は右辺の式から推論される。</li>
      <li><code>var x = 1;</code> は常に <code>int</code>。</li>
      <li><code>var x = 1.0;</code> は <code>float</code> として扱われる。</li>
      <li><code>valid</code> / <code>invalid</code> は代入・初期化に使用できない（コンパイルエラー）。</li>
      <li><code>any</code> 型の式を右辺に置いた場合、推論結果の型も <code>any</code> になる。</li>
    </ul>

<pre><code>function SomeFunc(): any {
    return 123;
}

function main(args: string[]): int {
    var x = 1;            // int
    var a = 123;          // int
    var v = SomeFunc();   // any
    return 0;
}
</code></pre>

    <h3>5.2 let（明示的な型）</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>
    <ul>
      <li><code>let x: Foo = invalid;</code> のような無効値代入・初期化はコンパイルエラー（8章参照）。</li>
    </ul>

    <h3>5.3 Constants（const）</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> 変数は再代入不可。</li>
      <li>const には型注釈が必須。</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields（フィールド宣言）</h2>
    <p>class / struct のフィールドは <code>field</code> キーワードで宣言する。</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id;
    }
    method change(): void {
        this.count = this.count + 1;
        // this.id = 2; // NG
    }
}
</code></pre>
    <ul>
      <li><code>field</code> ... 通常のフィールド。</li>
      <li><code>readonly field</code> ... コンストラクタ内のみ代入可、それ以降は読み取り専用。</li>
      <li>struct / class の両方で同じ意味。</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class は参照型。</li>
      <li><code>sealed class</code> は <code>extends</code> による継承不可。</li>
      <li>単一継承のみサポート。</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>struct は値型。</li>
      <li>フィールドはプリミティブ型か他の struct に限定（参照型フィールドは禁止）。</li>
      <li>struct のコピーは常に値コピー。</li>
      <li>struct の継承はサポートしない（<code>sealed struct</code> は「拡張禁止」マーカー）。</li>
    </ul>

    <h4>Struct layout annotations: @StructLayout / @FieldOffset</h4>
    <p>
      ネイティブコードとの相互運用などで、struct のメモリレイアウトを制御したい場合のために、
      struct には限定的なアノテーション <code>@StructLayout</code> / <code>@FieldOffset</code> を付与できる。
    </p>
<pre><code>@StructLayout("Explicit")
struct NativePoint {
    @FieldOffset(0) field X: int;
    @FieldOffset(4) field Y: int;
}
</code></pre>

    <h4>7.2.1 汎用アノテーション機構（annotation 定義）</h4>
    <p>
      Aloe では、組み込みアノテーションに加えて、ユーザが独自のアノテーションを定義・利用できる。
      アノテーションは <code>annotation</code> 宣言で定義する。
    </p>
<pre><code>annotation MyAnnotation {
    text:   "アノテーションテキスト";
    target: TargetKind;
    params: map&lt;string/any&gt;;

    build:  function (ctx: AnnotationBuildContext): void {
    }
}
</code></pre>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>with による trait の適用</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello();
</code></pre>

    <h4>非破壊的な追加 / 削除（+ / -）</h4>
<pre><code>var obj2 = obj + Trait_A;
var obj3 = obj2 - Trait_A;
</code></pre>

    <h4>as によるエイリアス</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello();
</code></pre>

    <h4>Trait conflicts（競合）</h4>
    <ul>
      <li>複数 trait が同名フィールド / メソッドを定義する場合、右側に記述した trait が左側の定義を上書きする。</li>
      <li>上書きを避けたい場合は、<code>as a</code> のようなエイリアスを用いて競合しない別名としてアクセスする。</li>
    </ul>

    <h4>trait の expects 句</h4>
<pre><code>interface IHasId {
    method GetId(): int;
}

trait HasIdFormatting expects IHasId {
    method PrintId(): void {
        print("ID = " + this.GetId());
    }
}
</code></pre>

    <hr>

    <h2 id="ch8">8. delete &amp; valid/invalid</h2>

    <h3 id="valid-invalid">8.1 valid / invalid（参照の有効状態）</h3>
    <p>
      Aloe の参照型は「有効（valid）」「無効（invalid）」の状態を取り得る。<br>
      仕様として null は存在しない。
    </p>
    <ul>
      <li><code>valid</code> / <code>invalid</code> は参照の有効性を判定するための特別なリテラルである。</li>
      <li><strong><code>valid</code> / <code>invalid</code> は代入・初期化・引数渡しに使用できない。</strong>
        <ul>
          <li><code>x = invalid;</code> や <code>var x = invalid;</code> はコンパイルエラー。</li>
        </ul>
      </li>
      <li>参照の有効性判定は <code>is</code> 演算子を用いる（9章参照）。</li>
    </ul>

    <h3>8.2 delete（参照の無効化）</h3>
<pre><code>var obj = new FizzBuzz();
delete obj;
</code></pre>
    <ul>
      <li><code>delete obj;</code> は「参照変数 <code>obj</code> を無効化する」コマンドである。</li>
      <li>VM レベルでは <code>delete obj;</code> の実行後、<code>obj</code> は <strong>invalid 状態</strong> となる。</li>
      <li><code>delete</code> は参照変数に対する操作であるため、同一オブジェクトを参照している別の参照変数には干渉しない。</li>
      <li>オブジェクトの実際の回収（解放）は実行系が決定する（GC）。</li>
      <li><code>obj</code> がすでに invalid の場合、<code>delete obj;</code> は無効果であり例外を送出してはならない。</li>
      <li><strong>invalid 状態の参照をデリファレンス（メンバーアクセス / 呼び出し）した場合、実行時に例外を投げる。</strong>
        <ul>
          <li>例外型は <code>InvalidReferenceException</code> とする（16章参照）。</li>
        </ul>
      </li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator（is 演算子）</h2>
<pre><code>if (obj is FizzBuzz) {
}

if (obj is ILogger) {
}

if (obj is Trait_A) {
}

if (obj is valid) {
}

if (obj is invalid) {
}
</code></pre>
    <ul>
      <li><code>is</code> は実行時の型チェックを行う。</li>
      <li>継承関係（Derived は Base としても扱う）を考慮する。</li>
      <li>インタフェースや trait に対しても使用できる。</li>
      <li><code>obj is valid</code> / <code>obj is invalid</code> は参照の有効状態を判定する。</li>
      <li><strong><code>is</code> 演算子の左辺は、必ず「式（値）」でなければならない。</strong>
        <ul>
          <li>クラス名・構造体名・インタフェース名・trait 名そのものを左辺に書くことはできない。</li>
        </ul>
      </li>
      <li>曖昧な名前解決（どの型やメンバーを指すかが確定しない状態）は <strong>必ずコンパイルエラー</strong>（17章の名前解決参照）。</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections（配列 / リスト / セット / マップ）</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>内部表現は常に int32。</li>
      <li>enum 型も型ベース with の対象となり、<code>with (Color) { Red; }</code> などで列挙子に短縮アクセスできる。</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) 記法</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,
}
</code></pre>
    <ul>
      <li><code>b(n)</code> はビット n（<code>1 &lt;&lt; n</code>）を表す。</li>
      <li><code>bitfield enum</code>で使用可能なビットは最大 32（n は 0-31）。</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block（エントリポイント）</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0;
}
</code></pre>
    <ul>
      <li>プログラムのエントリポイント。</li>
      <li><code>args</code> はコマンドライン引数。</li>
      <li><code>main</code> ブロックは必ず <code>function main(args: string[]): int</code> の形で宣言し、
          戻り値は <code>int</code> 型の <code>return</code> 文で指定する。</li>
    </ul>

    <hr>

    <h2 id="ch13">13. 識別子 <code>_</code> について</h2>
    <p>
      以前の版で検討していた「特別な一時変数 <code>_</code>」の仕様は採用しない。<br>
      現行仕様では、<code>_</code> は通常の識別子として扱われ、特別な意味は持たない。
    </p>
    <ul>
      <li><code>_</code> を使用するには、他の変数と同様に宣言が必要である。</li>
      <li><code>with</code> ブロックにおいても <code>_</code> に特別な意味はなく、短縮アクセスは <code>.Member</code> のみで表す。</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword（swap キーワード）</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a);
print(b);
</code></pre>

    <hr>

    <h2 id="ch15">15. Operators（演算子）</h2>

    <h3>15.1 優先順位（高い順）</h3>
    <ol>
      <li>メンバー / 呼び出し：<code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>単項：<code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>乗除：<code>*</code>, <code>/</code>, <code>%</code></li>
      <li>加減：<code>+</code>, <code>-</code></li>
      <li>シフト：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>関係：<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>等価：<code>==</code>, <code>!=</code></li>
      <li>ビット AND：<code>&amp;</code></li>
      <li>ビット XOR：<code>^</code></li>
      <li>ビット OR：<code>|</code>（pipeline 文では別語義）</li>
      <li>論理 AND：<code>&amp;&amp;</code>（エイリアス：<code>and</code>）</li>
      <li>論理 OR：<code>||</code>（エイリアス：<code>or</code>）</li>
      <li>代入：<code>=</code></li>
    </ol>

    <hr>

    <h2 id="ch16">16. Exceptions（例外）</h2>
<pre><code>try {
}
catch (e) {
}
finally {
}
</code></pre>

    <h3>16.1 標準例外の概要</h3>
<pre><code>Exception
+- SystemException
|  +- InvalidReferenceException
|  +- IndexOutOfBoundsException
|  +- OverflowException
|  +- ZeroDivisionException
|  +- InvalidOperationException
|  +- NotImplementedException
|  +- TimeoutException
|  +- ArgumentException
|  |  +- ArgumentNullException
|  |  +- ArgumentOutOfRangeException
|  +- FormatException
+- IOException
   +- FileNotFoundException
   +- EndOfStreamException
   +- IOException (general)
</code></pre>
    <ul>
      <li><code>InvalidReferenceException</code> は、invalid 参照のデリファレンスで投げる（8章参照）。</li>
      <li><code>InvalidOperationException</code> は、不正な状態での操作（例：<code>Result</code> の状態と合わないアクセスなど）に用いる。</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>

    <h3>17.1 Module（モジュール / コンパイル単位）</h3>
    <p>
      Aloe における <strong>モジュール</strong> は、コンパイル対象となる 1 つのソースファイルを指す。
      モジュール名やファイルパスなどはビルドツール側の責務とする。
    </p>

    <h3>17.2 ファイル構造の制約</h3>
<pre><code>import Foo.Bar;
import Aloe.Core.Logging;
import Aloe.Json.*;
import MyCompany.Project.Module;

namespace My.App {
}
</code></pre>

    <h3>17.3 namespace のルール</h3>
    <ul>
      <li>1 モジュールにつき、<strong><code>namespace</code> 文はちょうど 1 回だけ</strong> 許可される。</li>
      <li><strong>namespace のネスト構文は禁止</strong>とする。</li>
    </ul>

    <h3>17.4 import のルール</h3>
    <ul>
      <li><code>import</code> はファイル先頭にのみ書ける。</li>
      <li>相対 import はサポートしない。</li>
    </ul>

    <h3>17.5 名前解決の優先順位（固定）</h3>
    <p>
      ある識別子 <code>X</code> を解決するときの優先順位は次の通りとする（実装依存ではない）。
    </p>
    <ol>
      <li>ローカルスコープ（ローカル変数・パラメータ、そのブロック内の宣言）</li>
      <li>現在のクラス / struct / trait / function 自身のメンバー</li>
      <li>現在の namespace 内の宣言（同じ namespace を共有する他モジュールを含む）</li>
      <li><code>import</code> によって導入された公開シンボル</li>
    </ol>
    <p>
      この優先順位で複数の候補が見つかり、どれを指しているかが曖昧になる場合は
      <strong>必ずコンパイルエラー</strong>とする。
    </p>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters（パイプとフィルタ）</h2>

    <p>
      Aloe は <code>pipe&lt;T&gt;</code> と <code>filter(...)</code> を用いて、
      ストリーミング処理を構成する。
    </p>

    <h3>18.1 pipe&lt;T&gt; の基本</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> は T 型要素のストリーム。</li>
      <li>pipe は共有メモリではなく値コピーを前提とする。</li>
    </ul>

    <h3>18.2 Result&lt;T&gt; と ROP の概要</h3>
    <p>
      Aloe では、パイプラインやフィルタにおけるエラー処理や分岐を
      <strong>Result&lt;T&gt;</strong> 型で扱える。
    </p>

    <h4>18.2.1 Result&lt;T&gt; の型仕様</h4>
<pre><code>class Result&lt;T&gt; {
    field Success: bool;
    field Value: T;
    field ErrorMessage: string;

    static method Ok(value: T): Result&lt;T&gt;;
    static method Error(message: string): Result&lt;T&gt;;
}
</code></pre>
    <ul>
      <li><code>Success</code> が <code>true</code> の場合：<code>Value</code> が有効。</li>
      <li><code>Success</code> が <code>false</code> の場合：<code>ErrorMessage</code> が有効で、<code>Value</code> へのアクセスは不正。</li>
      <li><code>Result&lt;void&gt;</code> については、成功のみを表すために <code>Result&lt;void&gt;.Ok()</code>（引数なし）を特別に許可する。</li>
    </ul>

    <h4>18.2.2 Result を強制する範囲（パイプ内のみ）</h4>
    <ul>
      <li><strong>filter / producer / consumer の <code>bound</code> は Result を返すことが必須</strong>である。</li>
      <li>この規則に違反した場合は <strong>コンパイルエラー</strong>とする。</li>
      <li>通常の関数・メソッドは戻り値は自由であり、Result を強制しない。
        失敗時のふるまい（例外を投げる等）はその関数・メソッド仕様による。</li>
    </ul>

    <h4 id="result-access-principle">18.2.3 Result の不正アクセス原則（案 A）</h4>
    <p>
      <code>Result&lt;T&gt;</code> の不正アクセス（例：<code>Success == false</code> のときに <code>Value</code> を読む）については、
      次の原則で扱う。
    </p>
    <ul>
      <li>コンパイラが不正アクセスであることを <strong>静的に確定できる</strong> 場合は、<strong>コンパイルエラー</strong>としてよい。</li>
      <li>静的に確定できない場合は、実行時に <strong><code>InvalidOperationException</code></strong> を投げる。</li>
      <li>どこまで静的に確定するか（解析の強さ）は実装依存だが、上記の二段階原則は固定とする。</li>
    </ul>

    <h3>18.3 filter(...) の基本と定義</h3>
    <p><code>filter(F)</code> はパイプライン中の中間変換ステージ。</p>

    <h4>18.3.1 フィルタ定義（filter 定義文）</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    options: LineSplitOptions;

    field _buffer: string = "";

    constructor(opts: LineSplitOptions) {
    }

    bound(input, output): Result&lt;void&gt; {
        output.close();
        return Result&lt;void&gt;.Ok();
    }
}
</code></pre>
    <ul>
      <li><code>bound(input, output)</code> の戻り値の型は <strong><code>Result&lt;T&gt;</code>（またはその派生）でなければならない</strong>。
        違反はコンパイルエラー。</li>
    </ul>

    <h4>18.3.2 フィルタオプション（filter オプション指定）</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>オプションは <code>:</code> の後に <code>|</code> でつなげて指定。</li>
      <li>（オプション名の例は互換のため残す。null は言語仕様としては存在しない。）</li>
    </ul>

    <h3>18.4 パイプライン文と <code>|</code> / パイプ with 演算子 <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>

    <h4>18.4.1 パイプ with 演算子 <span class="operator">|&gt;</span></h4>
<pre><code>users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>

    <h3>18.6 map による要素変換（pipe 用）</h3>
<pre><code>function toName(u: User): string {
    return u.Name;
}
names = users | map(toName);
</code></pre>

    <h3>18.7 コレクションに対するテンプレート map</h3>
<pre><code>customers = users | map Customer {
    Name    = "FixedName";
    Created = now();
    BaseUrl = base.ApiEndpoint;
};
</code></pre>
    <ul>
      <li>テンプレ map の禁止事項（例：要素参照、要素依存の分岐、未定義の副作用など）は <strong>基本コンパイルエラー</strong>とする。</li>
    </ul>

    <hr>

    <h2 id="editor-notes">Appendix: 生成AI 向け編集ポリシー（仕様書本文ではない）</h2>
    <p class="note">
      <strong>生成AI向け共通編集ポリシー（Aloe 言語仕様書 / AloeVM 仕様書）：</strong><br>
      ・この文書と AloeVM 仕様書は、常に同じ編集ポリシーで運用する。<br>
      ・日本語版・英語版の内容（章構成・見出し・本文の意味）は常に一致させる（片方だけを勝手に簡略化 / 拡張しない）。<br>
      ・<code>edit-version</code> は日本語版・英語版で共通とし、仕様本文（サンプルを含む）を変更したときだけ +1 する。減らしたり巻き戻したりしない。<br>
      ・<code>edit-date</code> には、編集を反映した「その瞬間の Asia/Tokyo の現在時刻」を ISO 8601 形式（YYYY-MM-DDThh:mm:ss+09:00）で必ず書く。推測や他タイムゾーンの時刻を書いてはいけない。<br>
      ・関係ない箇所については原則変更禁止。意味が同じでも、変数名やメソッド名、文言を「良かれと思って」書き換えない。<br>
      ・新しい仕様追加や既存仕様の意味が変わる修正をしたくなった場合は、必ず一度ユーザーに相談し、合意を取ってから反映する。<br>
      ・直前にユーザーが「正」として提示した全文 HTML を常に正本とみなし、その版に対する最小限の差分だけを適用する。<br>
      ・もし直前の HTML が手元で再現できなくなった場合や、どこまでが最新かわからなくなった場合は、編集を続けず、必ずユーザーに確認する。<br>
      ・HTML 内に絵文字や外字を使用しない。日本語文字は第一水準・第二水準までとする。<br>
    </p>

  </main>
</div>
</body>
</html>
