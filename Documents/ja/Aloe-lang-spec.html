<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Aloe 言語仕様書（ドラフト、日本語版）</title>
  <meta name="edit-version" content="19">
  <meta name="edit-date" content="2025-12-06T18:18:12+09:00">
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
    .operator {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- 左側メニュー -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • Japanese translation + with 拡張</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>概要 (Overview)</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>基本文法 (Basic Syntax)</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>型システム (Type System)</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>数値と変換 (Numbers &amp; Conversions)</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>ブロックとスコープ (Blocks &amp; Scope)</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>変数と定数 (Variables &amp; Constants)</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>フィールド (Fields)</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is 演算子 (is Operator)</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>コレクション (Collections)</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main ブロック (main Block)</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>一時変数 <code>_</code> (Temp Variable)</a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap キーワード</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>演算子 (Operators)</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>例外 (Exceptions)</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with ブロック</a></li>
        <li><a href="#with-type">4.2.1 型名対象 with 拡張</a></li>
      </ul>
    </nav>
  </aside>

  <!-- 本文 -->
  <main class="content">
    <h1 id="top">Aloe 言語仕様書（ドラフト、日本語版）</h1>
    <p class="note">
      この文書は、英語版仕様
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>
      をベースにした日本語ドラフトです。<br>
      その上で <strong>4.2 with-blocks</strong> に
      <strong>class / struct / enum を対象にした型ベース with（static メンバー／列挙子への短縮アクセス）</strong>
      の拡張を追加しています。<br>
      それ以外の仕様は原文にできるだけ忠実に訳しています。
    </p>

    <hr>

    <h2 id="ch0">0. Overview（概要）</h2>
    <p>
      Aloe は静的型付けのスクリプト言語であり、シンプルで直感的な構文を目指している。<br>
      スタックベースの仮想マシン（AloeVM）上で動作し、主に次のような目標を持つ。
    </p>
    <ul>
      <li>教育用途や小規模アプリケーションで読み書きしやすいこと</li>
      <li>C# ランタイムおよび WebAssembly (WASM) 環境で動作すること</li>
      <li><code>pipe</code> と <code>filter</code> によって、I/O と並行処理を静的型付けのまま制御できること</li>
    </ul>
    <p>特徴：</p>
    <ul>
      <li>静的型付け
        <ul>
          <li><code>var</code> による型推論</li>
          <li><code>let</code> による明示的な型指定</li>
        </ul>
      </li>
      <li>値型 / 参照型
        <ul>
          <li><code>struct</code> … 値型</li>
          <li><code>class</code> … 参照型</li>
        </ul>
      </li>
      <li>GC ベースのメモリ管理（具体的なアルゴリズムは VM 実装依存）</li>
      <li><code>= null</code> をソースコード中に直接書かない
        <ul>
          <li>参照型は内部的には null を取り得るが、<code>delete</code> による糖衣構文で扱う。</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> によるデータフロースタイルの設計</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax（基本文法）</h2>

    <h3>1.1 Comments（コメント）</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> から行末までが行コメント。</li>
      <li><code>/*</code> ～ <code>*/</code> が複数行コメント。</li>
      <li>
        複数行コメントは、開始 <code>/*</code> から最初に現れる <code>*/</code> までを
        まるごとコメントとして扱う。
        コメントの内部に追加の <code>/*</code> や <code>*/</code> が現れても、
        それらはすべてコメントの一部として無視される（ネストしたコメントの構文解析は行わない）。<br>
        したがって、コメント内の「コメント構文」が破綻していても、
        いったん <code>/*</code> が始まってから最初の <code>*/</code> が来るまでは常にコメント扱いとなる。
      </li>
    </ul>

    <h3>1.2 Identifiers（識別子）</h3>
    <ul>
      <li>使用可能文字：英字 (A–Z, a–z)、数字 (0–9)、アンダースコア <code>_</code></li>
      <li>先頭文字は英字または <code>_</code> でなければならない。</li>
      <li>大文字小文字は区別される。</li>
      <li>キーワードと同じ綴りは使用できない。</li>
      <li><code>_</code> で始まる識別子は「プライベート」扱い（外部からは参照しない慣習）。</li>
      <li>ユニコード文字も使用できる（空白や区切り記号などは除外）。</li>
    </ul>

    <h3>1.3 Keywords（キーワード）</h3>
<pre><code>abstract
and
as
async
bitfield
break
case
catch
class
const
construct
constructor
continue
default
delete
do
else
enum
expects
extends
false
field
filter
finally
for
function
if
import
implements
in
interface
is
let
main
map
match
method
namespace
new
null
options
or
override
pipe
private
protected
public
readonly
return
Result
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
virtual
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> は使わず、<code>namespace</code> を使用する。</li>
      <li><code>final</code> は廃止され、拡張禁止には <code>sealed</code> を用いる。</li>
      <li><code>instanceof</code> は廃止され、型チェックには <code>is</code> を用いる。</li>
    </ul>

    <h3>1.4 Literals（リテラル）</h3>
    <ul>
      <li>整数リテラル：<code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code> など</li>
      <li>浮動小数点リテラル：<code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>10進リテラル：<code>10.12345678901234567890:d</code> など</li>
      <li>真偽値：<code>true</code>, <code>false</code></li>
      <li>文字列：<code>"Hello, World!"</code></li>
      <li>文字：<code>'A'</code>, <code>'z'</code> など</li>
      <li>null リテラル：<code>null</code></li>
      <li>配列リテラル：<code>[1, 2, 3]</code></li>
      <li>リストリテラル：<code>(1, 2, 3)</code></li>
      <li>セットリテラル：<code>{1, 2, 3}</code></li>
      <li>マップリテラル：<code>["key1": 10, "key2": 20]</code></li>
      <li>enum リテラル：<code>EnumType.Value1</code></li>
      <li>struct リテラル：<code>Point { x: 0, y: 1 }</code></li>
      <li>オブジェクト生成：<code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator（文の終端）</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>すべての文はセミコロン <code>;</code> で終わる。</li>
      <li>改行による自動セミコロン挿入は行わない。</li>
    </ul>

    <h3>1.6 Whitespace（空白）</h3>
    <ul>
      <li>スペース、タブ、改行はトークン区切りとして扱われる。</li>
      <li>連続する空白は 1 つの区切りとみなされる。</li>
      <li>インデントに意味はない（Python とは異なる）。</li>
    </ul>

    <h3>1.7 Case sensitivity（大文字小文字）</h3>
    <ul>
      <li>識別子とキーワードは大文字小文字を区別する。</li>
      <li>キーワードはすべて小文字（<code>Result</code> を除く）。</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System（型システム）</h2>

    <h3>2.1 Primitive types（プリミティブ型）</h3>
    <p>
      Aloe における「プリミティブ型」は、次の 7 種類とする。
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – 真偽値。</li>
      <li><code>int</code> / <code>integer</code> – 符号付き整数。</li>
      <li><code>float</code> – 浮動小数点数。</li>
      <li><code>decimal</code> – 高精度 10 進数。</li>
      <li><code>string</code> – 文字列（内部的には Unicode）。</li>
      <li><code>null</code> – 「値が存在しない」ことを表す特別な型兼値。</li>
      <li><code>void</code> – 戻り値なし（メソッド戻り値専用）。</li>
    </ul>
    <p>
      <code>any</code> 型は存在せず、動的型付けはサポートしない。<br>
      <code>char</code> や <code>byte</code> は言語としてはサポートされるが、プリミティブ型のカテゴリからは外し、
      数値と変換の章（3 章）で別途扱う値型とする。
    </p>

    <h3>2.2 Composite / user-defined types（合成型 / ユーザー定義型）</h3>
    <ul>
      <li>配列：<code>T[]</code></li>
      <li>リスト：<code>T()</code></li>
      <li>セット：<code>T{}</code></li>
      <li>マップ：<code>map&lt;T&gt;</code> または <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>非同期タスク：<code>task</code></li>
      <li>パイプ：<code>pipe&lt;T&gt;</code>（18章参照）</li>
      <li>結果型：<code>Result&lt;T&gt;</code>（18章参照）</li>
    </ul>
    <p><code>any</code> 型は存在せず、動的型付けはサポートしない。</p>

    <h3>2.3 Value types / reference types（値型 / 参照型）</h3>
    <ul>
      <li>値型：
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code>（内部表現は int32）</li>
        </ul>
      </li>
      <li>参照型：
        <ul>
          <li><code>class</code></li>
          <li><code>string</code>（実装上は参照型）</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code>, <code>Result&lt;T&gt;</code> など</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying（struct の制約とコピー）</h4>
    <ul>
      <li>struct のフィールドにはプリミティブ型と他の struct のみを持てる。</li>
      <li>class などの参照型フィールドは持てない。</li>
      <li>struct の代入は常に値コピー。</li>
      <li>最大サイズなどは仕様で制限しない。</li>
    </ul>

    <h4>Class vs struct（class と struct）</h4>
    <ul>
      <li>class は struct をフィールドとして持てる。</li>
      <li>class インスタンスを別変数に代入すると参照がコピーされる（オブジェクト本体は共有）。</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions（数値と暗黙変換）</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li><code>int</code> と <code>float</code> を混在させた式の結果は <code>float</code> になる。
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> は高精度な 10 進数。</li>
      <li><code>int</code> / <code>float</code> と混在する式は、必要に応じて <code>decimal</code> に昇格しうる。</li>
      <li>オーバーフロー / アンダーフロー / 精度問題は <code>OverflowException</code> として扱う。</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe にはキャスト構文がない。</li>
      <li>enum と int の暗黙 / 明示変換はいずれも禁止。</li>
      <li>enum と数値型の混在式はコンパイルエラー（bitfield enum のビット演算を除く）。</li>
      <li>内部表現としては enum / bitfield enum はすべて int32。</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>：
        <ul>
          <li>範囲は 0–255。</li>
          <li>byte 同士の演算は許されるが、範囲外はエラーになり得る。</li>
          <li>byte と int の混在式は int に昇格。</li>
        </ul>
      </li>
      <li><code>char</code>：
        <ul>
          <li>char の算術演算は不可。</li>
          <li>比較演算（<code>==</code>, <code>&lt;</code>, <code>&gt;</code> 等）は char 同士のみ。</li>
          <li>数値型との暗黙変換はない。</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>数値オーバーフロー/アンダーフローは NaN/Infinity ではなく例外で扱う。</li>
      <li><code>ZeroDivisionException</code> は 0 / 0.0 で常に投げる。</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope（ブロックとスコープ）</h2>

    <p>
      ブロックは <code>{</code> と <code>}</code> で区切られ、各ブロックが新しいスコープを導入する。
    </p>
    <ul>
      <li><code>main</code> ブロック</li>
      <li>クラス定義ブロック</li>
      <li>メソッド定義ブロック</li>
      <li>任意の <code>{ ... }</code> ブロック</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing（静的スコープとシャドウイング）</h3>
<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // フィールドをシャドウ
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe は静的（レキシカル）スコープ。</li>
      <li>内側ブロックで同名変数を宣言すると、外側の変数をシャドウする。</li>
      <li>フィールド名とローカル変数名がぶつかった場合、ローカル変数が優先される。
        フィールドは <code>this.</code> で参照する。</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks（メンバー省略記法）</h3>
    <p>
      Aloe には、同一オブジェクトのメンバーアクセスを簡潔に書くための
      <code>with</code> ブロックがある。
    </p>
<pre><code>with (user) {
    .name = "Alice";
    .age = .age + 1;
    print(.name);
}
</code></pre>
    <ul>
      <li><code>with (expr) { ... }</code> ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>(expr).Member</code> の省略形。</li>
          <li><code>expr</code> はブロックの先頭で 1 度だけ評価され、内部一時変数に保持される。</li>
          <li>特別な一時変数 <code>_</code> は「with 対象オブジェクト」を指す。
            <ul>
              <li><code>log(_);</code> のように渡すことができる。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>ネストした <code>with</code> ブロック：
        <ul>
          <li>内側の <code>with</code> が <code>.</code> の解決および <code>_</code> をシャドウする。</li>
          <li>外側オブジェクトへは通常の変数名でアクセスできる。</li>
        </ul>
      </li>
      <li>C# の <code>using</code> スタイルのように、同じブロックに複数の <code>with</code> を並べられる：</li>
    </ul>
<pre><code>with (user), (profile) {
    .name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>どのオブジェクトのメンバーに解決されるかの順序は実装依存。</li>
      <li>ただし曖昧な場合（複数オブジェクトが同じメンバーを持つ）はコンパイルエラー。</li>
    </ul>
    <p>
      <code>with</code> はあくまで構文糖衣であり、意味的にはすべて
      明示的な <code>obj.member</code> 呼び出しに書き換えた上で
      型チェック・コード生成を行うことができる。
    </p>

    <h4 id="with-type">4.2.1 Type-based with（class / struct / enum の static / 列挙子ショートカット）</h4>
    <p>
      通常の <code>with (expr)</code> に加えて、<strong>型名</strong> を対象にした
      <code>with</code> を利用できる。
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>ここで <code>TypeName</code> は次のいずれか：</p>
    <ul>
      <li><code>class</code> 型</li>
      <li><code>struct</code> 型</li>
      <li><code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>この場合、<code>with</code> は「型コンテキスト with」として解釈される：</p>
    <ul>
      <li><code>()</code> 内の式は実行時に値として評価されない。
        <ul>
          <li>コンパイラは <code>TypeName</code> を型として解決し、インスタンス生成などは行わない。</li>
        </ul>
      </li>
      <li>ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>TypeName.Member</code> の省略形。
            <ul>
              <li>対象となる <code>Member</code> は
                <ul>
                  <li>static フィールド</li>
                  <li>static メソッド</li>
                  <li>enum / bitfield enum の列挙子</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>一時変数 <code>_</code> は、<code>TypeName</code> の static コンテキストを表す擬似オブジェクトとして振る舞う。
            <ul>
              <li><code>_.Member</code> も <code>TypeName.Member</code> と等価。</li>
            </ul>
          </li>
          <li>型ベース with 内でインスタンスメンバーにアクセスすることはコンパイルエラー。</li>
        </ul>
      </li>
    </ul>
    <p>
      なお、型ベース with でもローカル変数や外側スコープの変数が同名で存在すればそちらが優先される。
      列挙子や static メンバーを明示したいときは <code>TypeName.Member</code> または <code>.Member</code> / <code>_.Member</code> を用いる。
    </p>

    <h5>例：class / struct の static アクセス</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a &gt; b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
    return 0;
}
</code></pre>

    <h5>例：enum の列挙子アクセス</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      型ベース <code>with</code> も複数ターゲット構文に混在させられる：
    </p>
<pre><code>with (user), (Color) {
    .name = "Alice"; // user.name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      この場合も解決順は実装依存だが、曖昧であればコンパイルエラーとする。
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants（変数と定数）</h2>

    <h3>5.1 var（型推論）</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>変数の型は右辺の式から推論される。</li>
      <li><code>var x = 1;</code> は常に <code>int</code>。</li>
      <li><code>var x = 1.0;</code> は <code>float</code> として扱われる。</li>
      <li><code>var x = null;</code> はコンパイルエラー（型が推論できない）。</li>
    </ul>

    <h3>5.2 let（明示的な型）</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants（const）</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> 変数は再代入不可。</li>
      <li>const には型注釈が必須。</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields（フィールド宣言）</h2>
    <p>class / struct のフィールドは <code>field</code> キーワードで宣言する。</p>
<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: inside the constructor
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … 通常のフィールド。</li>
      <li><code>readonly field</code> … コンストラクタ内のみ代入可、それ以降は読み取り専用。</li>
      <li>struct / class の両方で同じ意味。</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class は参照型。</li>
      <li><code>sealed class</code> は <code>extends</code> による継承不可。</li>
      <li>単一継承のみサポート。</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>
    <ul>
      <li>struct は値型。</li>
      <li>フィールドはプリミティブ型か他の struct に限定（参照型フィールドは禁止）。</li>
      <li>struct のコピーは常に値コピー。</li>
      <li>struct の継承はサポートしない（<code>sealed struct</code> は「拡張禁止」マーカー）。</li>
    </ul>

    <h4>Struct layout annotations: @StructLayout / @FieldOffset</h4>
    <p>
      ネイティブコードとの相互運用などで、struct のメモリレイアウトを制御したい場合のために、
      struct には限定的なアノテーション <code>@StructLayout</code> / <code>@FieldOffset</code> を付与できる。
      これらは Aloe に組み込みで定義されているアノテーションであり、後述の汎用アノテーション機構の一例でもある。
    </p>
<pre><code>@StructLayout("Explicit")
struct NativePoint {
    @FieldOffset(0) field X: int;
    @FieldOffset(4) field Y: int;
}
</code></pre>
    <ul>
      <li><code>@StructLayout("...")</code>
        <ul>
          <li>struct 宣言の直前にのみ付けられるアノテーション。</li>
          <li>引数にはレイアウト種別を表す文字列を指定する。
            <ul>
              <li><code>"Auto"</code>（または省略時）: レイアウトは VM 実装依存。C 構造体との ABI 互換は保証しない。</li>
              <li><code>"Sequential"</code>: フィールド宣言順に並べることを VM に要求する（アラインメントなどの詳細は実装依存）。</li>
              <li><code>"Explicit"</code>: 各フィールドに <code>@FieldOffset</code> を指定して、バイトオフセットを明示する。</li>
            </ul>
          </li>
          <li>構文上は、アノテーション名の後に <code>(...)</code> 付きで 1 つ以上の引数を取る形とするが、
              現時点で仕様として定義するのは第 1 引数のレイアウト種別文字列のみとする。</li>
        </ul>
      </li>
      <li><code>@FieldOffset(n)</code>
        <ul>
          <li>struct 内の <code>field</code> 宣言の直前にのみ付けられるアノテーション。</li>
          <li>引数 <code>n</code> は 0 以上の整数リテラルで、struct 先頭からのバイトオフセットを表す。</li>
          <li><code>@StructLayout("Explicit")</code> が付いた struct 内でのみ有効であり、それ以外のレイアウト種別で使用した場合はコンパイルエラー。</li>
          <li>同じ struct 内で、フィールドのサイズや <code>@FieldOffset</code> の指定によってメモリ領域が重なった場合の扱いは実装依存だが、
              多くの実装ではコンパイルエラーまたは警告とすることが推奨される。</li>
        </ul>
      </li>
      <li>これらのアノテーションは、
        <strong>VM / ランタイムのネイティブインターフェイスに対するヒント</strong> であり、
        通常の Aloe コードにおける型システムの意味論（値コピー / 参照 / equality など）を変えるものではない。</li>
    </ul>

    <h4>7.2.1 汎用アノテーション機構（annotation 定義）</h4>
    <p>
      Aloe では、<code>@StructLayout</code> や <code>@FieldOffset</code> のような組み込みアノテーションに加えて、
      ユーザが独自のアノテーションを定義・利用できる。
      アノテーションは <code>annotation</code> 宣言で定義する。
    </p>
<pre><code>annotation MyAnnotation {
    text:   "アノテーションテキスト";         // 説明用文字列（任意）
    target: TargetKind;                      // struct, class, method, function などを表す列挙型
    params: map&lt;string/any&gt;;                // () 内に与えられるパラメータの論理表現

    build:  function (ctx: AnnotationBuildContext): void {
        // コンパイラから呼び出されるフック関数（擬似シグネチャ例）
        // ctx から付与先や params などの情報を取得して検証・変換などを行う。
    }
}
</code></pre>
    <ul>
      <li><code>annotation</code> 宣言は、アノテーションの「メタ定義」を行うための専用構文であり、
          通常の <code>class</code> / <code>struct</code> とは別枠の宣言とする。</li>
      <li><code>text</code> は人間向けの説明文であり、エディタやドキュメント生成ツールなどが利用してもよい。</li>
      <li><code>target</code> は、このアノテーションを付与できる対象種別（struct, class, method, function など）を表す列挙型（またはそれに準ずる型）とする。</li>
      <li><code>params</code> は、アノテーションに与えられた引数の論理表現を表す。
        <ul>
          <li>配列 / リスト / セット / マップなど、複合的な値を含みうる。</li>
        </ul>
      </li>
      <li><code>build</code> はコンパイラから呼び出されるフック関数であり、
          付与先の情報や <code>params</code> をもとに検証や補助的なコード生成などを行うことができる。
          具体的な引数型や戻り値はコンパイラ実装側の詳細に委ねられる。</li>
    </ul>
    <p>
      実際のアノテーション使用時には、次のような構文でパラメータを指定する。
    </p>
<pre><code>@MyAnnotation(key1 = value1, key2 = value2, ...)
struct Example {
    // ...
}
</code></pre>
    <p>
      このとき、アノテーション定義側から見た <code>params</code> には、次のようなマップとして渡されるものとする。
    </p>
<pre><code>params = { key1: value1, key2: value2, ... }
</code></pre>
    <p>
      配列 / リスト / セット / マップリテラルを引数に取る場合も同様に、
      それらの構造が <code>params</code> の値としてそのまま渡される。
      組み込みアノテーション <code>@StructLayout</code> や <code>@FieldOffset</code> も、
      この汎用アノテーション機構を用いて実装された「標準アノテーション」とみなしてよい。
      新たに必要なアノテーションが出てきた場合は、この機構を用いて仕様書に都度追記していく。
    </p>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li><code>implements</code> キーワードでインタフェースを実装。</li>
      <li><code>is</code> 演算子でインタフェース実装有無を判定。</li>
    </ul>

    <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

    <h4>with による trait の適用</h4>
<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // Trait_A から取り込まれたメソッド（競合がなければ）
</code></pre>

    <h4>非破壊的な追加 / 削除（+ / -）</h4>
<pre><code>var obj2 = obj + Trait_A;      // obj はそのまま; obj2 に Trait_A が付与される
var obj3 = obj2 - Trait_A;     // obj3 は obj2 から Trait_A を除いたもの
</code></pre>

    <h4>as によるエイリアス</h4>
<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: エイリアスのみ; メンバーはフラット化されない
</code></pre>

    <h4>Trait conflicts（競合）</h4>
    <ul>
      <li>複数 trait が同名フィールド / メソッドを定義する場合、右側に記述した trait が左側の定義を上書きする。</li>
      <li>クラス本体のメンバーと trait メンバーが同名の場合も同様に、
          最後に適用された（右側に書かれた） trait のメンバーで上書きされるとみなす。</li>
      <li>既に trait によって上書きされたメンバーに対して、さらに別の trait を <code>+</code> した場合も、
          その適用順に従って右側の trait が最終的な定義を提供する。</li>
      <li>上書きを避けたい場合は、<code>as a</code> のようなエイリアスを用いて、
          クラス本体のメンバー名と競合しない別名としてアクセスする。</li>
      <li><code>as a</code> などのエイリアス付き適用は衝突判定の対象外（エイリアス名の下に別の名前空間がぶら下がる）とする。</li>
    </ul>

    <h4>7.5.1 expects による前提インタフェース / 型制約</h4>
    <p>
      trait は <code>expects</code> 句を使って、適用先オブジェクトが満たすべき前提インタフェースを宣言できる。
    </p>
<pre><code>interface Interface_A {
    method Foo(): void;
}

trait Trait_B expects Interface_A {
    method CallFoo(): void {
        // Interface_A で定義されたメンバーを this 経由で安全に呼び出せる
        this.Foo();
    }
}
</code></pre>
    <ul>
      <li><code>trait T expects I1, I2, ... { ... }</code> のように、1 個以上のインタフェース名を列挙できる。</li>
      <li><code>expects</code> に列挙された各インタフェース <code>Ik</code> について、
          trait を適用する先の静的型 <code>TTarget</code> は <strong><code>Ik</code> を実装していなければならない</strong>。
        <ul>
          <li><code>TTarget</code> が <code>implements Ik</code> を持つ、または基底クラスが <code>Ik</code> を実装している場合は OK。</li>
        </ul>
      </li>
      <li>この条件を満たさない型に対して
<pre><code>var x = new SomeType() with Trait_B;
</code></pre>
          のように適用しようとした場合はコンパイルエラーとなる。</li>
      <li>同様に、<code>+</code> や <code>as</code> を使った適用でも同じ制約がかかる：
<pre><code>var x = new A() + Trait_B;         // A が Interface_A を実装していれば OK
var y = new B() + Trait_B as b;    // B が Interface_A を実装していない場合はコンパイルエラー
</code></pre>
      </li>
      <li>trait 本体から見た <code>this</code> は、
          <code>expects</code> で宣言されたすべてのインタフェースを実装するオブジェクトとして扱われる。
        <ul>
          <li>そのため、trait 内ではこれらのインタフェースで定義されたプロパティ / メソッドを
              明示的なキャストなしに利用できる。</li>
        </ul>
      </li>
      <li>インタフェースを増やしたい場合は <code>expects I1, I2</code> のようにカンマで複数列挙する。
        <ul>
          <li>将来的な拡張として、インタフェース以外の型（例えば trait 自体や特定の基底クラス）も
              期待対象に含めることは検討余地として残すが、現時点の仕様では
              <strong>expects の右辺には interface 型だけを書く</strong> ことを前提とする。</li>
        </ul>
      </li>
    </ul>
    <p>直感的には、次のように読むことができる：</p>
    <ul>
      <li><code>class A implements Interface_A {}</code><br>
        ⇒ クラス A は <code>Interface_A</code> を「実装」する。</li>
      <li><code>trait B expects Interface_A {}</code><br>
        ⇒ Trait B は「<code>Interface_A</code> を実装したオブジェクトにアタッチされることを期待する」。<br>
        ⇒ したがって、Trait B の内部では <code>Interface_A</code> で定義されたプロパティ / メソッドを利用できる。
      </li>
    </ul>

    <h3>7.6 abstract / virtual / override</h3>
    <p>
      継承階層における多態性を表現するために、<code>abstract</code> / <code>virtual</code> /
      <code>override</code> の 3 つのキーワードを用いる。
    </p>

    <h4>abstract class / abstract method</h4>
<pre><code>abstract class Animal {
    method SayName(): void {
        print("Unknown");
    }

    abstract method Speak(): void; // 本体を持たない抽象メソッド
}
</code></pre>
    <ul>
      <li><code>abstract</code> が class の前に付いた場合、そのクラスは抽象クラスとなる。</li>
      <li>抽象クラスは直接インスタンス化できない（<code>new Animal()</code> はコンパイルエラー）。</li>
      <li><code>abstract method</code> は本体（メソッドブロック）を持たず、宣言のみを行う。</li>
      <li>抽象メソッドを持つクラスは必ず <code>abstract class</code> でなければならない。</li>
    </ul>

<pre><code>class Dog extends Animal {
    override method Speak(): void {
        print("Bowwow");
    }
}
</code></pre>
    <ul>
      <li>抽象メソッドは、具象クラス（非 abstract クラス）側で <code>override</code> によって必ず実装しなければならない。</li>
    </ul>

    <h4>virtual method と override</h4>
<pre><code>class BaseLogger {
    virtual method Log(message: string): void {
        print("[Base] " + message);
    }
}

class FileLogger extends BaseLogger {
    override method Log(message: string): void {
        print("[File] " + message);
    }
}
</code></pre>
    <ul>
      <li><code>virtual</code> が付いたメソッドは、派生クラスで <code>override</code> 可能なメソッドである。</li>
      <li><code>virtual</code> メソッドは本体を持つ（抽象メソッドとは異なる）。</li>
      <li>派生クラス側でオーバーライドする場合、必ず <code>override</code> を付ける。</li>
      <li><code>override</code> を付けたメソッドのシグネチャ（名前、引数、戻り値）は、基底クラスの抽象 / virtual メソッドと一致していなければならない。</li>
      <li>基底クラスに対応する virtual / abstract メソッドが存在しないのに <code>override</code> を付けた場合はコンパイルエラー。</li>
    </ul>

    <h4>呼び出しの挙動と <code>base</code> キーワード</h4>
<pre><code>BaseLogger logger = new FileLogger();
logger.Log("Hello");  // 実行時型に応じて FileLogger.Log が呼ばれる（仮想呼び出し）

FileLogger fl = new FileLogger();
fl.Log("Hello");      // 当然 FileLogger.Log が呼ばれる
</code></pre>
    <ul>
      <li>virtual / override メソッドは、変数の静的型ではなく実行時型に基づいて解決される（仮想メソッド呼び出し）。</li>
      <li>基底クラス側の実装を呼び出したい場合は <code>base.Log(...)</code> のような構文を用いる。
        <ul>
          <li><code>base</code> は、インスタンスメソッドの本体内からのみ使用可能であり、
              そのメソッドを宣言しているクラスの直接の基底クラスを指す。</li>
          <li><code>base</code> は静的メソッドやトップレベル関数からは使用できない。</li>
        </ul>
      </li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> は VM レベルでは <code>obj = null</code> と等価。</li>
      <li>ソースコード中で <code>obj = null;</code> と書くことはできない。</li>
      <li>参照型は内部的には null を取り得るが、型システムは null を追跡しない。</li>
      <li>null 状態でのアクセスは <code>NullReferenceException</code> を引き起こす可能性がある。</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator（is 演算子）</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is Trait_A) {
    // true if obj has Trait_A applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> は実行時の型チェックを行う。</li>
      <li>継承関係（Derived は Base としても扱う）を考慮する。</li>
      <li>インタフェースや trait に対しても使用できる。</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections（配列 / リスト / セット / マップ）</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // map&lt;int&gt; は map&lt;string/int&gt; のエイリアス
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>内部表現は常に int32。</li>
      <li><code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code> のような基礎型の変更は許可されない。</li>
      <li>enum 型も型ベース with の対象となり、<code>with (Color) { Red; }</code> などで列挙子に短縮アクセスできる。</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) 記法</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> はビット n（<code>1 &lt;&lt; n</code>）を表す。</li>
      <li><code>Name : b(n)</code> でその列挙子にビット n を割り当てる。</li>
      <li><code>bitfield enum</code>で使用可能なビットは最大 32（n は 0–31）。</li>
      <li>同一ビットを共有する列挙子があっても、コンパイラは警告にとどめ、エラーにはしない。</li>
      <li>基礎型は常に int32 であり、<code>bitfield enum&lt;byte&gt;</code> などはコンパイルエラー。</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block（エントリポイント）</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.run();
    return 0; // プロセスの終了コード
}
</code></pre>
    <ul>
      <li>プログラムのエントリポイント。</li>
      <li><code>args</code> はコマンドライン引数。</li>
      <li><code>main</code> ブロックは必ず <code>function main(args: string[]): int</code> の形で宣言し、
          戻り値は <code>int</code> 型の <code>return</code> 文で指定する。</li>
      <li>main ブロック内の特別な一時変数 <code>_</code> の仕様は存在しない（通常の一時変数のみ）。</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code>（一時変数）</h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    var _ = x + 5;   // ここでは通常のローカル変数として扱われる
    return 0;
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // このブロックにおける最初の代入の型が _ の型になる
}
</code></pre>
    <ul>
      <li><code>_</code> は任意のブロックで宣言なしに使用できる特別な一時変数として扱われる。</li>
      <li>ただし main では特別な意味は持たず、通常の変数と同様に扱われる。</li>
      <li>main 以外のブロックでは、そのブロックで最初に代入された式の型が <code>_</code> の型になる。</li>
      <li>with ブロック内では、追加で「現在の with 対象」を指す意味を持つ（4.2 参照）。</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword（swap キーワード）</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> は x と y の値（または参照）を入れ替える。</li>
      <li>swap が妥当かどうかはコンパイル時にチェックされる。</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators（演算子）</h2>

    <h3>15.1 優先順位（高い順）</h3>
    <ol>
      <li>メンバー / 呼び出し：<code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>単項：<code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>乗除：<code>*</code>, <code>/</code>, <code>%</code></li>
      <li>加減：<code>+</code>, <code>-</code></li>
      <li>シフト：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>関係：<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>等価：<code>==</code>, <code>!=</code></li>
      <li>ビット AND：<code>&amp;</code></li>
      <li>ビット XOR：<code>^</code></li>
      <li>ビット OR：<code>|</code>（pipeline 文では別語義）</li>
      <li>論理 AND：<code>&amp;&amp;</code>（エイリアス：<code>and</code>）</li>
      <li>論理 OR：<code>||</code>（エイリアス：<code>or</code>）</li>
      <li>代入：<code>=</code></li>
    </ol>
    <p>複合代入（<code>+=</code> 等）はまだ仕様化されていない。</p>

    <h3>15.2 結合規則</h3>
    <ul>
      <li>単項演算子：右結合。</li>
      <li>代入：右結合。</li>
      <li>その他の 2 項演算子：左結合。</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions（例外）</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 標準例外の概要</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> はオーバーフロー / アンダーフロー両方に用いる。</li>
      <li><code>ZeroDivisionException</code> は 0 / 0.0 による除算で投げる。</li>
      <li>パースやフォーマットエラーは <code>FormatException</code>。</li>
      <li><code>InvalidOperationException</code> は、不正な状態での操作（例：<code>Result</code> の状態と合わないプロパティアクセスなど）に用いる。</li>
      <li>その他の VM レベルの致命的エラーは実装依存。</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>

    <h3>17.1 Module（モジュール / コンパイル単位）</h3>
    <p>
      Aloe における <strong>モジュール</strong> は、コンパイル対象となる 1 つのソースファイルを指す。
      言語仕様のスコープ外として、モジュール名やファイルパス・ディレクトリ構成・パッケージ管理は
      ビルドツールやパッケージマネージャ側の責務とする。
    </p>
    <p>
      この章では、1 ファイル内部での <code>import</code> / <code>namespace</code> の書式と
      それによる名前解決のルールのみを定義する。
    </p>

    <h3>17.2 ファイル構造の制約</h3>
    <p>
      1 つのモジュール（ソースファイル）の構造は、次の形に限定される。
    </p>
<pre><code>import Foo.Bar;
import Aloe.Core.Logging;
import Aloe.Json.*;
import MyCompany.Project.Module;

namespace My.App {
    // class / struct / enum / bitfield enum / trait / function などの宣言だけ
}
</code></pre>
    <ul>
      <li><code>import</code> はファイルの先頭にのみ書ける。</li>
      <li><code>import</code> より前に、他のコード（宣言や文）を書いてはならない。</li>
      <li><code>import</code> は複数行並べてよい。</li>
      <li><code>namespace</code> は、すべての <code>import</code> の後に 1 回だけ現れなければならない。</li>
      <li><code>namespace</code> の外側には、<code>import</code> と <code>namespace</code> 以外の要素を書いてはならない。</li>
      <li>トップレベルに実行文（<code>print(...);</code> など）を書くことは禁止であり、
          実行コードは必ず <code>main</code> や他の関数 / メソッド内部に置く。</li>
    </ul>

    <h3>17.3 namespace のルール</h3>
    <ul>
      <li>1 モジュールにつき、<strong><code>namespace</code> 文はちょうど 1 回だけ</strong> 許可される。</li>
      <li>構文は
<pre><code>namespace My.App {
    // 宣言
}
</code></pre>
        のようにフルパス 1 段のみとし、<code>namespace A { namespace B { ... } }</code> のような
        <strong>namespace のネスト構文は禁止</strong>とする。
      </li>
      <li>namespace ブロックの中に、さらに <code>namespace</code> 文を書くことはできない。</li>
      <li>namespace ブロック内に書けるのは、
        <ul>
          <li><code>class</code>, <code>struct</code>, <code>enum</code>, <code>bitfield enum</code>, <code>trait</code>, <code>function</code> などの宣言のみ。</li>
        </ul>
        トップレベルの実行文は書けない。
      </li>
      <li>namespace ブロックの内側から <code>import</code> を書くことはできない。</li>
      <li>同じ namespace 名を持つ宣言が複数のモジュールにまたがって存在する場合、
          それらは 1 つの論理的な namespace にマージされる。
          ただし、それらが属するモジュールのビルド単位やパッケージとしての扱いは別途ビルド仕様に委ねられる。</li>
    </ul>

    <h3>17.4 import のルール</h3>
    <h4>17.4.1 文法と制限</h4>
    <ul>
      <li><code>import</code> はファイル先頭にのみ書ける。</li>
      <li>namespace、クラス、メソッド、その他のブロックの内部に <code>import</code> を書くことはできない。</li>
      <li>サポートされる構文は次の通り。
<pre><code>import Aloe.Core.Logging;   // 単一 namespace / 型のインポート
import Aloe.Json.*;         // ワイルドカード import（Aloe.Json 直下の公開シンボル）
</code></pre>
      </li>
      <li><strong>相対 import はサポートしない。</strong>
        <ul>
          <li><code>import ./util.Json;</code> や <code>import ../common.*;</code> のような表記はコンパイルエラーとする。</li>
        </ul>
      </li>
      <li>import はすべて「絶対指定」（ルート namespace からのフルパス）でなければならない。</li>
    </ul>

    <h4>17.4.2 ワイルドカード import の挙動</h4>
    <ul>
      <li><code>import Foo.*;</code> は、<code>Foo</code> namespace 直下の公開シンボル（型・関数など）をまとめて導入する。</li>
      <li>サブ namespace（<code>Foo.Bar</code> など）をどこまで自動的に含めるかは、
          将来的にモジュール仕様で詳細化する余地を残すが、少なくとも <code>Foo</code> 直下の型・関数は導入されるものとする。</li>
      <li>ワイルドカード import によって同名シンボルが複数の namespace から導入され、
          解決が曖昧になる場合はコンパイルエラーとし、プログラマに完全修飾名の使用を要求する。</li>
    </ul>

    <h3>17.5 名前解決の優先順位（概要）</h3>
    <p>
      ある識別子 <code>X</code> を解決するときの大まかな優先順位は次の通りとする。
    </p>
    <ol>
      <li>ローカルスコープ（メソッドのローカル変数・パラメータ、そのブロック内の宣言）</li>
      <li>現在のクラス / struct / trait / function 自身のメンバー</li>
      <li>現在の namespace 内の宣言（同じ namespace を共有する他モジュールを含む）</li>
      <li><code>import</code> された namespace 達の公開メンバー
        <ul>
          <li><code>import Foo.Bar;</code> によって、<code>Foo.Bar</code> 直下の公開シンボルが導入される。</li>
        </ul>
      </li>
    </ol>
    <p>
      この優先順位で複数の候補が見つかり、どれを指しているかが曖昧になる場合はコンパイルエラーとする。
      その場合は、完全修飾名（例：<code>Foo.Bar.TypeName</code>）で明示的に指定する必要がある。
    </p>

    <h3>17.6 可視性と公開範囲</h3>
    <ul>
      <li><code>public</code> な型・メンバーは、他の namespace / モジュールから <code>import</code> を通じて参照できる。</li>
      <li><code>private</code> な型・メンバーは、同一モジュール内でのみ参照できる。
          （より細かい「同一 namespace 内だけ」などの制御が必要になった場合は、
           別途 <code>internal</code> のような修飾子を導入する余地を残す。）</li>
      <li><code>protected</code> なメンバーは、継承関係にあるクラス / struct から参照できる。
          そのモジュール境界をまたいだ挙動は VM / ランタイムよりも「言語仕様」に属するが、
          詳細なアクセス制御は今後のバージョンで拡張されうる。</li>
    </ul>

    <h3>17.7 循環 import の扱い</h3>
    <ul>
      <li>モジュール同士の <code>import</code> が循環していても、それ自体は構文的にも意味的にも禁止しない。</li>
      <li>コンパイラは、すべてのモジュールから宣言情報（型・関数のシグネチャなど）を先に収集し、
          その後で型チェックや struct のレイアウト決定を行うモデルを想定する。</li>
      <li>したがって、通常の class / interface / trait どうしの相互参照は問題にならない。</li>
      <li>一方で、struct のフィールドが互いを値型として再帰的に含み合うなど、
          「定義そのものが矛盾している」場合は、import グラフとは無関係に
          通常の型エラー（例：<q>この struct のサイズを決定できない</q>）としてコンパイルエラーになる。</li>
      <li>言い換えると、<strong>循環 import の有無を特別扱いするのではなく、
          あくまで通常の型システムのルールに基づいて正当性を判定する。</strong></li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters（パイプとフィルタ）</h2>

    <p>
      Aloe は <code>pipe&lt;T&gt;</code> と <code>filter(...)</code> を用いて、
      サーバ / CLI / Web アプリなどのストリーミング処理を構成する。
    </p>

    <h3>18.1 pipe&lt;T&gt; の基本</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> は T 型要素のストリーム。</li>
      <li><code>pipe&lt;byte&gt;</code> … 標準入力やソケットなどのバイト列。</li>
      <li><code>pipe&lt;string&gt;</code> … 文字列ストリーム。</li>
      <li>pipe は共有メモリではなく値コピーを前提とする。</li>
    </ul>

    <h4>18.1.1 組み込みパイプ</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code>（任意）</li>
    </ul>

    <h3>18.2 Result&lt;T&gt; と ROP（Railway Oriented Programming）の概要</h3>
    <p>
      Aloe では、パイプラインやフィルタにおけるエラー処理や分岐を
      <strong>Result&lt;T&gt;</strong> 型と <strong>Railway Oriented Programming（ROP）</strong> の考え方で扱う。
    </p>
    <ul>
      <li><code>Result&lt;T&gt;</code> は「成功（Success = true）」または「失敗（Success = false）」のどちらかを表す、言語組み込みランタイムが提供する標準ライブラリ型。</li>
      <li>フィルタやパイプは通常 <code>Result&lt;T&gt;</code> を返すことで、成功 / 失敗を明示的に表現する。</li>
    </ul>

    <h4>18.2.1 Result&lt;T&gt; の型仕様</h4>
<pre><code>class Result&lt;T&gt; {
    // 状態
    // Success == true のとき: Value が有効
    // Success == false のとき: ErrorMessage が有効
    field Success: bool;
    field Value: T;
    field ErrorMessage: string;

    // ファクトリメソッド（標準ライブラリの static メソッド）
    static method Ok(value: T): Result&lt;T&gt;;
    static method Error(message: string): Result&lt;T&gt;;
}
</code></pre>
    <ul>
      <li><code>Success</code> が <code>true</code> の場合：
        <ul>
          <li><code>Value</code> に有効な値が格納されている。</li>
          <li><code>ErrorMessage</code> は空文字列や実装依存の値だが、読み出してもよい。</li>
        </ul>
      </li>
      <li><code>Success</code> が <code>false</code> の場合：
        <ul>
          <li><code>ErrorMessage</code> にエラーメッセージ（またはその一部）が格納されている。</li>
          <li><code>Value</code> は「存在しない値」とみなされ、読み出しは不正な操作である。</li>
        </ul>
      </li>
      <li>状態（<code>Success</code>）と一致しないプロパティへのアクセス（例：<code>Success == false</code> なのに <code>Value</code> を読む、など）は
          実行時に <code>InvalidOperationException</code> を投げるものとする
          （コンパイラが静的に検出できる場合はコンパイルエラーとしてもよい）。</li>
      <li><code>Result&lt;void&gt;</code> については、値を持たない成功を表現するために
          <code>Result&lt;void&gt;.Ok()</code>（引数なし）を特別に許可する：
        <ul>
          <li>この場合も <code>Success == true</code> となり、<code>ErrorMessage</code> は通常空を意味する。</li>
          <li><code>Result&lt;void&gt;</code> に対して <code>Value</code> を読み出そうとした場合は常に不正であり、
              <code>InvalidOperationException</code> を投げる。</li>
        </ul>
      </li>
    </ul>
    <p>
      <code>Ok</code> / <code>Error</code> は言語構文としての特別扱いではなく、
      あくまで <code>Result&lt;T&gt;</code> クラスが提供する通常の static メソッドである。
      ただし、パイプラインやフィルタと組み合わせたときに扱いやすくするため、
      標準ライブラリの一部として特別に定義されている。
    </p>

    <h4>18.2.2 ROP（Railway Oriented Programming）のイメージ</h4>
    <p>
      ROP は「成功の線路」と「失敗の線路」が並走し、
      各ステップ（フィルタ）が <code>Result&lt;T&gt;</code> を返すことで、
      エラーが出た時点で以降のステップをスキップするイメージである。
    </p>
<pre><code>入力
  ├─&gt; [ Filter A ] ──&gt; [ Filter B ] ──&gt; [ Filter C ] ──&gt; 出力
  │         │               │               │
  │         └─&gt; Error ──────┴───────────────┴───&gt; エラー経路
  │
  └─&gt; （別の分岐やログ出力など）
</code></pre>
    <p>
      Aloe におけるフィルタは、可能な限り副作用を限定し、
      同じ入力に対して同じ出力を返す「準冪等性」を目指す設計とする。
    </p>

    <h3>18.3 filter(...) の基本と定義</h3>
    <p><code>filter(F)</code> はパイプライン中の中間変換ステージ。</p>

    <h4>18.3.1 フィルタ定義（filter 定義文）</h4>
<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    // オプション用の型（任意）
    options: LineSplitOptions;

    // フィールド定義（任意だが、副作用の観点からは最小限を推奨）
    field _buffer: string = "";

    // コンストラクタ（任意）
    constructor(opts: LineSplitOptions) {
        // options で受け取った値に応じて初期化などを行う
    }

    // 入力パイプから出力パイプへ処理を流す本体
    bound(input, output): Result&lt;void&gt; {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
        return Result&lt;void&gt;.Ok(); // 処理が成功したことを示す
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> で入力・出力パイプの型を指定する。</li>
      <li><code>options</code> で、このフィルタに紐づくオプションクラス（通常は <code>bitfield enum</code> 等）を指定できる。</li>
      <li><code>field</code> でフィルタ内部の状態を保持することも可能だが、
          ROP 的な観点からは「同じ入力に対して同じ出力」を返すことが望ましいため、
          副作用を持つフィールドは最小限にとどめることが推奨される。</li>
      <li><code>constructor</code> は任意で定義でき、オプション値や外部パラメータを受け取って初期化を行う。</li>
      <li><code>bound(input, output)</code> は
          フィルタの実行本体であり、戻り値の型は <strong><code>Result&lt;T&gt;</code> もしくはその派生クラス</strong> でなければならない。
        <ul>
          <li>これは、<code>async</code> 関数が <code>task</code> を返すことを要求されるのと同様に、
              フィルタの <code>bound</code> が ROP ベースの成功 / 失敗を表現できることを保証するための制約である。</li>
          <li>それ以外のオブジェクト型やプリミティブ型を返そうとしたり、戻り値が <code>void</code> の場合はコンパイルエラーとする。</li>
        </ul>
      </li>
    </ul>

    <h4>18.3.2 フィルタオプション（filter オプション指定）</h4>
<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>
    <ul>
      <li>オプションは <code>:</code> の後に <code>|</code> でつなげて指定。</li>
      <li>各フィルタは自前のオプション型（bitfield enum 等）を持つ。</li>
      <li><code>filter</code> 定義内で <code>options: JsonOptions;</code> のように
          オプションクラスを指定した場合、そのフィルタをパイプライン上で使用するときには
          <code>JsonOptions.</code> の接頭辞を省略して列挙子名だけを書いてもよい：</li>
    </ul>
<pre><code>filter(json&lt;User&gt;: PrettyPrint | IncludeNulls)
</code></pre>
    <p>
      上記は <code>JsonOptions.PrettyPrint | JsonOptions.IncludeNulls</code> と等価であり、
      options に指定されたクラスに属する列挙子であることがコンパイラによって検証される。
    </p>

    <h3>18.4 パイプライン文と <code>|</code> / パイプ with 演算子 <span class="operator">|&gt;</span></h3>
<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>
    <ul>
      <li><code>A | B | C;</code> で A の出力が B へ、B の出力が C へ接続される。</li>
      <li>型チェックにより各ステージの入出力型整合性を確認。</li>
      <li>パイプライン文そのものは値を返さない（副作用として接続を張るだけ）。</li>
    </ul>

    <h4>18.4.1 パイプ with 演算子 <span class="operator">|&gt;</span>（フィルタ条件ショートカット）</h4>
    <p>
      演算子 <span class="operator">|&gt;</span> は、<code>filter(if)</code> を用いた条件付きフィルタリングの
      ショートカットとして定義される。
    </p>
<pre><code>// フル構文
users
    | filter(if : .Age &gt;= 20 and .Gender == Gender.Male);

// ショートカット構文（同義）
users |&gt; .Age &gt;= 20 and .Gender == Gender.Male;
</code></pre>
    <ul>
      <li><span class="operator">|&gt;</span> の右側には、現在の要素を表す暗黙のコンテキスト
          （with における <code>.</code> と同様）を使った条件式を記述する。</li>
      <li>上記の例では、「20 歳以上かつ男性のユーザーだけを通す」フィルタを表す。</li>
      <li><span class="operator">|&gt;</span> は内部的には <code>filter(if : ...)</code> に展開されるため、
          実装上は <code>if</code> 用フィルタを 1 つ実装しておけばよい。</li>
    </ul>

    <h3>18.5 foreach と pipe</h3>
<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> は内部的に <code>p.next()</code> を EOF まで呼ぶ。</li>
      <li>書き込み側が <code>close()</code> を呼ぶと読み側は EOF を検知してループを終了する。</li>
    </ul>

    <h3>18.6 map による要素変換（pipe 用）</h3>
    <p>
      pipe に対して <code>map</code> を適用することで、各要素に関数を適用し、
      別の型のストリームを得ることができる。
    </p>
<pre><code>// 関数を用いた map
function toName(u: User): string {
    return u.Name;
}

names = users | map(toName);
</code></pre>
    <ul>
      <li><code>map</code> は組み込みの高階操作として定義される。</li>
      <li><code>map</code> の結果も <code>pipe&lt;T&gt;</code> であり、さらに他のフィルタに接続できる。</li>
      <li>ラムダ風の簡易構文（<code>map (u) =&gt; u.Name</code> のような表記）は現時点では採用せず、
          関数またはメソッド名を渡すシンプルな形のみを仕様に含める。</li>
    </ul>

    <h3>18.7 コレクションに対するテンプレート map</h3>
    <p>
      コレクション（例：<code>User()</code> や <code>User{}</code>）に対して、
      テンプレート構文を用いる <code>map</code> も利用できる。
    </p>
<pre><code>// User() コレクションから Customer() コレクションを生成する例
customers = users | map Customer {
    Name    = "FixedName";           // 固定値
    Created = now();                 // 固定関数呼び出し
    BaseUrl = base.ApiEndpoint;      // base による外部設定参照（例）
};
</code></pre>
    <ul>
      <li><code>users | map Customer { ... }</code> のように記述すると、
          各要素ごとに <code>Customer</code> 型のインスタンスを新たに生成し、
          ブロック内のフィールド代入を用いてマッピングするテンプレートとみなされる。</li>
      <li>テンプレート内では、<strong>「固定値」または「固定関数呼び出し」</strong> のみで
          <code>Customer</code> の各フィールドを構成することができる。
        <ul>
          <li>ここでいう「固定関数」とは、テンプレートが評価されるたびに同じ意味で呼び出される
              外側スコープの関数 / メソッドであり、コレクションの要素そのものを引数に取らないものを指す。</li>
        </ul>
      </li>
      <li>テンプレート内からコレクションの個々の要素には直接アクセスできない。
          すなわち、<code>users</code> の各 <code>User</code> を参照するような <code>u.Name</code> などの記法は許可されない。</li>
      <li>外部の設定値やコンテキストを参照したい場合には、
          <code>base</code> による外側の設定オブジェクトを用いるなど、
          明示的に別経路で情報を渡すことを想定する（<code>base</code> の具体的な意味付けは、
          テンプレート map を利用するコンテキスト側の仕様に委ねられる）。</li>
      <li>結果は <code>Customer()</code> など、元のコレクションと同様のコレクション型になる。</li>
    </ul>

    <h3>18.8 close と EOF 伝播</h3>
    <ul>
      <li><code>p.close()</code> 後の <code>write()</code> は無効（エラーになり得る）。</li>
      <li>フィルタは入力 EOF を検知したら出力側も <code>close()</code> すべき。</li>
    </ul>

    <h3>18.9 pipe を使った並行モデル</h3>
    <ul>
      <li>タスク同士の主な通信手段は <code>pipe&lt;T&gt;</code>。</li>
      <li>shared-nothing モデルを前提とし、共有可変データ構造は持たない設計を推奨。</li>
    </ul>

    <h3>18.10 match によるパイプ分岐（Result&lt;T&gt; の分岐）</h3>
    <p>
      <code>Result&lt;T&gt;</code> を返すパイプやフィルタに対して、
      <code>match</code> を用いて分岐させることができる。
    </p>
<pre><code>stdin
    | filter(parseUser)
    | match {
        case Ok(u):
            // 正常系パイプ
            | filter(saveUser)
            | filter(logSuccess);
        case Error(e):
            // エラー系パイプ
            | filter(logError);
        default:
            // どちらにもマッチしない場合（将来拡張用）
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... }</code> は直前のステージの出力 <code>Result&lt;T&gt;</code> に対して分岐を行う。</li>
      <li><code>case パターン:</code> の直後には、さらに <code>| filter(...)</code> などのパイプラインを続けて記述できる。</li>
      <li><code>default:</code> は任意で、どの <code>case</code> にもマッチしない場合のフォールバックを表す。</li>
    </ul>
<pre><code>| match {
    case 条件式1:
        | filter(handleCase1);
    case 条件式2:
        | filter(handleCase2);
    default:
        | filter(handleDefault);
}
</code></pre>
    <p>
      条件式部分には <code>is</code> や Result パターン（<code>Ok(...)</code>, <code>Error(...)</code>）を用いることができる。
    </p>

    <h3>18.11 例：簡単な REST 風パイプライン</h3>
<pre><code>class User {
    field id: int;
    field name: string;
}

function main(args: string[]): int {
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    stdin
        | filter(utf8)
        | filter(json&lt;User&gt;)
        | users;

    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    return 0;
}
</code></pre>

    <h2 id="editor-notes">Appendix: 生成AI 向け編集ポリシー（仕様書本文ではない）</h2>
    <p class="note">
      <strong>生成AI向け共通編集ポリシー（Aloe 言語仕様書 / AloeVM 仕様書）：</strong><br>
      ・この文書と AloeVM 仕様書は、常に同じ編集ポリシーで運用する。<br>
      ・日本語版・英語版の内容（章構成・見出し・本文の意味）は常に一致させる（片方だけを勝手に簡略化 / 拡張しない）。<br>
      ・<code>edit-version</code> は日本語版・英語版で共通とし、仕様本文（サンプルを含む）を変更したときだけ +1 する。減らしたり巻き戻したりしない。<br>
      ・<code>edit-date</code> には、編集を反映した「その瞬間の Asia/Tokyo の現在時刻」を ISO 8601 形式（YYYY-MM-DDThh:mm:ss+09:00）で必ず書く。推測や他タイムゾーンの時刻を書いてはいけない。<br>
      ・関係ない箇所については原則変更禁止。意味が同じでも、変数名やメソッド名、文言を「良かれと思って」書き換えない。<br>
      ・新しい仕様追加や既存仕様の意味が変わる修正をしたくなった場合は、必ず一度ユーザーに相談し、合意を取ってから反映する。<br>
      ・直前にユーザーが「正」として提示した全文 HTML を常に正本とみなし、その版に対する最小限の差分だけを適用する。<br>
      ・もし直前の HTML が手元で再現できなくなった場合や、どこまでが最新かわからなくなった場合は、編集を続けず、必ずユーザーに確認する。<br>
    </p>

  </main>
</div>
</body>
</html>
