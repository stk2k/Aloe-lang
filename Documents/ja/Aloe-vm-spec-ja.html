```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>AloeVM 仕様書（ドラフト）</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }
    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM 仕様書</h1>
    <small>（現時点のドラフト。今後変更・拡張される可能性があります。）</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. 概要</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. 実行モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. VM 値モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. コールスタックとフレーム</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. ヒープとメモリ管理方針</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. パイプ / フィルタの表現</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC バイナリ形式</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. 命令セットと WASM 対応</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. 未決事項・TODO</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. 概要 -->
    <section id="vm-ch0" class="chapter">
      <h2>0. 概要</h2>
      <p>
        AloeVM は、Aloe 言語の実行用に設計された <strong>スタックベースの仮想マシン</strong> です。<br>
        ここでは以下を定義します：
      </p>
      <ul>
        <li>実行モデル（スタックマシン／フレーム構造）</li>
        <li>VM レベルの値モデル（プリミティブ・構造体・クラス・enum・pipe/filter 等）</li>
        <li>ヒープとメモリ管理の方針</li>
        <li>パイプ / フィルタの VM 上での表現</li>
        <li>AloeBC（Aloe バイトコード）バイナリ形式</li>
        <li>WebAssembly（WASM）との対応ポリシー</li>
      </ul>
      <div class="note">
        AloeVM には 2 つの想定ランタイムがあります：
        <ul>
          <li>C# 実装（.NET 上で動作する VM）</li>
          <li>WASM ネイティブ実装（aloe2wasm によって直接 WASM にコンパイルされたコード）</li>
        </ul>
        本仕様は主に「C# 実装 VM + AloeBC」の振る舞いを定義し、<br>
        WASM 側は「命令セットをほぼ 1:1 でマッピングする」「GC は WASM 実行系に任せる」という方針を示します。
      </div>
    </section>

    <!-- 1. 実行モデル -->
    <section id="vm-ch1" class="chapter">
      <h2>1. 実行モデル</h2>

      <h3>1.1 スタックマシンとしてのモデル</h3>
      <ul>
        <li>VM は <strong>オペランドスタック</strong> を中心としたスタックマシンである。</li>
        <li>算術命令・比較命令などはスタックトップから値を取り出し、結果を再びスタックに積む。</li>
        <li>ローカル変数・引数は <strong>フレーム内ローカル領域</strong> に保持される。</li>
      </ul>

      <h3>1.2 実行単位</h3>
      <ul>
        <li>実行単位は「関数（メソッド）」であり、Aloe のメソッド／main ブロックに対応する。</li>
        <li>各関数は AloeBC 内で <strong>関数テーブル</strong> に登録されており、エントリには
          <ul>
            <li>コードオフセット</li>
            <li>ローカル変数数</li>
            <li>引数数</li>
            <li>例外ハンドラテーブルへの参照</li>
          </ul>
          などを保持する。
        </li>
      </ul>

      <h3>1.3 例外処理モデル</h3>
      <ul>
        <li>Aloe の <code>try / catch / finally</code> は VM レベルでも例外ハンドラテーブルに展開される。</li>
        <li>例外は VM 内で <strong>オブジェクト参照</strong> として扱い、スロー時にスタックを巻き戻す。</li>
        <li>WASM 実装では、ホストの例外モデルまたは多値戻り＋エラーコードパターンへマッピングする。</li>
      </ul>

      <h3>1.4 実行モード</h3>
      <ul>
        <li><strong>VM 実行モード</strong>:
          <ul>
            <li>C# 実装 VM が AloeBC を直接読み込み、命令を逐次解釈または JIT コンパイルする。</li>
          </ul>
        </li>
        <li><strong>WASM ネイティブモード</strong>:
          <ul>
            <li>aloe2wasm により、AloeVM 命令列をほぼ 1:1 対応で WASM 命令列へ変換し、AloeVM 自体は存在しない。</li>
            <li>GC・低レベルのメモリ管理は WASM ランタイム（実行系）に委譲する。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 2. VM 値モデル -->
    <section id="vm-ch2" class="chapter">
      <h2>2. VM 値モデル</h2>

      <h3>2.1 VM 値のカテゴリ</h3>
      <p>VM 上で扱う値は、概念的に以下のカテゴリに分かれる。</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>例</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>整数（int32）</td>
              <td><code>int</code>, <code>enum</code>, <code>bitfield enum</code></td>
              <td>32bit 符号付き整数。enum は常に int ベース。</td>
            </tr>
            <tr>
              <td>整数（その他）</td>
              <td><code>byte</code></td>
              <td>内部的には int32 にパックして扱ってもよい。</td>
            </tr>
            <tr>
              <td>浮動小数点</td>
              <td><code>float</code></td>
              <td>32bit IEEE754。</td>
            </tr>
            <tr>
              <td>decimal</td>
              <td><code>decimal</code></td>
              <td>C# decimal と同程度の精度を持つ 128bit 近似表現（実装依存）。</td>
            </tr>
            <tr>
              <td>bool</td>
              <td><code>bool</code></td>
              <td>内部表現は 1byte or int32。命令セットでは int と同じ比較命令を再利用可。</td>
            </tr>
            <tr>
              <td>char</td>
              <td><code>char</code></td>
              <td>Unicode コードポイント（実装は UTF-16 でも UTF-32 でもよい）。</td>
            </tr>
            <tr>
              <td>オブジェクト参照</td>
              <td><code>class</code> インスタンス、<code>string</code></td>
              <td>ヒープオブジェクトへのハンドル（例: 64bit ID）。</td>
            </tr>
            <tr>
              <td>構造体</td>
              <td><code>struct</code></td>
              <td>VM 上では「値の塊」。実装により inline / boxed を選択。</td>
            </tr>
            <tr>
              <td>pipe</td>
              <td><code>pipe&lt;T&gt;</code></td>
              <td>VM レベルで専用タグを持つ。実装は OS パイプ／ソケット等。</td>
            </tr>
            <tr>
              <td>filter</td>
              <td><code>filter Foo</code></td>
              <td>VM レベルで専用タグ。関数＋接続情報のラッパ。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <strong>enum / bitfield enum</strong> は VM レベルでは <strong>常に int32</strong> として表現される。<br>
        bitfield enum の有効ビットは 0～31（最大 32 bit）に制限される。
      </div>

      <h3>2.2 AloeObject とヒープオブジェクト</h3>
      <p>
        C# 実装 VM では、ヒープ上のオブジェクトは <strong>オブジェクト ID（例: 64bit 整数）</strong> で識別される。
      </p>
      <ul>
        <li>VM 上でのオブジェクト値:
          <ul>
            <li>スタックやローカルには単に <code>objectId: long</code> が積まれる（<strong>AloeObject</strong>）。</li>
          </ul>
        </li>
        <li>メモリマネージャ側で、オブジェクト ID → メタデータを管理する:
          <ul>
            <li>クラス／構造体の <strong>フィールドリスト（参照スロット定義）</strong></li>
            <li>フィールドごとの <strong>値スロット</strong>（プリミティブ値 or 他オブジェクト ID）</li>
            <li>trait 合成後の最終的なフィールドレイアウト</li>
          </ul>
        </li>
        <li>構造体も同じ枠組みで扱える:
          <ul>
            <li>値型であっても、ヒープ上に配置する場合は同様に「フィールドリスト＋値スロット」で管理可能。</li>
            <li>VM の最適化次第で、スタック上に inline 展開するかどうかを切り替えられる。</li>
          </ul>
        </li>
      </ul>

      <h3>2.3 pipe / filter の VM タグ</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> と <code>filter</code> は、クラスインスタンスとは別の <strong>専用 VM 値タグ</strong> を持つ。</li>
        <li>ただし WASM 対応のため、内部表現は「ref 型」（例: <code>externref</code> / <code>funcref</code> / <code>anyref</code> 相当）にマッピングしやすい構造にする。</li>
        <li>pipe は「末端バッファ＋同期オブジェクトへの参照」、filter は「バインド済みハンドラ関数＋ in/out メタ情報」などを持つ。</li>
      </ul>
    </section>

    <!-- 3. コールスタックとフレーム -->
    <section id="vm-ch3" class="chapter">
      <h2>3. コールスタックとフレーム</h2>

      <h3>3.1 フレーム構造</h3>
      <p>各関数呼び出しは「フレーム」を生成する。フレームは少なくとも以下を持つ。</p>
      <ul>
        <li>戻りアドレス（次に実行する命令の PC）</li>
        <li>前のフレームへのリンク</li>
        <li>ローカル変数領域</li>
        <li>引数領域</li>
        <li>一時値スロット（必要なら）</li>
      </ul>

      <h3>3.2 呼び出し規約（概要）</h3>
      <ul>
        <li>関数呼び出し命令（例: <code>CALL</code>）は、引数をスタック上に積んだ状態で実行される。</li>
        <li>フレーム作成後、引数はローカル領域に移される（またはスタック上に残したままインデックス指定）。</li>
        <li>戻り値はスタックトップに 1 つだけ積まれる。</li>
        <li>void 関数は戻り値を積まない。</li>
      </ul>

      <h3>3.3 例外フレーム</h3>
      <ul>
        <li>例外ハンドラテーブルに基づき、スタックのどこまで巻き戻すかを決定する。</li>
        <li>巻き戻し後、catch ブロック先頭にジャンプし、例外オブジェクトをローカルまたはスタックに渡す。</li>
      </ul>
    </section>

    <!-- 4. ヒープとメモリ管理方針 -->
    <section id="vm-ch4" class="chapter">
      <h2>4. ヒープとメモリ管理方針（C# 実装 VM）</h2>

      <h3>4.1 スロットベースのヒープレイアウト</h3>
      <ul>
        <li>C# 実装 VM のヒープは、固定長スロットの配列として管理される。</li>
        <li>1 スロットあたりのバイト数は設定ファイルの <code>memory.slot_size_bytes</code> で指定し、
          未指定時のデフォルト値は <strong>16 バイト</strong> とする。</li>
        <li>すべてのヒープオブジェクトは、スロット境界（スロット先頭アドレス）から開始し、
          1 個以上の <strong>連続スロット</strong> を占有する。
          <ul>
            <li>オブジェクトの「長さ」はスロット数（<code>lengthSlots</code>）で管理される。</li>
            <li>実際のバイト長は <code>lengthSlots × slot_size_bytes</code> となる。</li>
          </ul>
        </li>
        <li>実装上、ヒープは 1 つまたは複数の「アリーナ」に分割されてもよい。
          <ul>
            <li>単一アリーナ構成の場合：全オブジェクトを 1 つのスロット配列で管理する。</li>
            <li>将来の最適化として、サイズクラスごとに別アリーナ（16/32/64 バイトなど）を持つ構成も許容する。</li>
          </ul>
        </li>
      </ul>

      <h3>4.2 ハンドルと変数テーブル</h3>
      <ul>
        <li>第 2 章で述べたとおり、ヒープオブジェクトは <strong>オブジェクト ID（ハンドル）</strong> によって識別される。</li>
        <li>VM 内部では、ハンドルから実際のヒープ上の位置を引くために、
          <strong>変数テーブル（またはオブジェクトテーブル）</strong> を持つ。
          典型的には以下の情報を保持する：
          <ul>
            <li>所属アリーナ ID</li>
            <li>先頭スロット index（整数）</li>
            <li>占有スロット数（<code>lengthSlots</code>）</li>
            <li>参照カウント（refcount）</li>
            <li>型情報への参照（クラス／構造体のメタデータ ID）</li>
          </ul>
        </li>
        <li>VM のオペコードやランタイムは、<strong>生ポインタではなくハンドル</strong> を扱う。
          <ul>
            <li>ハンドル → テーブル → 先頭スロットアドレス、という 2 段階で物理メモリに到達する。</li>
            <li>オブジェクトの移動（コンパクション）が発生しても、変数テーブルの 1 箇所を書き換えるだけで済む。</li>
          </ul>
        </li>
      </ul>

      <h3>4.3 参照カウントによる寿命管理</h3>
      <ul>
        <li>各ヒープオブジェクトは <strong>参照カウント（reference count）</strong> を持つ。</li>
        <li>参照カウントの増減タイミング（例）:
          <ul>
            <li>ローカル変数やフィールドにハンドルを格納する際にインクリメント。</li>
            <li>変数がスコープから抜ける／フィールドから別の値に置き換えられるときにデクリメント。</li>
          </ul>
        </li>
        <li>参照カウントが 0 になったオブジェクトは「到達不能」とみなし、
          そのオブジェクトが占有していたスロットを次のように扱う：
          <ul>
            <li>スロットの内容を 0 で初期化する（論理的に「空き」として扱いやすくする）。</li>
            <li>スロット状態テーブル（<code>slot_used[i] = false</code> など）を更新し、空きスロットとしてマークする。</li>
          </ul>
        </li>
        <li>循環参照（<code>A → B → A</code> 等）は参照カウントだけでは解放できないため、
          <strong>実装上の制約または将来の補助 GC</strong> によって対処する：
          <ul>
            <li>言語レベルで強い循環を作りにくい設計（所有権／weak 参照）を推奨する。</li>
            <li>または必要に応じて、低優先度のマーク＆スイープを併用し、循環のみを回収してもよい。</li>
          </ul>
        </li>
      </ul>

      <h3>4.4 アクセス時スライディング・コンパクション</h3>
      <p>
        AloeVM のヒープは、断片化を防ぐために <strong>「アクセス時に少しだけ詰める」スライディング・コンパクション</strong> を行う。
        これは、オブジェクトにアクセスしたタイミングでそのオブジェクトを前方にスライドさせ、
        スロットの空きを徐々に前方へ集約していく仕組みである。
      </p>
      <ul>
        <li>変数ハンドルにアクセスする命令は、概念的に以下の処理を行う：
          <ol>
            <li>ハンドルから変数テーブルを引き、<code>(arenaId, slotIndex, lengthSlots)</code> を取得する。</li>
            <li>同じアリーナ内で、<code>slotIndex - lengthSlots</code> から <code>slotIndex - 1</code> までのスロットが
              すべて空き（未使用）であるかを確認する。
              <ul>
                <li>単純化のため、実装では「スロット状態テーブルのフラグ」を見るだけでもよい。</li>
              </ul>
            </li>
            <li>もし上記の範囲が完全に空きであれば、
              <ul>
                <li>オブジェクトを前方に <code>lengthSlots</code> スロット分スライドさせる（コピー）。</li>
                <li>旧領域（元の <code>slotIndex ～ slotIndex + lengthSlots - 1</code>）を 0 クリアし、空きスロットとしてマークする。</li>
                <li>変数テーブル内の <code>slotIndex</code> を <code>slotIndex - lengthSlots</code> に更新する。</li>
              </ul>
            </li>
            <li>更新後の先頭スロットから、実際のオブジェクトフィールドにアクセスする。</li>
          </ol>
        </li>
        <li>このルールにより、1 回のアクセスで触るメモリ量は高々「自分のサイズ（<code>lengthSlots</code> スロット）」に抑えられる。
          <ul>
            <li>「ヒープ全体を走査して一気に詰める」タイプの stop-the-world GC を避け、
              断片化解消コストを <strong>アクセスに分散</strong> できる。</li>
          </ul>
        </li>
        <li>すべてのオブジェクトはスロット境界から始まるため、スライド後も必ずスロット境界に揃った整合性の取れたレイアウトが維持される。</li>
        <li>この「アクセス時スライド」は必須ではなく、実装によっては
          <ul>
            <li>頻度を下げる（一定回数に 1 回だけ実施）</li>
            <li>1 アクセスあたりの最大移動スロット数に上限を設ける</li>
          </ul>
          などの調整を行ってよい。
        </li>
      </ul>

      <h3>4.5 アロケーション戦略</h3>
      <ul>
        <li>新しいオブジェクトを確保する際、メモリマネージャは以下を行う：
          <ol>
            <li>必要なスロット数 <code>lengthSlots</code> を計算する（<code>ceil(objectSizeBytes / slot_size_bytes)</code>）。</li>
            <li>現在のアリーナ内、または複数アリーナの中から、<strong>十分な連続空きスロット</strong> を探索する。</li>
            <li>見つかった先頭スロットにオブジェクトを配置し、スロット状態テーブルと変数テーブルを更新する。</li>
          </ol>
        </li>
        <li>空きスロットの管理方法は実装に依存するが、典型的には以下のいずれか：
          <ul>
            <li>単純な線形探索（プロトタイプ段階）</li>
            <li>連続スロット範囲のフリーリスト</li>
            <li>ビットマップ＋first-fit/best-fit アルゴリズム</li>
          </ul>
        </li>
        <li>どのアリーナにも必要な連続空きスロットが見つからない場合：
          <ul>
            <li>アクセス時スライドの頻度を一時的に上げて断片化を軽減する。</li>
            <li>またはヒープを拡張し、新しいアリーナを追加する。</li>
          </ul>
        </li>
      </ul>

      <h3>4.6 delete と解放タイミング</h3>
      <ul>
        <li>Aloe 言語の <code>delete x;</code> は、「変数 <code>x</code> が保持しているハンドルへの参照を切る」という意味であり、
          その瞬間に物理的なメモリが解放されることは <strong>保証されない</strong>。</li>
        <li>参照カウントが 0 になったオブジェクトは、次のタイミングで解放処理対象となる：
          <ul>
            <li>カウンタが 0 になった瞬間に、そのオブジェクトのスロットを 0 クリアし、空きスロットとしてマークする。</li>
            <li>または低優先度のバックグラウンド処理で順次解放してもよい（実装依存）。</li>
          </ul>
        </li>
        <li>したがって、Aloe プログラムは「delete 直後に必ずヒープ使用量が減る」とは期待してはいけない。
          あくまで <strong>「そのオブジェクトはもはや利用されない」という論理的な宣言</strong> に過ぎない。</li>
      </ul>

      <h3>4.7 WASM 実装時のメモリ管理</h3>
      <div class="note">
        WASM ネイティブモードでは、AloeVM 独自のスロット制メモリ管理および参照カウントは必須ではない。<br>
        GC・メモリ確保・解放は <strong>WASM 実行系およびホストランタイムに委譲</strong>する。
      </div>
      <ul>
        <li>Aloe のオブジェクトは、WASM の <code>struct</code> / <code>array</code> / <code>ref</code> などへ直接マッピングされうる。</li>
        <li>WASM GC やホストランタイム（例: .NET, JVM, JS）の GC が責務を負うため、
          本章で述べたスロットレイアウト・アクセス時スライドは C# 実装 VM の内部仕様に留まる。</li>
        <li>aloe2wasm などのコンパイラは、AloeVM の抽象メモリモデルを維持しつつ、
          実際の GC はターゲット環境の仕組みに任せることが推奨される。</li>
      </ul>
    </section>

    <!-- 5. パイプ / フィルタ -->
    <section id="vm-ch5" class="chapter">
      <h2>5. パイプ / フィルタの VM 表現</h2>

      <h3>5.1 pipe&lt;T&gt;</h3>
      <ul>
        <li>VM レベルで <strong>PIPE</strong> タグを持つ値として表現する。</li>
        <li>内部には以下のような情報を持つ想定:
          <ul>
            <li>バッファ（リングバッファ／キュー）</li>
            <li>同期プリミティブ（ロック／条件変数など）</li>
            <li>要素の型情報（ランタイム型情報への参照）</li>
          </ul>
        </li>
        <li>複数スレッドからアクセスしても壊れないよう、実装はスレッドセーフであること。</li>
        <li>実装例:
          <ul>
            <li>OS パイプ／ソケット</li>
            <li>メモリマップドファイル上のリングバッファ</li>
          </ul>
        </li>
      </ul>

      <h3>5.2 filter</h3>
      <ul>
        <li>filter は専用タグ（FILTER）を持つ値として表現される。</li>
        <li>filter 値は、概念的には
          <ul>
            <li>「bound 関数へのポインタ」</li>
            <li>フィルタ定義メタ情報（in/out 型）</li>
          </ul>
          をまとめた構造体。
        </li>
        <li>ユーザ定義フィルタも同じ仕組みで表現できる。</li>
      </ul>

      <h3>5.3 パイプライン文の実行モデル</h3>
      <pre><code class="language-aloe">
A | filter(F) | B;
      </code></pre>
      <ul>
        <li>VM はこの文を「接続構築命令」の列に展開する。</li>
        <li>典型的な流れ:
          <ol>
            <li><code>A</code> の出力 pipe を解決する。</li>
            <li><code>filter(F)</code> のインスタンスを生成し、<code>bound(input, output)</code> を別タスク／スレッドとして起動。</li>
            <li>出力 pipe を <code>B</code> に接続する。</li>
          </ol>
        </li>
        <li>実装によっては、複数フィルタを 1 スレッド内で順次処理する最適化も可能。</li>
      </ul>
    </section>

    <!-- 6. AloeBC バイナリ形式 -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC バイナリ形式</h2>

      <h3>6.1 全体構造</h3>
      <p>AloeBC（Aloe Byte Code）は、AloeVM 向けコンパイル結果を格納するバイナリフォーマットである。</p>

      <h3>6.2 ヘッダ</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>オフセット</th>
              <th>サイズ</th>
              <th>フィールド</th>
              <th>内容</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 byte</td>
              <td>Magic</td>
              <td>ASCII 文字列 <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>メジャーバージョン</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>マイナーバージョン</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>ビルド番号</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Reserved</td>
              <td>予約（0 固定）</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 byte</td>
              <td>HeaderSize</td>
              <td>ヘッダ全体のサイズ（リトルエンディアン）</td>
            </tr>
            <tr>
              <td>14</td>
              <td>4 byte</td>
              <td>ConstPoolOffset</td>
              <td>定数プールの先頭オフセット</td>
            </tr>
            <tr>
              <td>18</td>
              <td>4 byte</td>
              <td>TypeTableOffset</td>
              <td>型テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>22</td>
              <td>4 byte</td>
              <td>FuncTableOffset</td>
              <td>関数テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>26</td>
              <td>4 byte</td>
              <td>CodeSectionOffset</td>
              <td>コードセクションの先頭オフセット</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>エンディアンは <strong>リトルエンディアン</strong> を前提とする。</p>

      <h3>6.3 定数プール（概要）</h3>
      <ul>
        <li>文字列リテラル、数値リテラル、型情報などを一元管理する。</li>
        <li>各エントリは「タグ + 長さ + 本体」で構成される可変長レコード。</li>
        <li>タグの例:
          <ul>
            <li>0x01: UTF-8 文字列</li>
            <li>0x02: int32</li>
            <li>0x03: float32</li>
            <li>0x04: decimal</li>
          </ul>
        </li>
      </ul>

      <h3>6.4 型テーブル（概要）</h3>
      <ul>
        <li>各 Aloe 型（class / struct / enum / bitfield enum / pipe&lt;T&gt; など）に ID を割り当てる。</li>
        <li>enum / bitfield enum は VM 上では <strong>int32 値型</strong> としてフラグ付けされる。</li>
        <li>bitfield enum の有効ビット数（0～31）はメタ情報として保持してもよい（警告発生などに利用）。</li>
      </ul>

      <h3>6.5 関数テーブル・コードセクション</h3>
      <ul>
        <li>関数テーブル:
          <ul>
            <li>関数シグネチャ（引数の型、戻り値の型）</li>
            <li>ローカル変数の数</li>
            <li>コードセクション内のオフセット・長さ</li>
          </ul>
        </li>
        <li>コードセクション:
          <ul>
            <li>VM 命令列をバイト列として格納。</li>
            <li>命令セットの詳細は第 7 章参照。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 7. 命令セットと WASM 対応 -->
    <section id="vm-ch7" class="chapter">
      <h2>7. 命令セットと WASM 対応（概要）</h2>

      <h3>7.1 命令カテゴリ</h3>
      <p>命令セットはおおよそ以下のカテゴリに分かれる想定。</p>
      <ul>
        <li>スタック操作命令
          <ul>
            <li>PUSH, POP, DUP, SWAP など</li>
          </ul>
        </li>
        <li>算術・論理命令
          <ul>
            <li>ADD, SUB, MUL, DIV, MOD</li>
            <li>AND, OR, XOR, SHL, SHR</li>
          </ul>
        </li>
        <li>比較命令
          <ul>
            <li>CMPEQ, CMPNE, CMPLT, CMPLE, CMPGT, CMPGE</li>
          </ul>
        </li>
        <li>制御フロー命令
          <ul>
            <li>JMP, JMP_IF_TRUE, JMP_IF_FALSE</li>
          </ul>
        </li>
        <li>関数呼び出し命令
          <ul>
            <li>CALL, RET</li>
          </ul>
        </li>
        <li>オブジェクト操作命令
          <ul>
            <li>NEWOBJ, GETFIELD, SETFIELD など</li>
          </ul>
        </li>
        <li>配列・コレクション操作命令（将来）</li>
        <li>pipe / filter 操作命令（接続・read/write）</li>
      </ul>

      <div class="note">
        命令セットの「数値（opcode）」と「バイナリフォーマットとしての具体的ビット配置」については、<br>
        以下 7.4「命令セット表（ドラフト）」に暫定版を定義する。将来の最適化や実装上の都合により変更される可能性がある。
      </div>

      <h3>7.2 WASM への 1:1 マッピング方針</h3>
      <ul>
        <li>基本算術・比較命令は、可能な限り WASM の <code>i32.add</code>, <code>i32.lt_s</code> などへ 1:1 でマッピングする。</li>
        <li>スタック操作も WASM のスタックマシンと概念的に一致するため、ほぼそのまま変換可能。</li>
        <li>例外処理は、WASM の exception handling 拡張またはエラーコード + ブロック構造の組み合わせで表現する。</li>
        <li>pipe / filter は、WASM の <code>ref</code> 型＋ホスト関数を用いて実装されることが多い。</li>
      </ul>

      <h3>7.3 aloe2wasm の役割</h3>
      <ul>
        <li>Aloe ソース → AloeBC → AloeVM 実行 という経路とは別に、
          <ul>
            <li>Aloe ソース → 中間 IR → WASM という <strong>ネイティブ WASM ビルド</strong> 経路を用意する。</li>
          </ul>
        </li>
        <li>このとき、AloeVM 命令セットと WASM 命令セットが近いほど、コンパイラ実装が単純になる。</li>
        <li>理想的には「AloeVM 命令列をそのまま WASM にシリアライズするだけ」で動作するレベルを目指す。</li>
      </ul>

      <h3>7.4 命令セット表（ドラフト）</h3>
      <p>
        ここでは、AloeVM の最小実行系を実装するために必要となる <strong>コア命令群</strong> を暫定的に定義する。<br>
        opcode は 1 byte を想定し、表記は 16 進数（0xNN）とする。
      </p>
      <p>
        スタック効果は <code>… , A , B → … , R</code> のように記載する（左が実行前、右が実行後）。<br>
        ここで <code>…</code> はスタックのそれ以外の部分を表す。
      </p>

      <h4>7.4.1 スタック操作・定数ロード</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="4">スタック</td>
              <td>NOP</td>
              <td>0x00</td>
              <td>なし</td>
              <td>… → …</td>
              <td>何もしない。</td>
            </tr>
            <tr>
              <td>POP</td>
              <td>0x01</td>
              <td>なし</td>
              <td>… , A → …</td>
              <td>スタックトップを 1 つ捨てる。</td>
            </tr>
            <tr>
              <td>DUP</td>
              <td>0x02</td>
              <td>なし</td>
              <td>… , A → … , A , A</td>
              <td>スタックトップを複製する。</td>
            </tr>
            <tr>
              <td>SWAP</td>
              <td>0x03</td>
              <td>なし</td>
              <td>… , A , B → … , B , A</td>
              <td>スタックトップ 2 要素を入れ替える。</td>
            </tr>
            <tr>
              <td rowspan="7">定数</td>
              <td>LDC_I4_S</td>
              <td>0x10</td>
              <td>int8（符号付き）</td>
              <td>… → … , i32</td>
              <td>符号付き 8bit 即値を int32 として積む（小さな整数用）。</td>
            </tr>
            <tr>
              <td>LDC_I4</td>
              <td>0x11</td>
              <td>int32</td>
              <td>… → … , i32</td>
              <td>32bit 整数即値を積む。</td>
            </tr>
            <tr>
              <td>LDC_F</td>
              <td>0x12</td>
              <td>float32</td>
              <td>… → … , f32</td>
              <td>32bit 浮動小数点即値を積む。</td>
            </tr>
            <tr>
              <td>LDC_DEC</td>
              <td>0x13</td>
              <td>decimal（16 byte）</td>
              <td>… → … , decimal</td>
              <td>decimal 即値を積む（定数プール参照でも可、実装依存）。</td>
            </tr>
            <tr>
              <td>LDC_STR</td>
              <td>0x14</td>
              <td>uint16（定数プール index）</td>
              <td>… → … , obj</td>
              <td>定数プール中の文字列をロードし、string オブジェクト参照を積む。</td>
            </tr>
            <tr>
              <td>LDC_BOOL</td>
              <td>0x15</td>
              <td>byte（0 or 1）</td>
              <td>… → … , bool</td>
              <td>bool 即値を積む。</td>
            </tr>
            <tr>
              <td>LDC_NULL</td>
              <td>0x16</td>
              <td>なし</td>
              <td>… → … , null</td>
              <td>null 参照を積む。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.2 ローカル変数・引数アクセス</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">ローカル</td>
              <td>LDLOC</td>
              <td>0x20</td>
              <td>uint16（index）</td>
              <td>… → … , V</td>
              <td>現在フレームのローカル変数 index の値をロードする。</td>
            </tr>
            <tr>
              <td>STLOC</td>
              <td>0x21</td>
              <td>uint16（index）</td>
              <td>… , V → …</td>
              <td>スタックトップの値をローカル変数 index にストアする。</td>
            </tr>
            <tr>
              <td>LDLOC_ADDR</td>
              <td>0x22</td>
              <td>uint16（index）</td>
              <td>… → … , ref</td>
              <td>ローカル変数への参照（アドレス）を積む（将来の最適化用、オプション）。</td>
            </tr>
            <tr>
              <td rowspan="2">引数</td>
              <td>LDARG</td>
              <td>0x28</td>
              <td>uint16（index）</td>
              <td>… → … , V</td>
              <td>現在フレームの引数 index の値をロードする。</td>
            </tr>
            <tr>
              <td>STARG</td>
              <td>0x29</td>
              <td>uint16（index）</td>
              <td>… , V → …</td>
              <td>スタックトップの値を引数スロットに書き戻す（ref 引数などを想定）。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.3 算術・比較・論理</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="6">算術（int32）</td>
              <td>ADD_I4</td>
              <td>0x30</td>
              <td>なし</td>
              <td>… , A , B → … , (A + B)</td>
              <td>int32 加算。</td>
            </tr>
            <tr>
              <td>SUB_I4</td>
              <td>0x31</td>
              <td>なし</td>
              <td>… , A , B → … , (A - B)</td>
              <td>int32 減算。</td>
            </tr>
            <tr>
              <td>MUL_I4</td>
              <td>0x32</td>
              <td>なし</td>
              <td>… , A , B → … , (A * B)</td>
              <td>int32 乗算。</td>
            </tr>
            <tr>
              <td>DIV_I4</td>
              <td>0x33</td>
              <td>なし</td>
              <td>… , A , B → … , (A / B)</td>
              <td>int32 除算（0 除算は例外）。</td>
            </tr>
            <tr>
              <td>MOD_I4</td>
              <td>0x34</td>
              <td>なし</td>
              <td>… , A , B → … , (A % B)</td>
              <td>int32 剰余。</td>
            </tr>
            <tr>
              <td>NEG_I4</td>
              <td>0x35</td>
              <td>なし</td>
              <td>… , A → … , (-A)</td>
              <td>符号反転。</td>
            </tr>
            <tr>
              <td rowspan="3">比較</td>
              <td>CMPEQ</td>
              <td>0x40</td>
              <td>なし</td>
              <td>… , A , B → … , bool</td>
              <td>等値比較。</td>
            </tr>
            <tr>
              <td>CMPNE</td>
              <td>0x41</td>
              <td>なし</td>
              <td>… , A , B → … , bool</td>
              <td>不等比較。</td>
            </tr>
            <tr>
              <td>CMPLT_I4</td>
              <td>0x42</td>
              <td>なし</td>
              <td>… , A , B → … , bool</td>
              <td>A &lt; B （符号付き）比較。</td>
            </tr>
            <tr>
              <td rowspan="3">論理 / ビット</td>
              <td>AND_I4</td>
              <td>0x48</td>
              <td>なし</td>
              <td>… , A , B → … , (A &amp; B)</td>
              <td>ビット AND。</td>
            </tr>
            <tr>
              <td>OR_I4</td>
              <td>0x49</td>
              <td>なし</td>
              <td>… , A , B → … , (A | B)</td>
              <td>ビット OR。</td>
            </tr>
            <tr>
              <td>XOR_I4</td>
              <td>0x4A</td>
              <td>なし</td>
              <td>… , A , B → … , (A ^ B)</td>
              <td>ビット XOR。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.4 制御フロー・関数呼び出し・例外</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">分岐</td>
              <td>JMP</td>
              <td>0x50</td>
              <td>int32（相対オフセット）</td>
              <td>… → …</td>
              <td>無条件ジャンプ。</td>
            </tr>
            <tr>
              <td>JMP_TRUE</td>
              <td>0x51</td>
              <td>int32（相対オフセット）</td>
              <td>… , cond → …</td>
              <td>cond が true の場合にジャンプし、スタックから cond を POP する。</td>
            </tr>
            <tr>
              <td>JMP_FALSE</td>
              <td>0x52</td>
              <td>int32（相対オフセット）</td>
              <td>… , cond → …</td>
              <td>cond が false の場合にジャンプし、スタックから cond を POP する。</td>
            </tr>
            <tr>
              <td rowspan="2">呼び出し</td>
              <td>CALL</td>
              <td>0x58</td>
              <td>uint16（関数 ID）</td>
              <td>… , args → … , ret</td>
              <td>関数テーブル中の関数を呼び出す。引数個数・型はメタ情報に従う。</td>
            </tr>
            <tr>
              <td>RET</td>
              <td>0x59</td>
              <td>なし</td>
              <td>… , ret? → … , ret?</td>
              <td>現在フレームを終了し、呼び出し元へ戻る（戻り値は 0 または 1 個）。</td>
            </tr>
            <tr>
              <td rowspan="2">例外</td>
              <td>THROW</td>
              <td>0x5C</td>
              <td>なし</td>
              <td>… , ex → （スタック巻き戻し）</td>
              <td>例外オブジェクト ex をスローする。</td>
            </tr>
            <tr>
              <td>RETHROW</td>
              <td>0x5D</td>
              <td>なし</td>
              <td>… , ex → （スタック巻き戻し）</td>
              <td>catch ブロック内から例外を再スローする。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.5 オブジェクト・フィールド・pipe/filter</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="3">オブジェクト</td>
              <td>NEWOBJ</td>
              <td>0x60</td>
              <td>uint16（型 ID）、uint8（引数個数）</td>
              <td>… , args → … , obj</td>
              <td>指定クラス／構造体のインスタンスを生成し、コンストラクタを呼び出す。</td>
            </tr>
            <tr>
              <td>GETFIELD</td>
              <td>0x61</td>
              <td>uint16（フィールド ID）</td>
              <td>… , obj → … , value</td>
              <td>オブジェクトのフィールド値を取得する。</td>
            </tr>
            <tr>
              <td>SETFIELD</td>
              <td>0x62</td>
              <td>uint16（フィールド ID）</td>
              <td>… , obj , value → …</td>
              <td>オブジェクトのフィールドに値を設定する。</td>
            </tr>
            <tr>
              <td rowspan="3">pipe</td>
              <td>PIPE_NEW</td>
              <td>0x70</td>
              <td>uint16（型 ID）</td>
              <td>… → … , pipe</td>
              <td>指定型 T の <code>pipe&lt;T&gt;</code> を生成する。</td>
            </tr>
            <tr>
              <td>PIPE_SEND</td>
              <td>0x71</td>
              <td>なし</td>
              <td>… , pipe , value → …</td>
              <td>pipe に 1 要素を書き込む（ブロック／非ブロックは実装依存）。</td>
            </tr>
            <tr>
              <td>PIPE_RECV</td>
              <td>0x72</td>
              <td>なし</td>
              <td>… , pipe → … , value</td>
              <td>pipe から 1 要素を読み出す（データが無い場合の挙動は実装定義）。</td>
            </tr>
            <tr>
              <td rowspan="2">filter</td>
              <td>FILTER_NEW</td>
              <td>0x78</td>
              <td>uint16（filter 定義 ID）</td>
              <td>… → … , filter</td>
              <td>フィルタ定義に基づき filter インスタンスを生成する。</td>
            </tr>
            <tr>
              <td>FILTER_BIND</td>
              <td>0x79</td>
              <td>なし</td>
              <td>… , filter , inPipe , outPipe → … , filter</td>
              <td>filter に入力／出力 pipe をバインドする（パイプライン構築用）。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h4>7.4.6 デバッグ・拡張用</h4>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>Mnemonic</th>
              <th>Opcode</th>
              <th>オペランド</th>
              <th>スタック効果</th>
              <th>説明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>デバッグ</td>
              <td>BREAK</td>
              <td>0x7F</td>
              <td>なし</td>
              <td>… → …</td>
              <td>デバッガ用ブレークポイント。実行時にホストへ通知し、停止することができる。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        上記の命令セット表は <strong>プロトタイプ実装用の最小コア</strong> を示すドラフトであり、<br>
        実際の実装段階で opcode の追加・削除・再配置が発生する可能性がある。<br>
        その場合でも、「スタック効果」と「意味論」が互換である限り、Aloe 言語仕様との整合性は保たれる。
      </div>
    </section>

    <!-- 8. 未決事項・TODO -->
    <section id="vm-ch8" class="chapter">
      <h2>8. 未決事項・TODO</h2>

      <h3>8.1 まだ決まっていない事項</h3>
      <ul>
        <li>各命令の opcode 割り当てと、正確なバイナリ形式（7.4 の命令セット表の「確定版」）</li>
        <li>例外ハンドラテーブルの具体的なフォーマット（範囲指定、catch 種別など）</li>
        <li>構造体の inline 展開と box/unbox の扱い</li>
        <li>スロットアリーナ構成の詳細（単一アリーナか複数サイズクラスか）</li>
        <li>参照カウントと循環検出（補助 GC）を併用する場合のアルゴリズム</li>
        <li>pipe / filter のスレッドモデル（1 フィルタ 1 スレッドか、ワーカー共有か）</li>
        <li>WASM 版での pipe / filter の標準 ABI（ホストとのインターフェース）</li>
      </ul>

      <h3>8.2 将来の拡張候補</h3>
      <ul>
        <li>JIT コンパイル層（ホット関数のネイティブコード化）</li>
        <li>デバッガフック（ブレークポイント・ステップ実行・変数ウォッチ）</li>
        <li>プロファイラ API（実行時間・割り当てメモリの計測）</li>
        <li>分散実行（複数プロセス／ノードにまたがる pipe のサポート）</li>
      </ul>

      <div class="note">
        現在の仕様書の内容だけでも、<strong>Aloe コンパイラ / C# 実装の AloeVM / aloe2wasm のプロトタイプ</strong>は実装可能なレベルを目指している。<br>
        ただし、命令セット表やメモリ管理の細部は試行錯誤しつつブラッシュアップしていく前提。
      </div>
    </section>

  </main>
</div>
</body>
</html>
```
