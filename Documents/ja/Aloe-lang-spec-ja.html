
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Aloe 言語仕様書（ドラフト、日本語 + with 拡張）</title>
  <style>
    /* レイアウトだけ最低限。フォントはブラウザ標準任せにしておく */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1rem;
    }
    .sidebar h2 {
      font-size: 0.8rem;
      margin: 0.8rem 0 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.85rem;
    }
    .sidebar nav li {
      margin: 0.1rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.2rem 0.35rem;
      border-radius: 0.3rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar a.active {
      background: #1d4ed8;
      color: #e5e7eb;
    }
    .chapter-index {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.3rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 1.8rem 2.4rem;
      box-sizing: border-box;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.4em;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #f3f4f6;
      padding: 0.7rem 0.9rem;
      border-radius: 0.4rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 1.8rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }

    .chapter {
      display: none;
    }
    .chapter.active {
      display: block;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- 左メニュー -->
  <aside class="sidebar">
    <h1>Aloe Language Specification</h1>
    <div class="subtitle">
      Draft / 日本語訳 + <code>with</code> 拡張
    </div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a class="nav-link active" data-target="ch0"><span class="chapter-index">0.</span>概要</a></li>
        <li><a class="nav-link" data-target="ch1"><span class="chapter-index">1.</span>基本文法</a></li>
        <li><a class="nav-link" data-target="ch2"><span class="chapter-index">2.</span>型システム</a></li>
        <li><a class="nav-link" data-target="ch3"><span class="chapter-index">3.</span>数値と変換</a></li>
        <li><a class="nav-link" data-target="ch4"><span class="chapter-index">4.</span>ブロックとスコープ</a></li>
        <li><a class="nav-link" data-target="ch5"><span class="chapter-index">5.</span>変数と定数</a></li>
        <li><a class="nav-link" data-target="ch6"><span class="chapter-index">6.</span>フィールド</a></li>
        <li><a class="nav-link" data-target="ch7"><span class="chapter-index">7.</span>クラス / 構造体 / インタフェース / トレイト</a></li>
        <li><a class="nav-link" data-target="ch8"><span class="chapter-index">8.</span>delete と null</a></li>
        <li><a class="nav-link" data-target="ch9"><span class="chapter-index">9.</span>is 演算子</a></li>
        <li><a class="nav-link" data-target="ch10"><span class="chapter-index">10.</span>コレクション</a></li>
        <li><a class="nav-link" data-target="ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a class="nav-link" data-target="ch12"><span class="chapter-index">12.</span>main ブロック</a></li>
        <li><a class="nav-link" data-target="ch13"><span class="chapter-index">13.</span>一時変数 <code>_</code></a></li>
        <li><a class="nav-link" data-target="ch14"><span class="chapter-index">14.</span>swap キーワード</a></li>
        <li><a class="nav-link" data-target="ch15"><span class="chapter-index">15.</span>演算子</a></li>
        <li><a class="nav-link" data-target="ch16"><span class="chapter-index">16.</span>例外</a></li>
        <li><a class="nav-link" data-target="ch17"><span class="chapter-index">17.</span>モジュール / namespace / import</a></li>
        <li><a class="nav-link" data-target="ch18"><span class="chapter-index">18.</span>Pipes と Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a class="nav-link" data-target="ch4">4.2 with ブロック</a></li>
      </ul>
    </nav>
  </aside>

  <!-- 右コンテンツ -->
  <main class="content">
    <h1>Aloe 言語仕様書（ドラフト、日本語版）</h1>
    <p class="note">
      元文書：<code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code> をベースに翻訳し、<br />
      さらに <strong>4.2 with-blocks</strong> に「ピリオド省略版 + 型ベース with (class/struct/enum の static/列挙子ショートカット)」を追加しています。<br />
      併せて、<strong>サンプル中のメソッド名 / プロパティ名 / フィールド名は PascalCase（先頭大文字）</strong> にそろえています。
    </p>

    <!-- 0. Overview -->
    <section class="chapter active" id="ch0">
      <hr />
      <h2>0. Overview（概要）</h2>
      <p>
        Aloe は静的型付けスクリプト言語で、シンプルで直感的な構文を持ち、スタックベース仮想マシン（AloeVM）上で動作する。
      </p>
      <ul>
        <li>教育用途や小規模アプリケーションで読み書きしやすいこと。</li>
        <li>C# ランタイムおよび WASM 環境をターゲットとすること。</li>
        <li><code>pipe</code> と <code>filter</code> によって、I/O と並行処理を静的型付けのまま制御できること。</li>
      </ul>
      <p>主な特徴：</p>
      <ul>
        <li>静的型付け
          <ul>
            <li><code>var</code> による型推論。</li>
            <li><code>let</code> による明示的な型指定。</li>
          </ul>
        </li>
        <li>値型 / 参照型
          <ul>
            <li><code>struct</code> … 値型</li>
            <li><code>class</code> … 参照型</li>
          </ul>
        </li>
        <li>GC ベースのメモリ管理（アルゴリズムは VM 実装依存）。</li>
        <li>コード中に明示的な <code>= null</code> は書かない（<code>delete</code> を使う）。</li>
        <li><code>pipe</code> / <code>filter</code> によるデータフロー志向の設計。</li>
      </ul>
    </section>

    <!-- 1. Basic Syntax -->
    <section class="chapter" id="ch1">
      <hr />
      <h2>1. Basic Syntax（基本文法）</h2>

      <h3>1.1 Comments（コメント）</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
      <ul>
        <li><code>//</code> から行末までが行コメント。</li>
        <li><code>/* ... */</code> が複数行コメント。</li>
        <li>ネストした <code>/* */</code> は未定義（非サポート）。</li>
      </ul>

      <h3>1.2 Identifiers（識別子）</h3>
      <ul>
        <li>使用可能：英字 (A–Z, a–z)、数字 (0–9)、アンダースコア <code>_</code>。</li>
        <li>先頭は英字または <code>_</code>。</li>
        <li>大文字小文字は区別される。</li>
        <li>キーワードと同綴りは使用不可。</li>
        <li><code>_</code> で始まる識別子は慣習的に「プライベート」。</li>
        <li>Unicode 文字も一部使用可能（空白や区切り記号は除く）。</li>
      </ul>

      <h3>1.3 Keywords（キーワード）</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
      <ul>
        <li><code>package</code> の代わりに <code>namespace</code> を使用。</li>
        <li><code>final</code> は廃止され、<code>sealed</code> を使用。</li>
        <li><code>instanceof</code> は廃止され、<code>is</code> を使用。</li>
      </ul>

      <h3>1.4 Literals（リテラル）</h3>
      <ul>
        <li>整数：<code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code> など</li>
        <li>浮動小数点：<code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
        <li>10 進：<code>10.12345678901234567890:d</code> など</li>
        <li>真偽値：<code>true</code>, <code>false</code></li>
        <li>文字列：<code>"Hello, World!"</code></li>
        <li>文字：<code>'A'</code>, <code>'z'</code> など</li>
        <li>null リテラル：<code>null</code>（代入には直接使わない）</li>
        <li>配列リテラル：<code>[1, 2, 3]</code></li>
        <li>リストリテラル：<code>(1, 2, 3)</code></li>
        <li>セットリテラル：<code>{1, 2, 3}</code></li>
        <li>マップリテラル：<code>["key1": 10, "key2": 20]</code></li>
        <li>enum リテラル：<code>EnumType.Value1</code></li>
        <li>struct リテラル：<code>Point { X: 0, Y: 1 }</code></li>
        <li>オブジェクト生成：<code>new ClassName()</code></li>
      </ul>

      <h3>1.5 Statement terminator（文末）</h3>
<pre><code>var X = 10;
X = X + 1;
Print(X);
</code></pre>
      <ul>
        <li>すべての文は <code>;</code> で終わる。</li>
        <li>改行による自動セミコロン挿入は行わない。</li>
      </ul>

      <h3>1.6 Whitespace（空白） / 1.7 Case sensitivity</h3>
      <ul>
        <li>空白・タブ・改行はトークン区切り。</li>
        <li>複数の空白は 1 つの区切りとみなす。</li>
        <li>インデントに意味はない。</li>
        <li>識別子／キーワードは大文字小文字を区別。</li>
        <li>キーワードはすべて小文字。</li>
      </ul>
    </section>

    <!-- 2. Type System -->
    <section class="chapter" id="ch2">
      <hr />
      <h2>2. Type System（型システム）</h2>

      <h3>2.1 Primitive types</h3>
      <ul>
        <li><code>int</code> / <code>integer</code></li>
        <li><code>float</code></li>
        <li><code>bool</code> / <code>boolean</code></li>
        <li><code>decimal</code></li>
        <li><code>string</code></li>
        <li><code>char</code></li>
        <li><code>byte</code></li>
        <li><code>void</code></li>
        <li><code>null</code>（リテラル）</li>
      </ul>

      <h3>2.2 Composite / user-defined types</h3>
      <ul>
        <li>配列：<code>T[]</code></li>
        <li>リスト：<code>T()</code></li>
        <li>セット：<code>T{}</code></li>
        <li>マップ：<code>map&lt;T&gt;</code> / <code>map&lt;K/V&gt;</code></li>
        <li><code>struct</code>, <code>class</code>, <code>enum</code>, <code>bitfield enum</code></li>
        <li><code>task</code>, <code>pipe&lt;T&gt;</code></li>
      </ul>

      <h3>2.3 Value / reference types</h3>
      <ul>
        <li>値型：プリミティブ + struct + enum / bitfield enum。</li>
        <li>参照型：class, string, task, pipe など。</li>
      </ul>
      <h4>Struct restrictions</h4>
      <ul>
        <li>struct フィールドはプリミティブか他の struct のみ。</li>
        <li>class など参照型フィールドは禁止。</li>
        <li>struct 代入は値コピー。</li>
      </ul>
    </section>

    <!-- 3. Numbers & Conversions -->
    <section class="chapter" id="ch3">
      <hr />
      <h2>3. Numbers &amp; Conversions（数値と暗黙変換）</h2>

      <h3>3.1 int / float</h3>
      <ul>
        <li>式中で混在すると <code>float</code> に昇格。</li>
      </ul>

      <h3>3.2 decimal</h3>
      <ul>
        <li>高精度 10 進数。オーバーフローなどは <code>OverflowException</code>。</li>
      </ul>

      <h3>3.3 enum and int</h3>
      <ul>
        <li>キャスト構文なし。</li>
        <li>enum ⇔ int の暗黙／明示変換は禁止。</li>
      </ul>

      <h3>3.4 byte / char</h3>
      <ul>
        <li><code>byte</code>：0–255。<code>int</code> との混在は <code>int</code> 昇格。</li>
        <li><code>char</code>：算術不可。比較は char 同士のみ。</li>
      </ul>

      <h3>3.5 NaN / Infinity</h3>
      <ul>
        <li>NaN/Infinity ではなく例外で扱う。</li>
        <li><code>ZeroDivisionException</code> で 0 除算を表現。</li>
        <li><code>IsNaN</code>, <code>IsInfinity</code> のようなヘルパーは標準関数として想定するなら PascalCase で表現する。</li>
      </ul>
    </section>

    <!-- 4. Blocks & Scope + with -->
    <section class="chapter" id="ch4">
      <hr />
      <h2>4. Blocks &amp; Scope（ブロックとスコープ）</h2>

      <h3>4.1 静的スコープとシャドウイング</h3>
<pre><code>class Sample {
    field Value: int = 1;

    method Foo(): void {
        var Value = 2;        // フィールドをシャドウ
        Print(Value);         // 2
        Print(this.Value);    // 1
    }
}
</code></pre>
      <ul>
        <li>Aloe は静的（レキシカル）スコープ。</li>
        <li>内側ブロックで同名変数を宣言すると外側をシャドウ。</li>
        <li>フィールドとローカルが衝突した場合はローカル優先。フィールドは <code>this.</code> で参照。</li>
      </ul>

      <h3>4.2 with-blocks（メンバー省略記法）</h3>
      <p>オブジェクトのメンバーアクセスを簡潔に書くための構文。</p>
<pre><code>with (User) {
    Name = "Alice";
    Age  = Age + 1;
    Print(Name);
}
</code></pre>
      <ul>
        <li><code>with (Expr1)</code> または <code>with (Expr1), (Expr2), ...</code> の形。</li>
        <li>各 Expr はブロック先頭で 1 回だけ評価され、内部一時変数に束縛される。</li>
        <li>with ブロック内の「単純識別子」解決順：
          <ol>
            <li>そのブロック内のローカル変数 / 引数</li>
            <li>with 対象（左から右）のメンバー（フィールド / プロパティ / メソッド）</li>
            <li>外側スコープ（外側ブロック、クラスフィールドなど）</li>
          </ol>
        </li>
        <li>複数ターゲットが同名メンバーを持つと曖昧でコンパイルエラー。</li>
        <li>特別な一時変数 <code>_</code> は「最初の with 対象 (Expr1)」を指す：
          <ul>
            <li><code>Log(_)</code> のように渡せる。</li>
          </ul>
        </li>
      </ul>

      <h4>4.2.1 複数ターゲット with</h4>
<pre><code>with (User), (Profile) {
    Name = "Alice";          // User.Name または Profile.Name に解決
    UpdateProfile();         // User.UpdateProfile() か Profile.UpdateProfile()
}
</code></pre>
      <ul>
        <li>解決順は左から右。</li>
        <li>同名メンバーが複数ターゲットに存在するとコンパイルエラー。</li>
      </ul>

      <h4>4.2.2 ネストした with</h4>
<pre><code>with (User) {
    Name = "Alice";

    with (Address) {
        City = "Tokyo";   // Address.City
        Print(Name);      // User.Name かローカル Name に解決
    }
}
</code></pre>
      <ul>
        <li>内側 with は独立した名前解決規則を持つ。</li>
        <li>解決できない識別子は外側スコープへフォールバック。</li>
      </ul>

      <h4>4.2.3 Type-based with（class / struct / enum）</h4>
      <p>
        with の対象に「式」ではなく <strong>型名</strong> を指定すると、
        そのブロック内でその型の <strong>static メンバー / 列挙子</strong> に短縮アクセスできる。
      </p>
<pre><code>with (AngleUtil) {
    var Rad  = DegToRad(90.0);   // AngleUtil.DegToRad(90.0)
    var Rad2 = DegToRad(45.0);
    Print(Pi);                   // AngleUtil.Pi
}
</code></pre>
      <ul>
        <li>対象にできる型名：
          <ul>
            <li>class</li>
            <li>struct</li>
            <li>enum / bitfield enum</li>
          </ul>
        </li>
        <li>型ベース with 内での単純識別子解決順も通常と同様：
          <ol>
            <li>ローカル変数 / 引数</li>
            <li>対象型の static フィールド / static メソッド / 列挙子</li>
            <li>外側スコープ</li>
          </ol>
        </li>
        <li>インスタンスメンバーへのアクセスはコンパイルエラー。</li>
        <li>特別な <code>_</code> は「最初の型ターゲットの static コンテキスト」に対応する擬似オブジェクトとして扱える（<code>_.Member</code> と書いてもよいが、単に <code>Member</code> と等価）。</li>
      </ul>

      <h5>例：struct / class</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(Deg: float): float {
        return Deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(A: int, B: int): int {
        if (A > B) return A;
        return B;
    }
}

main(Args: string[]) {
    with (AngleUtil) {
        var Rad  = DegToRad(90.0);
        var Rad2 = DegToRad(45.0);
        Print(Pi);
    }

    with (MathUtil) {
        var M = Max(10, 20);
        Print(M);
    }
}
</code></pre>

      <h5>例：enum</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

main(Args: string[]) {
    with (Color) {
        var C1: Color = Red;   // Color.Red
        var C2: Color = Blue;  // Color.Blue
        Print(C1);
        Print(C2);
    }
}
</code></pre>

      <h5>値ターゲット + 型ターゲットの混在</h5>
<pre><code>with (User), (Color) {
    Name = "Alice";      // User.Name
    var C: Color = Red;  // Color.Red
}
</code></pre>
      <p class="note">
        値ターゲットと型ターゲットの両方をまとめて「メンバー候補集合」とみなし、
        同じ識別子に複数候補がある場合はコンパイルエラーとする。
      </p>
    </section>

    <!-- 5. Variables & Constants -->
    <section class="chapter" id="ch5">
      <hr />
      <h2>5. Variables &amp; Constants（変数と定数）</h2>

      <h3>5.1 var（型推論）</h3>
<pre><code>var I = 10;
var F = 10.5;
var S = "Hello";
var C = 'A';
var B = 255;
var Arr = [1, 2, 3];
var Lst = (1, 2, 3);
var St  = {1, 2, 3};
var Fb  = new FizzBuzz();
</code></pre>

      <h3>5.2 let（明示型）</h3>
<pre><code>let I: int = 10;
let F: float = 10.5;
let D: decimal = 10.12345678901234567890:d;
let S: string = "Hello, Aloe!";
let C: char = 'A';
let B: byte = 255;

let Arr: int[] = [1, 2, 3];
let Lst: int() = (1, 2, 3);
let St : int{} = {1, 2, 3};
let Mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

      <h3>5.3 const</h3>
<pre><code>const MaxCount: int = 100;
const PiConst : float = 3.14159;
const AppName : string = "Aloe VM";
</code></pre>
    </section>

    <!-- 6. Fields -->
    <section class="chapter" id="ch6">
      <hr />
      <h2>6. Fields（フィールド宣言）</h2>
<pre><code>class Sample {
    field Count: int = 0;
    field Name : string = "default";

    readonly field Id: int;

    construct(Id: int) {
        this.Id = Id; // OK
    }

    method Change(): void {
        this.Count = this.Count + 1;
        // this.Id = 2; // NG
    }
}
</code></pre>
    </section>

    <!-- 7. Class / Struct / Interface / Trait -->
    <section class="chapter" id="ch7">
      <hr />
      <h2>7. Class / Struct / Interface / Trait</h2>

      <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name : string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var I = 1;
        while (I &lt;= 100) {
            // ...
            I = I + 1;
        }
    }
}
</code></pre>

      <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(X: int, Y: int) {
        this.X = X;
        this.Y = Y;
    }
}
</code></pre>

      <h3>7.3 継承 / sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
}
</code></pre>

      <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(Msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(Msg: string): void {
        Print(Msg);
    }
}
</code></pre>

      <h3>7.5 trait</h3>
<pre><code>trait Trait_A {
    method Hello(): void {
        Print("Hello from Trait_A");
    }
}
</code></pre>

      <h4>with による適用</h4>
<pre><code>var Obj = new SomeClass() with Trait_A;
Obj.Hello();
</code></pre>

      <h4>非破壊 add/remove</h4>
<pre><code>var Obj2 = Obj + Trait_A;
var Obj3 = Obj2 - Trait_A;
</code></pre>

      <h4>エイリアス as</h4>
<pre><code>var Obj2 = Obj + Trait_A as A;
Obj2.A.Hello();
// Obj2.Hello(); // NG
</code></pre>
    </section>

    <!-- 8. delete & null -->
    <section class="chapter" id="ch8">
      <hr />
      <h2>8. delete と null</h2>
<pre><code>var Obj = new FizzBuzz();
delete Obj;   // VM レベルでは Obj = null 相当
</code></pre>
    </section>

    <!-- 9. is -->
    <section class="chapter" id="ch9">
      <hr />
      <h2>9. is Operator（型チェック）</h2>
<pre><code>if (Obj is FizzBuzz) {
}

if (Obj is ILogger) {
}

if (Obj is Trait_A) {
}
</code></pre>
    </section>

    <!-- 10. Collections -->
    <section class="chapter" id="ch10">
      <hr />
      <h2>10. Collections（配列 / リスト / セット / マップ）</h2>
<pre><code>var Arr: int[] = [1, 2, 3];
var Matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];

var Lst: int() = (1, 2, 3);
var ObjLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());

var St: int{} = {1, 2, 3};
var StructSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};

var Mp: map&lt;int&gt; = ["key1": 10, "key2": 20];
var Mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var ObjMp: map&lt;FizzBuzz&gt; = ["Obj1": new FizzBuzz(), "Obj2": new FizzBuzz()];
</code></pre>
    </section>

    <!-- 11. enum -->
    <section class="chapter" id="ch11">
      <hr />
      <h2>11. enum / bitfield enum</h2>

      <h3>11.1 enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>

      <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

      <h4>b(n) 記法</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // ここでは b(4) に割り当て
}
</code></pre>
    </section>

    <!-- 12. main -->
    <section class="chapter" id="ch12">
      <hr />
      <h2>12. main Block（エントリポイント）</h2>
<pre><code>main(Args: string[]) {
    var Fb = new FizzBuzz();
    Fb.Run();

    _ = 0;   // プロセス終了コード
}
</code></pre>
    </section>

    <!-- 13. temp variable _ -->
    <section class="chapter" id="ch13">
      <hr />
      <h2>13. Temp Variable <code>_</code></h2>
<pre><code>method Foo(): void {
    var X = 10;
    _ = X + 5;   // このブロック内の一時結果
}
</code></pre>
      <p class="note">
        main では <code>_</code> は int で固定（終了コード）。その他のブロックでは最初の代入で型が決まる。<br />
        with との関係については 4.2 を参照。
      </p>
    </section>

    <!-- 14. swap -->
    <section class="chapter" id="ch14">
      <hr />
      <h2>14. swap キーワード</h2>
<pre><code>var A = 10;
var B = 20;
swap (A, B);
</code></pre>
    </section>

    <!-- 15. Operators -->
    <section class="chapter" id="ch15">
      <hr />
      <h2>15. Operators（演算子）</h2>
      <p>優先順位や結合規則は原文どおり（ここでは割愛）。</p>
    </section>

    <!-- 16. Exceptions -->
    <section class="chapter" id="ch16">
      <hr />
      <h2>16. Exceptions（例外）</h2>
<pre><code>try {
    // ...
}
catch (E) {
}
finally {
}
</code></pre>
      <p>標準例外のツリーは原文に準拠（<code>NullReferenceException</code>, <code>OverflowException</code> など）。</p>
    </section>

    <!-- 17. Modules -->
    <section class="chapter" id="ch17">
      <hr />
      <h2>17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
    }
}
</code></pre>
    </section>

    <!-- 18. Pipes & Filters -->
    <section class="chapter" id="ch18">
      <hr />
      <h2>18. Pipes &amp; Filters（パイプとフィルタ）</h2>

      <h3>18.1 pipe&lt;T&gt;</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> は T のストリーム。</li>
        <li><code>stdin</code>, <code>stdout</code> などの組み込みパイプを想定。</li>
      </ul>

      <h3>18.2 filter 定義</h3>
<pre><code>filter LineSplit {
    in : pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(Input, Output) {
        foreach (Chunk in Input) {
            let Lines = Chunk.Split("\n");
            foreach (Line in Lines) {
                Output.Write(Line);
            }
        }
        Output.Close();
    }
}
</code></pre>

      <h3>18.3 パイプライン文</h3>
<pre><code>stdin
    | filter(Utf8)
    | filter(Json&lt;User&gt;)
    | Users;
</code></pre>

      <h3>18.4 foreach / EOF</h3>
<pre><code>foreach (Line in Lines) {
    Print(Line);
}
</code></pre>

      <p class="note">
        pipe / filter の詳細なランタイム挙動は AloeVM 側の仕様に委ねられる。
      </p>

      <hr />
      <p class="note">
        以上が、元英語版仕様をベースにした日本語版＋<code>with</code> 拡張＋PascalCase 整理済み HTML です。<br />
        これをそのままファイル保存して開けば、左メニュー→右コンテンツ切り替えが動くはずです。
      </p>
    </section>

  </main>
</div>

<script>
  (function() {
    var links = document.querySelectorAll('.nav-link');
    var chapters = document.querySelectorAll('.chapter');

    function showChapter(id) {
      chapters.forEach(function(ch) {
        ch.classList.toggle('active', ch.id === id);
      });
      links.forEach(function(a) {
        a.classList.toggle('active', a.getAttribute('data-target') === id);
      });
    }

    links.forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        var target = this.getAttribute('data-target');
        if (!target) return;
        showChapter(target);
        if (history.replaceState) {
          history.replaceState(null, '', '#' + target);
        }
      });
    });

    var hash = window.location.hash.replace('#', '');
    if (hash && document.getElementById(hash)) {
      showChapter(hash);
    }
  })();
</script>
</body>
</html>
