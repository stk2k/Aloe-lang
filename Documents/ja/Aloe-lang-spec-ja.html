
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Aloe 言語仕様書（ドラフト – パイプ／フィルタ／producer／consumer + delete/with/lock/クラス継承/ジェネリクス/event/async）</title>
  <meta name="last-updated" content="2025-11-30T12:00:00+09:00" />
  <style>
    /* レイアウトのみ最低限。フォントはブラウザ標準に任せる */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar p {
      margin: 0 0 0.75rem;
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      color: #d1d5db;
      text-decoration: none;
      padding: 0.2rem 0;
      white-space: nowrap;
    }
    .sidebar nav a:hover {
      color: #ffffff;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      box-sizing: border-box;
    }
    .content h1 {
      font-size: 1.6rem;
      margin-top: 0;
    }
    .content h2 {
      font-size: 1.3rem;
      margin-top: 2rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.25rem;
    }
    .content h3 {
      font-size: 1.1rem;
      margin-top: 1.4rem;
    }
    .content p {
      line-height: 1.6;
      margin: 0.4rem 0;
    }
    .content ul, .content ol {
      margin: 0.4rem 0 0.8rem 1.4rem;
    }
    code {
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 0.9rem;
      background: #f3f4f6;
      padding: 0.1rem 0.2rem;
      border-radius: 3px;
    }
    pre {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      padding: 0.75rem 0.9rem;
      overflow-x: auto;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0 1rem;
      width: 100%;
      max-width: 100%;
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 0.3rem 0.5rem;
      font-size: 0.9rem;
      text-align: left;
    }
    th {
      background: #f3f4f6;
    }
    .tag {
      display: inline-block;
      font-size: 0.75rem;
      background: #e5e7eb;
      color: #111827;
      padding: 0.05rem 0.4rem;
      border-radius: 999px;
      margin-right: 0.25rem;
    }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <h1>Aloe 言語仕様書</h1>
      <p>ドラフト版 / 設計検討用</p>
      <nav>
        <a href="#overview">1. 概要</a>
        <a href="#goals">2. 設計目標</a>
        <a href="#syntax">3. 基本文法</a>
        <a href="#types">4. 型システム</a>
        <a href="#pipe-filter">5. パイプ／フィルタ／producer／consumer</a>
        <a href="#collections">6. コレクションとパイプライン</a>
        <a href="#resource">7. リソース管理（with / delete / lock）</a>
        <a href="#classes">8. クラス／struct／継承</a>
        <a href="#generics">9. ジェネリクス</a>
        <a href="#enums">10. enum とビットフラグ</a>
        <a href="#events">11. event とデリゲート</a>
        <a href="#pattern-union">12. パターンマッチと union</a>
        <a href="#async">13. 非同期処理（async/await と Task）</a>
        <a href="#future">14. 今後の拡張</a>
      </nav>
    </aside>
    <main class="content">
      <header>
        <h1 id="overview">1. 概要</h1>
        <p>
          Aloe は、生成 AI と一緒に設計している、静的型付きで小さくシンプルな
          <span class="tag">パイプ指向</span>
          言語である。
        </p>
        <p>
          文字列・テキスト処理・REST 呼び出し・ストリーミングを、
          <code>pipe</code> と <code>filter</code> を使って書きやすくすることを第一の目的とする。
        </p>
        <ul>
          <li>静的型付き・コンパイル言語</li>
          <li>スタックベース VM と WebAssembly を意識したバイトコード（AloeBC）</li>
          <li>pipe / filter / producer / consumer を第一級機能としてサポート</li>
          <li><code>with</code> によるメモリ・リソースの安全なスコープ管理</li>
          <li>クラス継承・ジェネリクス・event・async/await をサポート</li>
        </ul>
      </header>

      <section id="goals">
        <h2>2. 設計目標</h2>
        <ul>
          <li><strong>小さく覚えやすい文法</strong>：構文ルールを少なくし、規則性を重視する。</li>
          <li><strong>テキストと I/O に強い</strong>：パイプラインでのデータ変換を標準機能化する。</li>
          <li><strong>言語仕様として明示</strong>：曖昧な挙動を避け、仕様書に書けるレベルで定義する。</li>
          <li><strong>Wasm と相性がよい</strong>：AloeVM を Wasm 上に載せやすくする設計。</li>
          <li><strong>GC 依存を減らす</strong>：<code>with</code> とリソース管理規約で安全性を担保する。</li>
        </ul>
      </section>

      <section id="syntax">
        <h2>3. 基本文法</h2>

        <h3>3.1 コメント</h3>
        <ul>
          <li><code>//</code> から行末までがコメント。</li>
          <li><code>/* ... */</code> のブロックコメントも将来的には追加予定。</li>
        </ul>

        <pre><code>// これは 1 行コメント
method PrintHello(): void {
  Print("Hello");
}</code></pre>

        <h3>3.2 キーワード</h3>
        <p>主要なキーワード（抜粋）：</p>
        <ul>
          <li><code>var</code> / <code>let</code>（変数・定数）</li>
          <li><code>method</code>（メソッド定義）</li>
          <li><code>struct</code> / <code>class</code> / <code>union</code></li>
          <li><code>enum</code></li>
          <li><code>with</code> / <code>delete</code> / <code>lock</code></li>
          <li><code>pipe</code> / <code>filter</code> / <code>producer</code> / <code>consumer</code></li>
          <li><code>event</code></li>
          <li><code>await</code></li>
        </ul>

        <h3>3.3 宣言の基本形</h3>

        <h4>変数・定数</h4>
        <pre><code>var Count: int = 0;       // 再代入可能
let Name: string = "Aloe"; // 再代入不可</code></pre>

        <h4>メソッド</h4>
        <p>
          メソッドは <code>method Name(引数): 戻り値型</code> で定義する。
        </p>
        <pre><code>method Add(Left: int, Right: int): int {
  return Left + Right;
}</code></pre>

        <h3>3.4 ブロックとスコープ</h3>
        <ul>
          <li><code>{ ... }</code> でブロックを作り、ローカルスコープを形成する。</li>
          <li><code>with</code> ブロックは別途「リソース管理」で定義する。</li>
        </ul>
      </section>

      <section id="types">
        <h2>4. 型システム</h2>

        <h3>4.1 プリミティブ型</h3>
        <p>
          Aloe のプリミティブ型は、すべて <strong>小文字キーワード</strong> で表記する。
        </p>
        <ul>
          <li><code>bool</code> / <code>boolean</code> – 真偽値。<code>boolean</code> は <code>bool</code> のエイリアス。</li>
          <li><code>int</code> / <code>integer</code> – 符号付き整数。<code>integer</code> は <code>int</code> のエイリアス。実装上のビット幅は VM 仕様で定義。</li>
          <li><code>float</code> – 浮動小数点数。</li>
          <li><code>decimal</code> – 高精度な 10 進小数。</li>
          <li><code>string</code> – 文字列（不変のテキスト）。</li>
          <li><code>null</code> – 値が存在しないことを表す特殊値／型。主に参照型やオプション型との組み合わせで用いる（詳細仕様は null 安全性の章で拡張予定）。</li>
          <li><code>void</code> – 戻り値なしを表す型。関数・メソッドの戻り値位置でのみ使用される。</li>
        </ul>
        <p>
          スタイルガイドとしては、短い形（<code>bool</code> / <code>int</code>）を推奨し、長い形（<code>boolean</code> / <code>integer</code>）は互換性・可読性のためのエイリアスとする。
        </p>

        <h3>4.2 配列・コレクション</h3>
        <p>代表的なコンテナ型：</p>
        <ul>
          <li><code>Array&lt;T&gt;</code></li>
          <li><code>List&lt;T&gt;</code></li>
        </ul>

        <h3>4.3 関数型</h3>
        <p>
          関数型はすべて <code>Func&lt;引数型列:戻り値型&gt;</code> で表現する。
        </p>

        <pre><code>var Callback: Func&lt;int:string&gt;;                   // int を受け取り string を返す
var AsyncCallback: Func&lt;string:Task&gt;;           // string を受け取り Task を返す
var AsyncWithResult: Func&lt;int:Task&lt;string&gt;&gt;; // int を受け取り Task&lt;string&gt; を返す</code></pre>

        <p>
          戻り値なしの関数は <code>Func&lt;Args:void&gt;</code>、または戻り値型の省略記法
          <code>Func&lt;Args:&gt;</code> を許可してよい。
        </p>

        <h3>4.4 null と Option</h3>
        <p>
          参照の有無を表すために、<code>Option&lt;T&gt;</code> を用意する案がある。詳細は未確定。
          <code>null</code> との関係や、どの型に <code>null</code> を代入可能とするかは、今後の null 安全設計で明示する。
        </p>
      </section>

      <section id="pipe-filter">
        <h2>5. パイプ／フィルタ／producer／consumer</h2>

        <h3>5.1 基本コンセプト</h3>
        <p>
          Aloe の中心となるのが、ストリーム指向の
          <code>pipe</code> と <code>filter</code> モデルである。
        </p>

        <ul>
          <li><span class="tag">producer</span>: データを生成する側</li>
          <li><span class="tag">consumer</span>: データを消費する側</li>
          <li><span class="tag">filter</span>: ストリーム中のデータを変換・フィルタする処理</li>
        </ul>

        <h3>5.2 パイプ演算子</h3>
        <p>
          パイプラインは <code>|</code> でつなぐ。
        </p>

        <pre><code>var Lines: Array&lt;string&gt; =
  File.ReadLines("users.txt")
    | filter Trim()
    | filter Where(Name =&gt; Name != "")
    | filter ToArray();</code></pre>

        <p>
          ここで <code>filter</code> は、ストリーム上で要素ごとに呼ばれる関数を登録する構文糖衣として定義する。
        </p>

        <h3>5.3 producer / consumer インターフェース</h3>
        <p>概念的には以下の二つのインターフェースが存在する：</p>

        <pre><code>struct Producer&lt;T&gt; {
  method Next(): Option&lt;T&gt;;
}

struct Consumer&lt;T&gt; {
  method Push(Item: T): void;
}</code></pre>

        <p>実際の VM 実装では、パイプラインを最適化した形で表現する。</p>
      </section>

      <section id="collections">
        <h2>6. コレクションとパイプライン</h2>

        <h3>6.1 コレクションパイプライン</h3>
        <p>
          コレクションもパイプライン構文と統一的に扱う。
        </p>

        <pre><code>var Numbers: Array&lt;int&gt; = [1, 2, 3, 4, 5];

var Result: Array&lt;int&gt; =
  Numbers
    | filter Where(X =&gt; X % 2 == 0)
    | filter Select(X =&gt; X * 10)
    | filter ToArray();</code></pre>

        <h3>6.2 Lazy / Eager</h3>
        <ul>
          <li>基本は遅延評価のストリーム。</li>
          <li><code>ToArray</code> や <code>ToList</code> などを呼んだ時点で実データが確定する。</li>
        </ul>
      </section>

      <section id="resource">
        <h2>7. リソース管理（with / delete / lock）</h2>

        <h3>7.1 with ブロック</h3>
        <p>
          <code>with</code> は、「そのスコープ内でオブジェクトが安全に使われ、スコープ終端で必ずクリーンアップされる」ことを保証する。
        </p>

        <pre><code>method UseFile(Path: string): void {
  with File.Open(Path) as F {
    F.WriteLine("Hello");
  }
}</code></pre>

        <p>
          <code>with</code> の対象型は、「スコープ終端時に呼ばれる <code>Dispose</code> または同等のメソッド」を実装している必要がある。
        </p>

        <h3>7.2 delete</h3>
        <p>
          <code>delete</code> は、明示的にオブジェクトを破棄したいときに使うキーワードとして予約しておく。
        </p>

        <pre><code>var Buffer: ByteBuffer = ByteBuffer.Create(1024);
// 何か利用する
delete Buffer; // 以降の使用はコンパイルエラーまたは未定義とする</code></pre>

        <h3>7.3 lock</h3>
        <p>
          <code>lock</code> は排他制御のための構文として予約する。
        </p>

        <pre><code>lock Mutex {
  SharedState.Value = SharedState.Value + 1;
}</code></pre>
      </section>

      <section id="classes">
        <h2>8. クラス／struct／継承</h2>

        <h3>8.1 struct と class</h3>
        <ul>
          <li><code>struct</code> は値型（コピーセマンティクス）。</li>
          <li><code>class</code> は参照型（参照セマンティクス）。</li>
        </ul>

        <pre><code>struct Point {
  var X: int;
  var Y: int;
}

class User {
  var Id: int;
  var Name: string;
}</code></pre>

        <h3>8.2 クラス継承</h3>
        <p>
          クラスは単一継承を行う。構文は <code>class Sub : Base</code>。
        </p>

        <pre><code>class Animal {
  method Speak(): void { }
}

class Dog : Animal {
  override method Speak(): void {
    Print("Bow");
  }
}</code></pre>

        <h3>8.3 メンバ名のスタイル</h3>
        <ul>
          <li>プロパティ名、メソッド名は <strong>パスカルケース</strong>（先頭大文字）とする。</li>
          <li>ローカル変数・引数はキャメルケースを推奨するが、仕様としては強制しない。</li>
        </ul>
      </section>

      <section id="generics">
        <h2>9. ジェネリクス</h2>

        <h3>9.1 基本</h3>
        <pre><code>struct Result&lt;T&gt; {
  var Value: T;
  var IsOk: bool;
}</code></pre>

        <h3>9.2 ジェネリックメソッド</h3>
        <pre><code>method FirstOrDefault&lt;T&gt;(Items: Array&lt;T&gt;): Option&lt;T&gt; {
  if (Items.Length == 0) {
    return None;
  }
  return Some(Items[0]);
}</code></pre>
      </section>

      <section id="enums">
        <h2>10. enum とビットフラグ</h2>

        <h3>10.1 enum の基本</h3>
        <p>
          enum の内部表現は <strong>int 固定</strong> とし、他の基になる整数型を指定することはできない。
        </p>

        <pre><code>enum Color {
  Red = 0;
  Green = 1;
  Blue = 2;
}</code></pre>

        <h3>10.2 ビットフラグ enum</h3>
        <p>
          ビットフラグ用途の enum は「最大 32 個まで」という制限を設ける。
        </p>

        <pre><code>enum FileAccess {
  Read  = 0x1;
  Write = 0x2;
  Exec  = 0x4;
}</code></pre>
      </section>

      <section id="events">
        <h2>11. event とデリゲート</h2>

        <h3>11.1 デリゲート型</h3>
        <p>
          Aloe では専用の <code>delegate</code> 構文を持たず、すべて <code>Func&lt;...:...&gt;</code> で表現する。
        </p>

        <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>

        <p>
          この定義により、「イベントハンドラはすべて非同期であり <code>Task</code> を返す」という世界観で統一される。
        </p>

        <h3>11.2 event 宣言</h3>
        <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>

        <p>
          <code>event Name&lt;TArgs&gt;</code> は、内部的には <code>EventHandler&lt;TArgs&gt;</code> を複数保持するコレクションとして実装される。
        </p>

        <h3>11.3 購読と解除</h3>
        <pre><code>method Setup(ButtonInstance: Button): Task {
  ButtonInstance.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  // 解除構文の詳細は未確定（-= を想定）
}</code></pre>

        <h3>11.4 Raise の挙動</h3>
        <p>
          <code>event</code> は <code>Raise</code> メソッドを通じて発火する。<br />
          <code>Raise</code> 自体も <code>Task</code> を返し、内部で登録されたハンドラの <code>Task</code> を順に <code>await</code> する。
        </p>

        <pre><code>bound Button {
  method OnNativeClick(Id: string): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>
      </section>

      <section id="pattern-union">
        <h2>12. パターンマッチと union</h2>

        <h3>12.1 union 型</h3>
        <p>
          union は「排他的なバリアント型」を表す。
        </p>

        <pre><code>union Response {
  Ok(Value: string);
  NotFound();
  Error(Message: string);
}</code></pre>

        <h3>12.2 match 式（案）</h3>
        <p>
          union に対するパターンマッチは、<code>match</code> 式で記述する。
        </p>

        <pre><code>method Handle(ResponseValue: Response): void {
  match (ResponseValue) {
    Ok(Value) {
      Print("OK: " + Value);
    }
    NotFound() {
      Print("Not found");
    }
    Error(Message) {
      Print("Error: " + Message);
    }
  }
}</code></pre>

        <p>
          網羅性チェック（全バリアントをカバーしているか）はコンパイル時に行う方針とする。
        </p>
      </section>

      <section id="async">
        <h2>13. 非同期処理（async/await と Task）</h2>

        <h3>13.1 基本方針</h3>
        <ul>
          <li>非同期処理は <code>Task</code> と <code>Task&lt;T&gt;</code> の 2 種類で表現する。</li>
          <li>専用の <code>async</code> キーワードをメソッド宣言には使わない。</li>
          <li><code>await</code> は式として定義し、<code>Task</code> 系の値の完了を待つ。</li>
        </ul>

        <pre><code>method DelayMs(Millis: int): Task {
  // 実装はランタイム側
}

method FetchUser(Name: string): Task&lt;User&gt; {
  // ユーザを非同期に取得する
}</code></pre>

        <h3>13.2 Task と Task&lt;T&gt;</h3>
        <ul>
          <li><code>Task</code> は「戻り値なしの非同期処理」を表す。</li>
          <li><code>Task&lt;T&gt;</code> は「型 <code>T</code> の値を返す非同期処理」を表す。</li>
        </ul>

        <h3>13.3 await 式の型ルール</h3>
        <p>
          <code>await Expr</code> は、<code>Expr</code> の型によって結果の型が決まる。
        </p>

        <table>
          <thead>
            <tr>
              <th>Expr の型</th>
              <th>await Expr の型</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Task&lt;T&gt;</code></td>
              <td><code>T</code></td>
            </tr>
            <tr>
              <td><code>Task</code></td>
              <td>値なし（式の結果は使用不可）</td>
            </tr>
          </tbody>
        </table>

        <pre><code>var UserTask: Task&lt;User&gt; = FetchUser("Foo");
var U: User = await UserTask;  // await Task&lt;User&gt; の結果は User

await DelayMs(1000);           // Task の場合は値なしとして扱う</code></pre>

        <p>
          <code>Task</code> に対する <code>await</code> を変数に代入しようとした場合はコンパイルエラーとする。
        </p>

        <h3>13.4 await を使える場所</h3>
        <p>
          <code>await</code> は、次のいずれかに該当するコンテキストの中でのみ使用できる。
        </p>
        <ul>
          <li>戻り値型が <code>Task</code> のメソッド</li>
          <li>戻り値型が <code>Task&lt;T&gt;</code> のメソッド</li>
          <li>型が <code>Func&lt;...:Task&gt;</code> のラムダ式</li>
          <li>型が <code>Func&lt;...:Task&lt;T&gt;&gt;</code> のラムダ式</li>
        </ul>

        <pre><code>method Foo(): Task {
  await DelayMs(1000);            // OK
}

method Bar(): Task&lt;int&gt; {
  let U: User = await FetchUser("Foo"); // OK
  return U.Id;
}

method Ng(): int {
  await DelayMs(1000);            // コンパイルエラー
  return 1;
}</code></pre>

        <h3>13.5 ラムダと await</h3>
        <p>
          ラムダ式に関しては、<code>Func&lt;Args:Task&gt;</code> や <code>Func&lt;Args:Task&lt;T&gt;&gt;</code> を返す場合に <code>await</code> を中で使える。
        </p>

        <pre><code>let Handler: Func&lt;ClickedArgs:Task&gt; =
  async (Args: ClickedArgs): Task {
    await DelayMs(500);
    Print("Clicked");
  };</code></pre>

        <p>
          ここで <code>async</code> は構文糖衣としてのキーワード候補であり、
          「このラムダは <code>Task</code> または <code>Task&lt;T&gt;</code> を返す」ことを示す。
          メソッド定義に <code>async</code> を付ける必要はない。
        </p>

        <h3>13.6 例外処理との関係</h3>
        <p>
          <code>await Expr</code> の評価中に、対応する <code>Task</code> 側で例外が発生していた場合、
          その例外は <code>await</code> の位置で再スローされる。
        </p>

        <pre><code>method UseAsync(): Task {
  try {
    let U: User = await FetchUser("Foo");
    Print(U.Name);
  } catch (Ex: Error) {
    LogError(Ex);
  }
}</code></pre>

        <h3>13.7 event モデルとの統合</h3>
        <p>
          前述のとおり、イベントハンドラ型は <code>EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;</code> で定義されている。
          そのため、イベントハンドラ内では自然に <code>await</code> を使うことができる。
        </p>

        <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: string): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}

method SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  Btn.Clicked += async (Args: ClickedArgs): Task {
    await DelayMs(100);
    Print("Clicked: " + Args.ButtonId);
  };
}</code></pre>

        <p>
          <code>Clicked.Raise(Args)</code> は <code>Task</code> を返し、内部で登録済みハンドラの <code>Task</code> を順に <code>await</code> する。
          これにより、「イベントを発火した側が、ハンドラの完了を待つ」スタイルを自然に書ける。
        </p>
      </section>

      <section id="future">
        <h2>14. 今後の拡張</h2>
        <ul>
          <li>Option 型と null 安全性の詳細設計</li>
          <li>エラー型と例外、どこまでを例外、どこからを戻り値とするかの整理</li>
          <li>pipe/filter の VM レベル最適化と Wasm 対応</li>
          <li>AloeBC（バイトコード形式）仕様との突き合わせ</li>
          <li>分散実行・リモート pipe（別プロセスや別ノードへのストリーム接続）</li>
        </ul>
      </section>
    </main>
  </div>
</body>
</html>
