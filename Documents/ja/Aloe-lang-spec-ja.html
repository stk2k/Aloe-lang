
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Aloe 言語仕様書（ドラフト、日本語版）</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      background: #f5f5f7;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.5rem 1.25rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.4rem;
    }
    .sidebar .subtitle {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 1.4rem;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      margin: 1.2rem 0 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
    }
    .sidebar nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 0.9rem;
    }
    .sidebar nav li {
      margin: 0.15rem 0;
    }
    .sidebar a {
      color: inherit;
      text-decoration: none;
      display: block;
      padding: 0.25rem 0.4rem;
      border-radius: 0.35rem;
    }
    .sidebar a:hover {
      background: #1f2937;
    }
    .sidebar .chapter-index {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-right: 0.35rem;
    }

    .content {
      flex: 1;
      max-width: 1100px;
      padding: 2rem 3rem;
      box-sizing: border-box;
      margin: 0 auto;
      background: #f9fafb;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
      color: #111827;
    }
    h1 {
      margin-top: 0;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas,
                   "Ricty Diminished", monospace;
      font-size: 0.9rem;
    }
    pre {
      background: #1118270d;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      border: 1px solid #e5e7eb;
    }
    ul, ol {
      padding-left: 1.4em;
    }
    hr {
      margin: 2.2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      font-size: 0.9rem;
      color: #4b5563;
    }
  </style>
</head>
<body>
<div class="layout">

  <!-- 左側メニュー -->
  <aside class="sidebar">
    <h1>Aloe Language Spec</h1>
    <div class="subtitle">Draft • Japanese translation + with 拡張</div>

    <h2>Chapters</h2>
    <nav>
      <ul>
        <li><a href="#ch0"><span class="chapter-index">0.</span>概要 (Overview)</a></li>
        <li><a href="#ch1"><span class="chapter-index">1.</span>基本文法 (Basic Syntax)</a></li>
        <li><a href="#ch2"><span class="chapter-index">2.</span>型システム (Type System)</a></li>
        <li><a href="#ch3"><span class="chapter-index">3.</span>数値と変換 (Numbers &amp; Conversions)</a></li>
        <li><a href="#ch4"><span class="chapter-index">4.</span>ブロックとスコープ (Blocks &amp; Scope)</a></li>
        <li><a href="#ch5"><span class="chapter-index">5.</span>変数と定数 (Variables &amp; Constants)</a></li>
        <li><a href="#ch6"><span class="chapter-index">6.</span>フィールド (Fields)</a></li>
        <li><a href="#ch7"><span class="chapter-index">7.</span>Class / Struct / Interface / Trait</a></li>
        <li><a href="#ch8"><span class="chapter-index">8.</span>delete &amp; null</a></li>
        <li><a href="#ch9"><span class="chapter-index">9.</span>is 演算子 (is Operator)</a></li>
        <li><a href="#ch10"><span class="chapter-index">10.</span>コレクション (Collections)</a></li>
        <li><a href="#ch11"><span class="chapter-index">11.</span>enum / bitfield enum</a></li>
        <li><a href="#ch12"><span class="chapter-index">12.</span>main ブロック (main Block)</a></li>
        <li><a href="#ch13"><span class="chapter-index">13.</span>一時変数 <code>_</code> (Temp Variable)</a></li>
        <li><a href="#ch14"><span class="chapter-index">14.</span>swap キーワード</a></li>
        <li><a href="#ch15"><span class="chapter-index">15.</span>演算子 (Operators)</a></li>
        <li><a href="#ch16"><span class="chapter-index">16.</span>例外 (Exceptions)</a></li>
        <li><a href="#ch17"><span class="chapter-index">17.</span>Modules / namespace / import</a></li>
        <li><a href="#ch18"><span class="chapter-index">18.</span>Pipes &amp; Filters</a></li>
      </ul>
    </nav>

    <h2>Key Section</h2>
    <nav>
      <ul>
        <li><a href="#with-blocks">4.2 with ブロック</a></li>
        <li><a href="#with-type">4.2.1 型名対象 with 拡張</a></li>
      </ul>
    </nav>
  </aside>

  <!-- 本文 -->
  <main class="content">
    <h1 id="top">Aloe 言語仕様書（ドラフト、日本語版）</h1>
    <p class="note">
      この文書は、英語版仕様
      <code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>
      をベースにした日本語ドラフトです。<br>
      その上で <strong>4.2 with-blocks</strong> に
      <strong>class / struct / enum を対象にした型ベース with（static メンバー／列挙子への短縮アクセス）</strong>
      の拡張を追加しています。<br>
      それ以外の仕様は原文にできるだけ忠実に訳しています。
    </p>

    <hr>

    <h2 id="ch0">0. Overview（概要）</h2>
    <p>
      Aloe は静的型付けのスクリプト言語であり、シンプルで直感的な構文を目指している。<br>
      スタックベースの仮想マシン（AloeVM）上で動作し、主に次のような目標を持つ。
    </p>
    <ul>
      <li>教育用途や小規模アプリケーションで読み書きしやすいこと</li>
      <li>C# ランタイムおよび WebAssembly (WASM) 環境で動作すること</li>
      <li><code>pipe</code> と <code>filter</code> によって、I/O と並行処理を静的型付けのまま制御できること</li>
    </ul>
    <p>特徴：</p>
    <ul>
      <li>静的型付け
        <ul>
          <li><code>var</code> による型推論</li>
          <li><code>let</code> による明示的な型指定</li>
        </ul>
      </li>
      <li>値型 / 参照型
        <ul>
          <li><code>struct</code> … 値型</li>
          <li><code>class</code> … 参照型</li>
        </ul>
      </li>
      <li>GC ベースのメモリ管理（具体的なアルゴリズムは VM 実装依存）</li>
      <li><code>= null</code> をソースコード中に直接書かない
        <ul>
          <li>参照型は内部的には null を取り得るが、<code>delete</code> による糖衣構文で扱う。</li>
        </ul>
      </li>
      <li><code>pipe</code> / <code>filter</code> によるデータフロースタイルの設計</li>
    </ul>

    <hr>

    <h2 id="ch1">1. Basic Syntax（基本文法）</h2>

    <h3>1.1 Comments（コメント）</h3>
<pre><code>// single-line comment

/* multi-line
   comment */
</code></pre>
    <ul>
      <li><code>//</code> から行末までが行コメント。</li>
      <li><code>/*</code> ～ <code>*/</code> が複数行コメント。</li>
      <li>ネストした <code>/* */</code> は未定義（サポートしない想定）。</li>
    </ul>

    <h3>1.2 Identifiers（識別子）</h3>
    <ul>
      <li>使用可能文字：英字 (A–Z, a–z)、数字 (0–9)、アンダースコア <code>_</code></li>
      <li>先頭文字は英字または <code>_</code> でなければならない。</li>
      <li>大文字小文字は区別される。</li>
      <li>キーワードと同じ綴りは使用できない。</li>
      <li><code>_</code> で始まる識別子は「プライベート」扱い（外部からは参照しない慣習）。</li>
      <li>ユニコード文字も使用できる（空白や区切り記号などは除外）。</li>
    </ul>

    <h3>1.3 Keywords（キーワード）</h3>
<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>
    <ul>
      <li><code>package</code> は使わず、<code>namespace</code> を使用する。</li>
      <li><code>final</code> は廃止され、拡張禁止には <code>sealed</code> を用いる。</li>
      <li><code>instanceof</code> は廃止され、型チェックには <code>is</code> を用いる。</li>
    </ul>

    <h3>1.4 Literals（リテラル）</h3>
    <ul>
      <li>整数リテラル：<code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code> など</li>
      <li>浮動小数点リテラル：<code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
      <li>10進リテラル：<code>10.12345678901234567890:d</code> など</li>
      <li>真偽値：<code>true</code>, <code>false</code></li>
      <li>文字列：<code>"Hello, World!"</code></li>
      <li>文字：<code>'A'</code>, <code>'z'</code> など</li>
      <li>null リテラル：<code>null</code></li>
      <li>配列リテラル：<code>[1, 2, 3]</code></li>
      <li>リストリテラル：<code>(1, 2, 3)</code></li>
      <li>セットリテラル：<code>{1, 2, 3}</code></li>
      <li>マップリテラル：<code>["key1": 10, "key2": 20]</code></li>
      <li>enum リテラル：<code>EnumType.Value1</code></li>
      <li>struct リテラル：<code>Point { x: 0, y: 1 }</code></li>
      <li>オブジェクト生成：<code>new ClassName()</code></li>
    </ul>

    <h3>1.5 Statement terminator（文の終端）</h3>
<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>
    <ul>
      <li>すべての文はセミコロン <code>;</code> で終わる。</li>
      <li>改行による自動セミコロン挿入は行わない。</li>
    </ul>

    <h3>1.6 Whitespace（空白）</h3>
    <ul>
      <li>スペース、タブ、改行はトークン区切りとして扱われる。</li>
      <li>連続する空白は 1 つの区切りとみなされる。</li>
      <li>インデントに意味はない（Python とは異なる）。</li>
    </ul>

    <h3>1.7 Case sensitivity（大文字小文字）</h3>
    <ul>
      <li>識別子とキーワードは大文字小文字を区別する。</li>
      <li>キーワードはすべて小文字。</li>
    </ul>

    <hr>

    <h2 id="ch2">2. Type System（型システム）</h2>

    <h3>2.1 Primitive types（プリミティブ型）</h3>
    <p>
      Aloe における「プリミティブ型」は、次の 7 種類とする。
    </p>
    <ul>
      <li><code>bool</code> / <code>boolean</code> – 真偽値。</li>
      <li><code>int</code> / <code>integer</code> – 符号付き整数。</li>
      <li><code>float</code> – 浮動小数点数。</li>
      <li><code>decimal</code> – 高精度 10 進数。</li>
      <li><code>string</code> – 文字列（内部的には Unicode）。</li>
      <li><code>null</code> – 「値が存在しない」ことを表す特別な型兼値。</li>
      <li><code>void</code> – 戻り値なし（メソッド戻り値専用）。</li>
    </ul>
    <p>
      <code>any</code> 型は存在せず、動的型付けはサポートしない。<br>
      <code>char</code> や <code>byte</code> は言語としてはサポートされるが、プリミティブ型のカテゴリからは外し、
      数値と変換の章（3 章）で別途扱う値型とする。
    </p>

    <h3>2.2 Composite / user-defined types（合成型 / ユーザー定義型）</h3>
    <ul>
      <li>配列：<code>T[]</code></li>
      <li>リスト：<code>T()</code></li>
      <li>セット：<code>T{}</code></li>
      <li>マップ：<code>map&lt;T&gt;</code> または <code>map&lt;K/V&gt;</code></li>
      <li><code>struct</code></li>
      <li><code>class</code></li>
      <li><code>enum</code>, <code>bitfield enum</code></li>
      <li>非同期タスク：<code>task</code></li>
      <li>パイプ：<code>pipe&lt;T&gt;</code>（18章参照）</li>
    </ul>
    <p><code>any</code> 型は存在せず、動的型付けはサポートしない。</p>

    <h3>2.3 Value types / reference types（値型 / 参照型）</h3>
    <ul>
      <li>値型：
        <ul>
          <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
          <li><code>struct</code></li>
          <li><code>enum</code>, <code>bitfield enum</code>（内部表現は int32）</li>
        </ul>
      </li>
      <li>参照型：
        <ul>
          <li><code>class</code></li>
          <li><code>string</code>（実装上は参照型）</li>
          <li><code>task</code>, <code>pipe&lt;T&gt;</code> など</li>
        </ul>
      </li>
    </ul>

    <h4>Struct restrictions and copying（struct の制約とコピー）</h4>
    <ul>
      <li>struct のフィールドにはプリミティブ型と他の struct のみを持てる。</li>
      <li>class などの参照型フィールドは持てない。</li>
      <li>struct の代入は常に値コピー。</li>
      <li>最大サイズなどは仕様で制限しない。</li>
    </ul>

    <h4>Class vs struct（class と struct）</h4>
    <ul>
      <li>class は struct をフィールドとして持てる。</li>
      <li>class インスタンスを別変数に代入すると参照がコピーされる（オブジェクト本体は共有）。</li>
    </ul>

    <h3>2.4 Result&lt;T&gt; 型</h3>
    <p>
      <code>Result&lt;T&gt;</code> は、Railway Oriented Programming（ROP）の考え方に基づき、
      「成功」または「失敗」の いずれかの状態を表現するための汎用コンテナ型である。
      主にパイプライン処理やフィルタ内で使用される。
    </p>
<pre><code>// 概念的な定義（実際の実装はランタイム依存）

struct ErrorInfo {
    field Message: string;
    field Code   : string;   // 任意（エラーコードなど）
}

struct Result&lt;T&gt; {
    field IsOk : bool;
    field Value: T;         // IsOk が true のときのみ有効
    field Error: ErrorInfo; // IsOk が false のときのみ有効
}
</code></pre>
    <ul>
      <li><code>IsOk</code> が <code>true</code> のとき「成功（Ok）」、<code>false</code> のとき「失敗（Error）」を表す。</li>
      <li>慣習として、ヘルパー関数
        <code>ok(value: T): Result&lt;T&gt;</code> /
        <code>error(msg: string, code: string): Result&lt;T&gt;</code>
        を用いて <code>Result&lt;T&gt;</code> 値を生成する。</li>
      <li><code>Result&lt;void&gt;</code> は「値を返さない処理の成功 / 失敗」を表す特別な用途として許可される。</li>
      <li>パイプラインでは <code>pipe&lt;Result&lt;T&gt;&gt;</code> の形で「成功レール」と「エラーレール」を同時に流す前提で使用する。</li>
    </ul>

    <hr>

    <h2 id="ch3">3. Numbers &amp; Conversions（数値と暗黙変換）</h2>

    <h3>3.1 int and float</h3>
    <ul>
      <li><code>int</code> と <code>float</code> を混在させた式の結果は <code>float</code> になる。
        <ul>
          <li><code>int + float → float</code></li>
          <li><code>int - float → float</code></li>
          <li><code>int * float → float</code></li>
          <li><code>int / float → float</code></li>
        </ul>
      </li>
    </ul>

    <h3>3.2 decimal</h3>
    <ul>
      <li><code>decimal</code> は高精度な 10 進数。</li>
      <li><code>int</code> / <code>float</code> と混在する式は、必要に応じて <code>decimal</code> に昇格しうる。</li>
      <li>オーバーフロー / アンダーフロー / 精度問題は <code>OverflowException</code> として扱う。</li>
    </ul>

    <h3>3.3 enum and int</h3>
    <ul>
      <li>Aloe にはキャスト構文がない。</li>
      <li>enum と int の暗黙 / 明示変換はいずれも禁止。</li>
      <li>enum と数値型の混在式はコンパイルエラー（bitfield enum のビット演算を除く）。</li>
      <li>内部表現としては enum / bitfield enum はすべて int32。</li>
    </ul>

    <h3>3.4 byte and char</h3>
    <ul>
      <li><code>byte</code>：
        <ul>
          <li>範囲は 0–255。</li>
          <li>byte 同士の演算は許されるが、範囲外はエラーになり得る。</li>
          <li>byte と int の混在式は int に昇格。</li>
        </ul>
      </li>
      <li><code>char</code>：
        <ul>
          <li>char の算術演算は不可。</li>
          <li>比較演算（<code>==</code>, <code>&lt;</code>, <code>&gt;</code> 等）は char 同士のみ。</li>
          <li>数値型との暗黙変換はない。</li>
        </ul>
      </li>
    </ul>

    <h3>3.5 NaN / Infinity</h3>
    <ul>
      <li>数値オーバーフロー/アンダーフローは NaN/Infinity ではなく例外で扱う。</li>
      <li><code>ZeroDivisionException</code> は 0 / 0.0 で常に投げる。</li>
    </ul>

    <hr>

    <h2 id="ch4">4. Blocks &amp; Scope（ブロックとスコープ）</h2>

    <p>
      ブロックは <code>{</code> と <code>}</code> で区切られ、各ブロックが新しいスコープを導入する。
    </p>
    <ul>
      <li><code>main</code> ブロック（エントリポイント関数）</li>
      <li>クラス定義ブロック</li>
      <li>メソッド定義ブロック</li>
      <li>任意の <code>{ ... }</code> ブロック</li>
    </ul>

    <h3>4.1 Static (lexical) scope and shadowing（静的スコープとシャドウイング）</h3>
<pre><code>class Sample {
    field Value: int = 1;
    method Foo(): void {
        var Value = 2;        // shadows the field
        print(Value);         // 2
        print(this.Value);    // 1
    }
}
</code></pre>
    <ul>
      <li>Aloe は静的（レキシカル）スコープ。</li>
      <li>内側ブロックで同名変数を宣言すると、外側の変数をシャドウする。</li>
      <li>フィールド名とローカル変数名がぶつかった場合、ローカル変数が優先される。
        フィールドは <code>this.</code> で参照する。</li>
    </ul>

    <h3 id="with-blocks">4.2 with-blocks（メンバー省略記法）</h3>
    <p>
      Aloe には、同一オブジェクトのメンバーアクセスを簡潔に書くための
      <code>with</code> ブロックがある。
    </p>
<pre><code>with (user) {
    .Name = "Alice";
    .Age  = .Age + 1;
    print(.Name);
}
</code></pre>
    <ul>
      <li><code>with (expr) { ... }</code> ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>(expr).Member</code> の省略形。</li>
          <li><code>expr</code> はブロックの先頭で 1 度だけ評価され、内部一時変数に保持される。</li>
          <li>特別な一時変数 <code>_</code> は「with 対象オブジェクト」を指す。
            <ul>
              <li><code>log(_);</code> のように渡すことができる。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>ネストした <code>with</code> ブロック：
        <ul>
          <li>内側の <code>with</code> が <code>.</code> の解決および <code>_</code> をシャドウする。</li>
          <li>外側オブジェクトへは通常の変数名でアクセスできる。</li>
        </ul>
      </li>
      <li>C# の <code>using</code> スタイルのように、同じブロックに複数の <code>with</code> を並べられる：</li>
    </ul>
<pre><code>with (user), (profile) {
    .Name = "Alice";  // resolved against both user and profile
}
</code></pre>
    <ul>
      <li>どのオブジェクトのメンバーに解決されるかの順序は実装依存。</li>
      <li>ただし曖昧な場合（複数オブジェクトが同じメンバーを持つ）はコンパイルエラー。</li>
    </ul>
    <p>
      <code>with</code> はあくまで構文糖衣であり、意味的にはすべて
      明示的な <code>obj.Member</code> 呼び出しに書き換えた上で
      型チェック・コード生成を行うことができる。
    </p>

    <h4 id="with-type">4.2.1 Type-based with（class / struct / enum の static / 列挙子ショートカット）</h4>
    <p>
      通常の <code>with (expr)</code> に加えて、<strong>型名</strong> を対象にした
      <code>with</code> を利用できる。
    </p>
<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>
    <p>ここで <code>TypeName</code> は次のいずれか：</p>
    <ul>
      <li><code>class</code> 型</li>
      <li><code>struct</code> 型</li>
      <li><code>enum</code> / <code>bitfield enum</code></li>
    </ul>
    <p>この場合、<code>with</code> は「型コンテキスト with」として解釈される：</p>
    <ul>
      <li><code>()</code> 内の式は実行時に値として評価されない。
        <ul>
          <li>コンパイラは <code>TypeName</code> を型として解決し、インスタンス生成などは行わない。</li>
        </ul>
      </li>
      <li>ブロック内では：
        <ul>
          <li><code>.Member</code> は <code>TypeName.Member</code> の省略形。
            <ul>
              <li>対象となる <code>Member</code> は
                <ul>
                  <li>static フィールド</li>
                  <li>static メソッド</li>
                  <li>enum / bitfield enum の列挙子</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>一時変数 <code>_</code> は、<code>TypeName</code> の static コンテキストを表す擬似オブジェクトとして振る舞う。
            <ul>
              <li><code>_.Member</code> も <code>TypeName.Member</code> と等価。</li>
            </ul>
          </li>
          <li>型ベース with 内でインスタンスメンバーにアクセスすることはコンパイルエラー。</li>
        </ul>
      </li>
    </ul>
    <p>
      なお、型ベース with でもローカル変数や外側スコープの変数が同名で存在すればそちらが優先される。
      列挙子や static メンバーを明示したいときは <code>TypeName.Member</code> または <code>.Member</code> / <code>_.Member</code> を用いる。
    </p>

    <h5>例：class / struct の static アクセス</h5>
<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method DegToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method Max(a: int, b: int): int {
        if (a &gt; b) return a;
        return b;
    }
}

function main(args: string[]): int {
    with (AngleUtil) {
        var rad = DegToRad(90.0);  // AngleUtil.DegToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = Max(10, 20);       // MathUtil.Max(10, 20)
        print(m);
    }

    return 0;
}
</code></pre>

    <h5>例：enum の列挙子アクセス</h5>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}

function main(args: string[]): int {
    with (Color) {
        var c1: Color = Red;   // Color.Red
        var c2: Color = Blue;  // Color.Blue
        print(c1);
        print(c2);
    }
    return 0;
}
</code></pre>
    <p>
      型ベース <code>with</code> も複数ターゲット構文に混在させられる：
    </p>
<pre><code>with (user), (Color) {
    .Name = "Alice"; // user.Name
    var c: Color = Red; // Color.Red
}
</code></pre>
    <p>
      この場合も解決順は実装依存だが、曖昧であればコンパイルエラーとする。
    </p>

    <hr>

    <h2 id="ch5">5. Variables &amp; Constants（変数と定数）</h2>

    <h3>5.1 var（型推論）</h3>
<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>
    <ul>
      <li>変数の型は右辺の式から推論される。</li>
      <li><code>var x = 1;</code> は常に <code>int</code>。</li>
      <li><code>var x = 1.0;</code> は <code>float</code> として扱われる。</li>
      <li><code>var x = null;</code> はコンパイルエラー（型が推論できない）。</li>
    </ul>

    <h3>5.2 let（明示的な型）</h3>
<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

    <h3>5.3 Constants（const）</h3>
<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>
    <ul>
      <li><code>const</code> 変数は再代入不可。</li>
      <li>const には型注釈が必須。</li>
    </ul>

    <hr>

    <h2 id="ch6">6. Fields（フィールド宣言）</h2>
    <p>class / struct のフィールドは <code>field</code> キーワードで宣言する。</p>
<pre><code>class Sample {
    field Count: int = 0;
    field Name: string = "default";

    readonly field Id: int;

    construct(id: int) {
        this.Id = id; // OK: inside the constructor
    }
    method Change(): void {
        this.Count = this.Count + 1; // OK
        // this.Id = 2; // NG: readonly field cannot be changed outside constructor
    }
}
</code></pre>
    <ul>
      <li><code>field</code> … 通常のフィールド。</li>
      <li><code>readonly field</code> … コンストラクタ内のみ代入可、それ以降は読み取り専用。</li>
      <li>struct / class の両方で同じ意味。</li>
    </ul>

    <hr>

    <h2 id="ch7">7. Class / Struct / Interface / Trait</h2>

    <h3>7.1 class</h3>
<pre><code>class FizzBuzz {
    field _Count: int = 0;
    field Name: string = "FizzBuzz";

    construct() {
    }

    method Run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>
    <ul>
      <li>class は参照型。</li>
      <li><code>sealed class</code> は <code>extends</code> による継承不可。</li>
      <li>単一継承のみサポート。</li>
    </ul>

    <h3>7.2 struct</h3>
<pre><code>struct Point {
    field X: int;
    field Y: int;

    construct(x: int, y: int) {
        this.X = x;
        this.Y = y;
    }
}
</code></pre>
    <ul>
      <li>struct は値型。</li>
      <li>フィールドはプリミティブ型か他の struct に限定（参照型フィールドは禁止）。</li>
      <li>struct のコピーは常に値コピー。</li>
      <li>struct の継承はサポートしない（<code>sealed struct</code> は「拡張禁止」マーカー）。</li>
    </ul>

    <h3>7.3 Inheritance and sealed</h3>
<pre><code>class Base {
    method Foo(): void { }
}

class Derived extends Base {
    method Bar(): void { }
}

sealed class FinalDerived extends Base {
    // cannot be extended further
}
</code></pre>

    <h3>7.4 interface</h3>
<pre><code>interface ILogger {
    method Log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method Log(msg: string): void {
        print(msg);
    }
}
</code></pre>
    <ul>
      <li><code>implements</code> キーワードでインタフェースを実装。</li>
      <li><code>is</code> 演算子でインタフェース実装有無を判定。</li>
    </ul>

    <h3>7.5 trait（トレイト）</h3>
<pre><code>trait TraitA {
    method Hello(): void {
        print("Hello from TraitA");
    }
}
</code></pre>

    <h4>with による trait の適用</h4>
<pre><code>var obj = new SomeClass() with TraitA;
obj.Hello(); // TraitA 由来のメソッド（競合がなければ）
</code></pre>

    <h4>非破壊な追加 / 削除（+ / -）</h4>
<pre><code>var obj2 = obj + TraitA;      // obj は変化せず、obj2 に TraitA が適用されたオブジェクトを生成
var obj3 = obj2 - TraitA;     // obj3 は obj2 から TraitA を取り除いたオブジェクト
</code></pre>

    <h4>as によるエイリアス</h4>
<pre><code>var obj2 = obj + TraitA as A;
obj2.A.Hello(); // OK

// obj2.Hello(); // NG: エイリアスのみで、メンバのフラット化は行われない
</code></pre>

    <h4>trait の衝突</h4>
    <ul>
      <li>複数 trait が同名フィールド / メソッドを定義するとコンパイルエラー。</li>
      <li><code>as A</code> などのエイリアス付き適用は衝突判定の対象外。</li>
      <li>クラス本体と trait メンバとの衝突の扱いは将来バージョンで定義予定。</li>
    </ul>

    <hr>

    <h2 id="ch8">8. delete &amp; null</h2>
<pre><code>var obj = new FizzBuzz();
delete obj;  // equivalent to: obj = null (at VM level)
</code></pre>
    <ul>
      <li><code>delete obj;</code> は VM レベルでは <code>obj = null</code> と等価。</li>
      <li>ソースコード中で <code>obj = null;</code> と書くことはできない。</li>
      <li>参照型は内部的には null を取り得るが、型システムは null を追跡しない。</li>
      <li>null 状態でのアクセスは <code>NullReferenceException</code> を引き起こす可能性がある。</li>
    </ul>

    <hr>

    <h2 id="ch9">9. is Operator（is 演算子）</h2>
<pre><code>if (obj is FizzBuzz) {
    // true if runtime type is FizzBuzz or a subclass
}

if (obj is ILogger) {
    // true if obj implements ILogger
}

if (obj is TraitA) {
    // true if obj has TraitA applied (with / +)
}
</code></pre>
    <ul>
      <li><code>is</code> は実行時の型チェックを行う。</li>
      <li>継承関係（Derived は Base としても扱う）を考慮する。</li>
      <li>インタフェースや trait に対しても使用できる。</li>
    </ul>

    <hr>

    <h2 id="ch10">10. Collections（配列 / リスト / セット / マップ）</h2>

    <h3>10.1 Arrays (T[])</h3>
<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

    <h3>10.2 Lists (T())</h3>
<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

    <h3>10.3 Sets (T{})</h3>
<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { X:0, Y:0 }, Point { X:1, Y:1 }};
</code></pre>

    <h3>10.4 Maps (map&lt;K/V&gt;)</h3>
<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // default key type is string
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

    <hr>

    <h2 id="ch11">11. enum and bitfield enum</h2>

    <h3>11.1 Normal enum</h3>
<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>
    <ul>
      <li>内部表現は常に int32。</li>
      <li><code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code> のような基礎型の変更は許可されない。</li>
      <li>enum 型も型ベース with の対象となり、<code>with (Color) { Red; }</code> などで列挙子に短縮アクセスできる。</li>
    </ul>

    <h3>11.2 bitfield enum</h3>
<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

    <h4>b(n) 記法</h4>
<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // highest b(n) so far is 3; Warn becomes b(4) = 1 &lt;&lt; 4
}
</code></pre>
    <ul>
      <li><code>b(n)</code> はビット n（<code>1 &lt;&lt; n</code>）を表す。</li>
      <li><code>Name : b(n)</code> でその列挙子にビット n を割り当てる。</li>
      <li><code>bitfield enum</code> で使用可能なビットは最大 32（n は 0–31）。</li>
      <li>同一ビットを共有する列挙子があっても、コンパイラは警告にとどめ、エラーにはしない。</li>
      <li>基礎型は常に int32 であり、<code>bitfield enum&lt;byte&gt;</code> などはコンパイルエラー。</li>
    </ul>

    <hr>

    <h2 id="ch12">12. main Block（エントリポイント）</h2>
<pre><code>function main(args: string[]): int {
    var fb = new FizzBuzz();
    fb.Run();
    return 0; // process exit code
}
</code></pre>
    <ul>
      <li>プログラムのエントリポイント。</li>
      <li><code>main</code> は通常の関数同様、<code>function</code> キーワードで宣言する。</li>
      <li>引数 <code>args</code> はコマンドライン引数の配列。</li>
      <li><code>main</code> の戻り値は <code>int</code> 型であり、その値がプロセスの終了コードとなる。</li>
    </ul>

    <hr>

    <h2 id="ch13">13. Temp Variable <code>_</code>（一時変数）</h2>
<pre><code>function main(args: string[]): int {
    var x = 10;
    _ = x + 5;   // このブロック内では _ は int 型として扱われる
    return 0;
}

method Foo(): void {
    var x = 10;
    _ = x + 5;   // このブロック内では _ は int 型として扱われる
}
</code></pre>
    <ul>
      <li><code>_</code> は任意のブロックで宣言なしに使用できる特別な一時変数。</li>
      <li><code>_</code> の型は、そのブロックで最初に代入された式の型として推論される。</li>
      <li><code>main</code> を含め、<code>_</code> と終了コードの関連付けは行わない（終了コードは <code>main</code> の戻り値で表現する）。</li>
      <li>with ブロック内では、追加で「現在の with 対象」を指す意味を持つ（4.2 参照）。</li>
    </ul>

    <hr>

    <h2 id="ch14">14. swap Keyword（swap キーワード）</h2>
<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>
    <ul>
      <li><code>swap (x, y);</code> は x と y の値（または参照）を入れ替える。</li>
      <li>swap が妥当かどうかはコンパイル時にチェックされる。</li>
    </ul>

    <hr>

    <h2 id="ch15">15. Operators（演算子）</h2>

    <h3>15.1 優先順位（高い順）</h3>
    <p>
      この表は「式」における演算子の優先順位を示す。<br>
      パイプライン文で使用される <code>|</code>（パイプライン演算子）および
      <code>|&gt;</code>（パイプ with 演算子）は、18.3 で定義される
      専用の「パイプライン文」構文として扱われ、通常の式の優先順位とは別枠で解釈される。
    </p>
    <ol>
      <li>メンバー / 呼び出し：<code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
      <li>単項：<code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
      <li>乗除：<code>*</code>, <code>/</code>, <code>%</code></li>
      <li>加減：<code>+</code>, <code>-</code></li>
      <li>シフト：<code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
      <li>関係：<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
      <li>等価：<code>==</code>, <code>!=</code></li>
      <li>ビット AND：<code>&amp;</code></li>
      <li>ビット XOR：<code>^</code></li>
      <li>ビット OR：<code>|</code></li>
      <li>論理 AND：<code>&amp;&amp;</code></li>
      <li>論理 OR：<code>||</code></li>
      <li>代入：<code>=</code></li>
    </ol>
    <p>複合代入（<code>+=</code> 等）はまだ仕様化されていない。</p>

    <h3>15.2 結合規則</h3>
    <ul>
      <li>単項演算子：右結合。</li>
      <li>代入：右結合。</li>
      <li>その他の 2 項演算子：左結合。</li>
    </ul>

    <hr>

    <h2 id="ch16">16. Exceptions（例外）</h2>
<pre><code>try {
    // code that might throw
}
catch (e) {
    // handle exception
}
finally {
    // cleanup
}
</code></pre>

    <h3>16.1 標準例外の概要</h3>
<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>
    <ul>
      <li><code>OverflowException</code> はオーバーフロー / アンダーフロー両方に用いる。</li>
      <li><code>ZeroDivisionException</code> は 0 / 0.0 による除算で投げる。</li>
      <li>パースやフォーマットエラーは <code>FormatException</code>。</li>
      <li>その他の VM レベルの致命的エラーは実装依存。</li>
    </ul>

    <hr>

    <h2 id="ch17">17. Modules / namespace / import</h2>
<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>
    <ul>
      <li><code>namespace</code> は論理的な名前空間を定義する。</li>
      <li><code>import</code> は他の namespace / シンボルへの参照を導入する。</li>
      <li>ファイル構成や循環 import の扱いなど詳細はモジュール仕様で定義される。</li>
    </ul>

    <hr>

    <h2 id="ch18">18. Pipes &amp; Filters（パイプとフィルタ）</h2>

    <p>
      Aloe は <code>pipe&lt;T&gt;</code> と <code>filter(...)</code> を用いて、
      サーバ / CLI / Web アプリなどのストリーミング処理を構成する。
      本章では、特に Result&lt;T&gt; を用いた Railway Oriented Programming（ROP）志向のパイプラインを想定する。
    </p>

    <h3>Railway Oriented Programming（ROP）の考え方</h3>
    <p>
      ROP は「成功」と「失敗」の 2 本のレールを持つイメージで処理を構成する考え方である。
      各ステップは <code>Result&lt;T&gt;</code> を入力として受け取り、
      <code>Result&lt;U&gt;</code> を返すことで、成功レールとエラーレールを保ったまま変換を重ねていく。
    </p>
<pre><code>入力  ──→  処理1  ──→  処理2  ──→  正常系出力
               ╲
                ╲→ エラー系出力
</code></pre>
    <p>
      具体的には、<code>pipe&lt;Result&lt;T&gt;&gt;</code> を流し、
      フィルタや map 関数が「成功なら次へ」「失敗ならそのままエラーとして流す」という挙動をとる。
      例外による制御よりも、<code>Result&lt;T&gt;</code> による明示的な成功 / 失敗の表現を推奨する。
    </p>

    <h3>18.1 pipe&lt;T&gt; の基本</h3>
    <ul>
      <li><code>pipe&lt;T&gt;</code> は T 型要素のストリーム。</li>
      <li><code>pipe&lt;byte&gt;</code> … 標準入力やソケットなどのバイト列。</li>
      <li><code>pipe&lt;string&gt;</code> … 文字列ストリーム。</li>
      <li>pipe は共有メモリではなく値コピーを前提とする。</li>
    </ul>

    <h4>18.1.1 組み込みパイプ</h4>
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code>（任意）</li>
    </ul>

    <h3>18.2 filter(...) の基本</h3>
    <p><code>filter(F)</code> はパイプライン中の中間変換ステージ。</p>

    <h4>18.2.1 フィルタ定義</h4>
<pre><code>filter LineSplit {
    // オプションクラス（bitfield enum など）を指定可能
    options LineSplitOptions;

    // 入出力パイプ型
    in : pipe&lt;string&gt;;
    out: pipe&lt;Result&lt;string&gt;&gt;;

    // フィールド（内部状態）も宣言可能
    field _Buffer: string = "";

    // コンストラクタ（任意）
    construct(initial: string) {
        _Buffer = initial;
    }

    // 実体処理：Result&lt;void&gt; を返すことを推奨
    bound(input: pipe&lt;string&gt;, output: pipe&lt;Result&lt;string&gt;&gt;): Result&lt;void&gt; {
        foreach (chunk in input) {
            let all = _Buffer + chunk;
            let lines = all.split("\n");
            var i = 0;
            while (i &lt; lines.Length - 1) {
                output.write(ok(lines[i]));
                i = i + 1;
            }
            _Buffer = lines[lines.Length - 1];
        }

        if (_Buffer != "") {
            output.write(ok(_Buffer));
        }

        output.close();
        return ok(void);
    }
}
</code></pre>
    <ul>
      <li><code>in</code> / <code>out</code> でフィルタが受け取るパイプ型と出力するパイプ型を定義する。</li>
      <li><code>field</code> により内部状態を持つこともできるが、
        ROP 的には「フィルタはできるだけ副作用のない関数」に近づけることが望ましい。
        特に再実行しても結果が変わらない冪等性を保つため、
        フィルタ内でのミューテーション（状態の書き換え）は最小限にとどめることを推奨する。</li>
      <li><code>construct(...)</code> によりフィルタごとの初期化処理を記述できる。</li>
      <li><code>bound(...): Result&lt;void&gt;</code> は
        <ul>
          <li>通常は <code>ok(void)</code> を返して「成功」を示す。</li>
          <li>致命的なエラーが発生した場合は <code>error(...)</code> を返し、
            上位側でパイプライン全体のエラーとして扱うことを想定する。</li>
        </ul>
      </li>
    </ul>

    <h4>18.2.2 フィルタオプション</h4>
<pre><code>bitfield enum JsonOptions {
    None         : b(0),
    PrettyPrint  : b(1),
    IncludeNulls : b(2),
}
</code></pre>
<pre><code>filter Json&lt;T&gt; {
    options JsonOptions;   // このフィルタのオプション型を指定

    in : pipe&lt;string&gt;;
    out: pipe&lt;Result&lt;T&gt;&gt;;

    bound(input: pipe&lt;string&gt;, output: pipe&lt;Result&lt;T&gt;&gt;): Result&lt;void&gt; {
        // ...
        return ok(void);
    }
}
</code></pre>
<pre><code>// 呼び出し側（オプション指定あり）
stdin
    | filter(Json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
    | Users;

// options で JsonOptions を指定しているため、クラス名省略も可能
stdin
    | filter(Json&lt;User&gt;: PrettyPrint | IncludeNulls)
    | Users;
</code></pre>
    <ul>
      <li>フィルタ定義内で <code>options SomeOptions;</code> を指定すると、
        そのフィルタにおけるオプション型として <code>SomeOptions</code> を関連付ける。</li>
      <li>その場合、<code>filter(Json&lt;T&gt;: PrettyPrint | IncludeNulls)</code> のように、
        呼び出し側で <code>SomeOptions.</code> のプレフィックスを省略できる。</li>
      <li>オプション型を指定しない場合は、常に完全修飾名
        （例：<code>JsonOptions.PrettyPrint</code>）で記述する。</li>
    </ul>

    <h3>18.3 パイプライン文と <code>|</code> / <code>|&gt;</code></h3>
<pre><code>stdin
    | filter(Utf8)
    | filter(Json&lt;DateTime&gt;)
    | Dates;
</code></pre>
    <ul>
      <li><code>A | B | C;</code> で A の出力が B へ、B の出力が C へ接続される。</li>
      <li>型チェックにより各ステージの入出力型整合性を確認する。</li>
      <li>パイプライン文そのものは値を返さない（副作用として接続を張るだけ）。</li>
      <li><code>|</code> は「パイプライン演算子」として、<code>pipe&lt;T&gt;</code> 同士を接続する。</li>
      <li><code>|&gt;</code> は将来的な拡張のために予約された
        「パイプ with 演算子」であり、本ドラフトでは構文のみ予約されている。
        具体的な意味付けは別途定義される。</li>
    </ul>

    <h3>18.4 foreach と pipe</h3>
<pre><code>foreach (line in Lines) {
    print("Input: " + line);
}
</code></pre>
    <ul>
      <li><code>foreach (x in p)</code> は内部的に <code>p.next()</code> を EOF まで呼ぶ。</li>
      <li>書き込み側が <code>close()</code> を呼ぶと読み側は EOF を検知してループを終了する。</li>
    </ul>

    <h3>18.5 map 関数（pipe 要素の関数適用）</h3>
    <p>
      <code>map</code> は <code>pipe&lt;T&gt;</code> 上の各要素に関数を適用し、
      新しい <code>pipe&lt;U&gt;</code> を返す組み込み高階関数である。
      また ROP との親和性を高めるために、
      <code>pipe&lt;Result&lt;T&gt;&gt;</code> 用のバージョンも用意する。
    </p>
<pre><code>// 概念的なシグネチャ（実際の表記はランタイム依存）
//
// 1. 通常のストリーム変換
//    src: pipe&lt;T&gt; の各要素に関数 f を適用し、pipe&lt;U&gt; を返す。
//
// 2. Result&lt;T&gt; ストリーム向け
//    Ok(t) にだけ f を適用し、Error(e) はそのまま通過させる。
//
// function Map&lt;T, U&gt;(src: pipe&lt;T&gt;, f: (T) : U) : pipe&lt;U&gt;
// function Map&lt;T, U&gt;(src: pipe&lt;Result&lt;T&gt;&gt;, f: (T) : Result&lt;U&gt;) : pipe&lt;Result&lt;U&gt;&gt;
</code></pre>

    <h4>18.5.1 pipe&lt;T&gt; に対する map</h4>
<pre><code>function Inc(x: int): int {
    return x + 1;
}

var Numbers: pipe&lt;int&gt; = pipe&lt;int&gt;.Create();
var Out    : pipe&lt;int&gt; = pipe&lt;int&gt;.Create();

Numbers
    | map(Inc)
    | Out;
</code></pre>
    <p>
      この例では、<code>Numbers: pipe&lt;int&gt;</code> から読み出した各要素に
      <code>Inc</code> を適用し、その結果を <code>Out: pipe&lt;int&gt;</code> へ流す。
      入力が EOF になったとき、<code>Out</code> も自動的に <code>close()</code> される。
    </p>

    <h4>18.5.2 pipe&lt;Result&lt;T&gt;&gt; に対する map</h4>
<pre><code>function Validate(u: User): Result&lt;User&gt; {
    if (u.Name == "") {
        return error("Name is empty", "User.Name.Empty");
    }
    return ok(u);
}

var UsersIn : pipe&lt;User&gt;         = pipe&lt;User&gt;.Create();
var Results : pipe&lt;Result&lt;User&gt;&gt; = pipe&lt;Result&lt;User&gt;&gt;.Create();

UsersIn
    | map(Validate)       // pipe&lt;User&gt; → pipe&lt;Result&lt;User&gt;&gt;
    | Results;
</code></pre>
    <p>
      <code>pipe&lt;Result&lt;T&gt;&gt;</code> 版の <code>map</code> は、
      入力が <code>Ok(t)</code> のときだけ関数を呼び出し、
      入力が <code>Error(e)</code> のときはそのまま <code>Error(e)</code> を下流へ流す。
      これにより、成功レールとエラーレールの二本レール構造を崩さずに変換を重ねられる。
    </p>

    <h4>18.5.3 コレクションパイプライン向け map テンプレート</h4>
    <p>
      コレクション型（例：<code>User()</code>）に対しては、
      「コレクションパイプライン」構文と組み合わせたテンプレート形式の
      <code>map</code> を用いて、別の型のコレクションに変換できる。
    </p>
<pre><code>let Users: User() = ...;

// Users の各要素を u として扱い、Customer にマッピングする例
Users as u
    | map Customer {
        Name    = u.Name,
        Address = u.Address,
    }
    | Customers;
</code></pre>
    <ul>
      <li><code>Users as u</code> は、コレクション <code>Users</code> の各要素を
        エイリアス <code>u</code> としてパイプラインに流す「コレクションパイプライン」の開始を表す。</li>
      <li><code>map Customer { ... }</code> は、ターゲット型 <code>Customer</code> の
        オブジェクト初期化テンプレートであり、ブロック内の各フィールド初期化式は
        現在の要素 <code>u</code> を参照できる。</li>
      <li>上記の例は、概念的には次のようなコードと等価である：</li>
    </ul>
<pre><code>let Customers: Customer() = ();

foreach (u in Users) {
    let c: Customer = Customer {
        Name    = u.Name,
        Address = u.Address,
    };
    Customers.Add(c);
}
</code></pre>
    <ul>
      <li>テンプレート内で指定されなかったフィールドは、<code>Customer</code> の
        デフォルト値（コンストラクタやフィールド初期値）に従う。</li>
      <li><code>Users as u | map Customer { ... }</code> の結果は、
        後続のパイプラインステージ（例：<code>| Customers;</code>）で受け取られる
        <code>Customer()</code> コレクションである。</li>
      <li>このテンプレート形式の <code>map</code> は、
        コレクションから別のコレクションへの「型付きプロジェクション」を簡潔に記述するための
        構文糖衣であり、コアのパイプ / filter モデルとは独立して定義される。</li>
    </ul>

    <h3>18.6 close と EOF 伝播</h3>
    <ul>
      <li><code>p.close()</code> 後の <code>write()</code> は無効（エラーになり得る）。</li>
      <li>フィルタは入力 EOF を検知したら出力側も <code>close()</code> すべき。</li>
    </ul>

    <h3>18.7 pipe を使った並行モデル</h3>
    <ul>
      <li>タスク同士の主な通信手段は <code>pipe&lt;T&gt;</code>。</li>
      <li>shared-nothing モデルを前提とし、共有可変データ構造は持たない設計を推奨。</li>
    </ul>

    <h3>18.8 match によるパイプ分岐（Result&lt;T&gt; の分岐）</h3>
    <p>
      <code>pipe&lt;Result&lt;T&gt;&gt;</code> を分岐させるために、
      パイプライン演算子と組み合わせた <code>match</code> 構文を用意する。
    </p>
<pre><code>Results
    | match {
        case Ok(u):
            | ValidUsers;
            break;

        case Error(err):
            | ErrorLog;
            break;

        default:
            | UnknownCases;
            break;
    };
</code></pre>
    <ul>
      <li><code>| match { ... };</code> は、直前のパイプの各要素に対してパターンマッチングを行い、
        条件ごとに別のパイプへ流すための構文である。</li>
      <li><code>case Ok(u):</code> のように、<code>Result&lt;T&gt;</code> には
        <code>Ok(変数)</code> / <code>Error(変数)</code> という特別なパターンを持つ。</li>
      <li>各 <code>case</code> ブロックの中では、先頭に <code>| NextPipe;</code> のように
        続くパイプラインを記述できる。
        そのブランチにマッチした要素のみが、その後ろに接続されたパイプへ流れる。</li>
      <li><code>default</code> ブロックは任意であり、
        どの <code>case</code> にもマッチしなかった要素を処理する。</li>
      <li><code>break;</code> は、そのブランチのパイプライン構築を終了する印として用いる。
        実装上は 1 ケース 1 パイプラインであることを明示するための記号的な役割を持つ。</li>
    </ul>

    <h3>18.9 pipe / filter 関連の主な組み込み関数</h3>
    <ul>
      <li><code>pipe&lt;T&gt;.Create(): pipe&lt;T&gt;</code> –
        新しいパイプを生成するファクトリメソッド。</li>
      <li><code>map(src: pipe&lt;T&gt;, f: (T) : U): pipe&lt;U&gt;</code> –
        各要素に関数を適用する高階関数。</li>
      <li><code>map(src: pipe&lt;Result&lt;T&gt;&gt;, f: (T) : Result&lt;U&gt;): pipe&lt;Result&lt;U&gt;&gt;</code> –
        ROP 用の Result パイプ版の map。</li>
      <li><code>ok(value: T): Result&lt;T&gt;</code> –
        成功を表す <code>Result&lt;T&gt;</code> を生成する。</li>
      <li><code>error(message: string, code: string): Result&lt;T&gt;</code> –
        失敗を表す <code>Result&lt;T&gt;</code> を生成する。</li>
      <li><code>print(value: string): void</code> –
        デバッグやログ出力のための基本的な出力関数（実装依存）。</li>
    </ul>
    <p class="note">
      ここに挙げた関数群は、あくまでコア言語レベルで想定される最小セットであり、
      実際のランタイムや標準ライブラリでは、より多くのユーティリティ関数が追加されることを想定している。
    </p>

    <h3>18.10 例：簡単な REST 風パイプライン</h3>
<pre><code>class User {
    field Id: int;
    field Name: string;
}

function main(args: string[]): int {
    let Req  : pipe&lt;byte&gt;        = pipe&lt;byte&gt;.Create();
    let Users: pipe&lt;Result&lt;User&gt;&gt; = pipe&lt;Result&lt;User&gt;&gt;.Create();

    stdin
        | filter(Utf8)
        | filter(Json&lt;User&gt;)
        | Users;

    // 1 件だけ読み取る例
    let u: Result&lt;User&gt; = Users.next();
    match (u) {
        case Ok(user):
            print("User: " + user.Name);
            break;

        case Error(err):
            print("Error: " + err.Message);
            break;
    }

    return 0;
}
</code></pre>
    <p class="note">
      <code>Utf8</code> や <code>Json&lt;T&gt;</code> などの標準フィルタの詳細は、
      コア言語仕様ではなく別途「標準フィルタライブラリ」仕様で定義される。
    </p>

    <hr>
    <p class="note">
      以上が、元の英語仕様に基づき、
      <strong>with ブロックの型対応拡張・Result&lt;T&gt;・ROP・map / match パイプライン・
      コレクションパイプライン向け map テンプレートを加えた
      Aloe 言語仕様（日本語・HTML 版）</strong> です。
    </p>

  </main>
</div>
</body>
</html>

