<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Aloe 言語仕様書 v0.3 (with 文対応版)</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            line-height: 1.7;
            margin: 2rem;
            max-width: 1100px;
        }
        h1, h2, h3, h4 {
            margin-top: 1.6em;
        }
        pre, code {
            font-family: "JetBrains Mono", "Cascadia Code", Consolas, monospace;
        }
        pre {
            background: #f7f7f7;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            overflow-x: auto;
        }
        .keyword {
            font-weight: bold;
        }
        hr {
            margin: 2.5rem 0;
        }
    </style>
</head>
<body>

<h1>Aloe 言語仕様書 v0.3</h1>
<p>
本書は、Aloe プログラミング言語の仕様を定義する。<br>
本バージョン v0.3 では、<span class="keyword">with 文</span> 構文を追加した。
</p>

<hr>

<h2>1. 言語概要</h2>

<h3>1.1 目的</h3>
<p>
Aloe は、静的型付け・コンパクトな構文・パイプ／フィルタによる処理合成を特徴とする汎用言語である。<br>
将来的に VM 実行環境および WebAssembly（WASM）コンポーネントとしての動作を想定している。
</p>

<h3>1.2 特徴</h3>
<ul>
    <li>静的型付け・ローカル型推論</li>
    <li><code>method</code> によるメソッド定義</li>
    <li><code>class</code>（参照型）と <code>struct</code>（値型）の区別</li>
    <li><code>enum</code> は内部表現を <code>int</code> に固定（<code>enum&lt;string&gt;</code>, <code>enum&lt;byte&gt;</code> は禁止）</li>
    <li>ビットフラグ用 <code>bitenum</code>（最大 32 個まで）</li>
    <li>パイプ (<code>|</code>) とフィルタによるデータフロー指向の記述</li>
    <li>オブジェクト初期化・整形のための <code>with</code> 文</li>
</ul>

<hr>

<h2>2. 字句構造</h2>

<h3>2.1 識別子</h3>
<p>
識別子は次のパターンに従う。
</p>
<pre><code>identifier ::= (letter | "_") (letter | digit | "_")*</code></pre>
<p>
大文字小文字は区別される。<br>
予約語と同じ綴りを識別子として用いることはできない。
</p>

<h3>2.2 予約語</h3>
<p>以下の単語は予約語であり、識別子として使用できない。</p>
<pre><code>let   const   var
class struct
method
if    else
while for
return break continue
true  false  null
with
enum bitenum
as    is
new
</code></pre>

<h3>2.3 コメント</h3>
<ul>
    <li>行コメント: <code>//</code> から行末まで</li>
    <li>ブロックコメント: <code>/* ... */</code>（ネスト不可）</li>
</ul>

<h3>2.4 リテラル</h3>
<ul>
    <li>整数リテラル: 10 進数 (例: <code>0</code>, <code>42</code>, <code>-1</code>)</li>
    <li>浮動小数点リテラル: (例: <code>3.14</code>, <code>-0.5</code>)</li>
    <li>文字列リテラル: ダブルクォートで囲む (例: <code>"hello"</code>)</li>
    <li>真偽値リテラル: <code>true</code>, <code>false</code></li>
    <li>ヌルリテラル: <code>null</code></li>
</ul>

<hr>

<h2>3. 型システム</h2>

<h3>3.1 組み込み型</h3>
<ul>
    <li><code>int</code></li>
    <li><code>float</code></li>
    <li><code>bool</code></li>
    <li><code>string</code></li>
    <li>配列型: <code>T[]</code></li>
    <li>リスト型: <code>List&lt;T&gt;</code>（標準ライブラリ型）</li>
</ul>

<h3>3.2 class と struct</h3>
<p>
Aloe は <code>class</code>（参照型）と <code>struct</code>（値型）を持つ。
</p>

<h4>3.2.1 class</h4>
<ul>
    <li>参照型であり、変数はインスタンスへの参照を保持する。</li>
    <li>代入で参照がコピーされる。</li>
</ul>

<h4>3.2.2 struct</h4>
<ul>
    <li>値型であり、変数は値そのものを保持する。</li>
    <li>代入で値がコピーされる。</li>
    <li>関数呼び出しの引数でもコピーが渡される（参照渡しは将来検討）。</li>
</ul>

<h3>3.3 enum と bitenum</h3>

<h4>3.3.1 enum</h4>
<p>
<code>enum</code> は内部的に <code>int</code> で表現される列挙型である。<br>
基礎型を <code>&lt;T&gt;</code> で指定することはできない。すなわち、<code>enum&lt;string&gt;</code> や <code>enum&lt;byte&gt;</code> は禁止とする。
</p>

<pre><code>enum Color {
    Red = 0;
    Green = 1;
    Blue = 2;
}
</code></pre>

<h4>3.3.2 bitenum</h4>
<p>
ビットフラグ用途の列挙型を <code>bitenum</code> として定義できる。<br>
ビットフラグとして扱う前提から、定義できる列挙子の数は <strong>最大 32 個まで</strong> とする。
</p>

<pre><code>bitenum FileAccess {
    Read    = 1 &lt;&lt; 0;
    Write   = 1 &lt;&lt; 1;
    Execute = 1 &lt;&lt; 2;
}
</code></pre>

<hr>

<h2>4. 変数と代入</h2>

<h3>4.1 変数宣言</h3>
<p>
変数宣言は <code>let</code> を用いる。
</p>

<pre><code>let x : int = 10;
let name : string = "Alice";
</code></pre>

<p>
型注釈は省略可能であり、初期値から型推論される。
</p>
<pre><code>let x = 10;         // x は int
let s = "hello";    // s は string
</code></pre>

<h3>4.2 再代入</h3>
<p>
<code>let</code> の変数は再代入可能とする（<code>const</code> は将来的に検討）。
</p>

<pre><code>let x = 1;
x = 2;      // OK
</code></pre>

<hr>

<h2>5. 式</h2>

<h3>5.1 基本式</h3>
<ul>
    <li>リテラル</li>
    <li>識別子参照</li>
    <li>メンバーアクセス: <code>obj.field</code></li>
    <li>配列アクセス: <code>a[index]</code></li>
</ul>

<h3>5.2 演算子</h3>
<p>代表的な演算子のみ記載する。</p>

<ul>
    <li>算術: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
    <li>比較: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
    <li>論理: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
</ul>

<h3>5.3 パイプ演算子</h3>

<h4>5.3.1 基本</h4>
<p>
Aloe はパイプ演算子 <code>|</code> を持つ。<br>
<code>a | f()</code> は、「左辺の値を、右辺のフィルタ <code>f</code> に流し込んだ結果」を表す。
</p>

<h4>5.3.2 フィルタ記法（概要）</h4>
<p>
フィルタは通常のメソッド／関数と同様に定義されるが、
</p>
<ul>
    <li>第 1 引数が「パイプから流れてくる値」を受け取る。</li>
    <li>戻り値は次のパイプへ渡される。</li>
</ul>

<pre><code>method TrimAll(s : string) : string {
    return Trim(s);
}

let result =
    "  hello  "
    | TrimAll()
    | ToUpper();
</code></pre>

<p>
パイプおよびフィルタの詳細仕様は別節（将来拡張）で定義する。
</p>

<hr>

<h2>6. 文</h2>

<h3>6.1 ブロック</h3>
<p>
ブロックは <code>{</code> と <code>}</code> で囲まれた文の並びである。<br>
ブロックは新しいスコープを導入する。
</p>

<h3>6.2 if 文</h3>
<pre><code>if (condition) {
    // then
} else {
    // else
}
</code></pre>

<h3>6.3 while 文</h3>
<pre><code>while (condition) {
    // body
}
</code></pre>

<h3>6.4 for 文（概要）</h3>
<pre><code>for (let i = 0; i &lt; n; i = i + 1) {
    // body
}
</code></pre>

<h3>6.5 return / break / continue</h3>
<ul>
    <li><code>return expr;</code>: メソッドからの復帰</li>
    <li><code>break;</code>: ループ中断</li>
    <li><code>continue;</code>: ループの次反復へ進む</li>
</ul>

<hr>

<h2>7. with 文</h2>

<p>
<strong>本節は v0.3 で追加された。</strong><br>
<code>with</code> 文は、あるオブジェクトに対する一連の操作を、スコープ付きで簡潔に記述するための構文である。<br>
主な用途は次のとおり。
</p>

<ul>
    <li>オブジェクトの初期化・設定をまとめて書く</li>
    <li>パイプ／フィルタと組み合わせて、途中結果のオブジェクトを整形する</li>
</ul>

<h3>7.1 構文</h3>

<pre><code>with-statement  ::= "with" "(" expression ")" block

block           ::= "{" statement-list "}"
</code></pre>

<p>
<code>expression</code> の評価結果を「対象オブジェクト」と呼ぶ。
</p>

<h3>7.2 基本動作</h3>

<ol>
    <li>
        <p>
        <code>with</code> 文が評価されるとき、まず <code>()</code> 内の <code>expression</code> を 1 回だけ評価し、その結果をローカルな暗黙変数 <code>it</code> に束縛する。
        </p>
    </li>
    <li>
        <p>ブロック内では、以下のルールで名前解決が行われる。</p>
        <ul>
            <li><code>it</code> という識別子は、常に対象オブジェクトを指す。</li>
            <li><code>it.メンバー</code> という形式で対象オブジェクトのメンバーにアクセスできる。</li>
            <li>
                単純な識別子 <code>name</code> への代入があり、かつ <code>it</code> の型に <code>name</code> というフィールド／プロパティが存在する場合、
                <pre><code>name = expr;</code></pre>
                は次の糖衣構文として解釈される。
                <pre><code>it.name = expr;</code></pre>
            </li>
            <li>
                上記に該当しない識別子は、通常どおりローカル変数や外側スコープの変数として解決される。
            </li>
        </ul>
    </li>
    <li>
        <p>
            <code>with</code> 文をステートメントとして用いる場合、<code>with</code> 自体の評価結果は無視される。
        </p>
    </li>
    <li>
        <p>
            <code>with</code> を式コンテキストで用いた場合、<code>with</code> 式の評価結果は <strong>対象オブジェクト <code>it</code> 自身</strong> となる。
        </p>
    </li>
</ol>

<h3>7.3 例</h3>

<h4>7.3.1 オブジェクトの設定</h4>

<pre><code>let user : User = new User();

with (user) {
    id    = 1001;
    name  = "Alice";
    email = "alice@example.com";
}
</code></pre>

<p>上記は次のコードと等価である。</p>

<pre><code>let user : User = new User();

user.id    = 1001;
user.name  = "Alice";
user.email = "alice@example.com";
</code></pre>

<h4>7.3.2 パイプとの組み合わせ（糖衣構文）</h4>

<p>
パイプで使いやすくするため、次の糖衣構文を定義する。
</p>

<pre><code>expr "|" "with" block
    ≡
with (expr) block
</code></pre>

<p>
この場合、<code>with</code> の直後は <code>()</code> ではなくブロックだけを書く。
</p>

<pre><code>let user =
    GetUserById(1001)
    | with {
        name  = Trim(name);
        email = ToLower(email);
      }
    | ValidateUser();
</code></pre>

<p>
ここでは次のように解釈される。
</p>
<ul>
    <li>左辺 <code>GetUserById(1001)</code> の結果が <code>with</code> の対象オブジェクト。</li>
    <li><code>with { ... }</code> でそのオブジェクトを書き換える。</li>
    <li>同じオブジェクトが次の <code>ValidateUser()</code> に流れる。</li>
</ul>

<p>
実装上は、パイプの糖衣構文はコンパイル時に次のように展開される。
</p>

<pre><code>let user =
    with (GetUserById(1001)) {
        name  = Trim(name);
        email = ToLower(email);
    }
    | ValidateUser();
</code></pre>

<h3>7.4 スコープとネスト</h3>

<ul>
    <li><code>with</code> ブロック内で有効な暗黙変数 <code>it</code> は、その <code>with</code> 文のブロックの外側には漏れない。</li>
    <li><code>with</code> はネストして使用できる。内側の <code>with</code> では、内側の対象オブジェクトが <code>it</code> となる。</li>
</ul>

<pre><code>with (user) {
    name = "Outer";

    with (address) {
        city = "Tokyo";
    }

    // ここでは再び user が it
    name = "Outer2";
}
</code></pre>

<h3>7.5 参照型／値型との関係</h3>

<ul>
    <li>対象オブジェクトの型が <code>class</code>（参照型）の場合、ブロック内での書き換えは元のオブジェクトに反映される。</li>
    <li>対象オブジェクトの型が <code>struct</code>（値型）の場合、<code>it</code> は値のコピーになる。
        <ul>
            <li><code>it</code> のメンバーを書き換えても、元の変数に自動的に反映されることはない。</li>
        </ul>
    </li>
</ul>

<p>
値型に対して「元の変数を書き換える」挙動が必要な場合は、明示的な代入を用いること。
</p>

<pre><code>let p : Point = new Point();

p = with (p) {
    x = x + 1;
    y = y + 1;
};
</code></pre>

<h3>7.6 null の扱い</h3>

<ul>
    <li><code>expression</code> の評価結果が <code>null</code> の場合、
        <code>with</code> ブロック内で対象オブジェクトのメンバーにアクセスした時点で実行時エラー（例: <code>NullReferenceError</code>）とする。
    </li>
    <li><code>with (null) { ... }</code> のようなコードは常に例外を投げる。</li>
</ul>

<h3>7.7 制御フローとの関係</h3>

<ul>
    <li><code>with</code> ブロック内の <code>return</code> / <code>break</code> / <code>continue</code> は、通常のブロックと同様に外側の制御フローへ伝播する。
        <ul>
            <li><code>with</code> 文は、これらの制御フローを捕捉・変形しない。</li>
        </ul>
    </li>
    <li><code>with</code> を式として利用している場合でも、ブロック内で <code>return</code> した時点でメソッドは終了し、<code>with</code> 式の結果は評価されない。</li>
</ul>

<pre><code>method FindAndNormalizeUser(id : int) : User {
    let user = GetUserById(id);

    if (user == null) {
        return null;
    }

    return with (user) {
        name  = Trim(name);
        email = ToLower(email);
    };
}
</code></pre>

<hr>

<h2>8. メソッド定義</h2>

<h3>8.1 構文</h3>

<pre><code>method name("(" parameter-list? ")") ":" type block</code></pre>

<p>例:</p>

<pre><code>method Add(a : int, b : int) : int {
    return a + b;
}
</code></pre>

<h3>8.2 戻り値なしメソッド</h3>
<p>
戻り値なしメソッドには <code>void</code> 型を用いる（暫定仕様）。
</p>

<pre><code>method Log(message : string) : void {
    PrintLine(message);
}
</code></pre>

<hr>

<h2>9. クラスと構造体</h2>

<h3>9.1 class</h3>
<pre><code>class User {
    id   : int;
    name : string;
    email : string;

    method Display() : void {
        PrintLine(name);
    }
}
</code></pre>

<h3>9.2 struct</h3>
<pre><code>struct Point {
    x : int;
    y : int;
}
</code></pre>

<hr>

<h2>10. 将来拡張</h2>

<ul>
    <li>例外処理（<code>try</code>, <code>catch</code>, <code>finally</code>）</li>
    <li>ジェネリクス</li>
    <li>参照パラメータ（<code>ref</code>-like）</li>
    <li>より詳細なパイプ／フィルタ仕様</li>
    <li>モジュール／名前空間機構</li>
</ul>

<p>
以上が、Aloe 言語仕様書 v0.3（<code>with</code> 文追加版）の全文である。
</p>

</body>
</html>
