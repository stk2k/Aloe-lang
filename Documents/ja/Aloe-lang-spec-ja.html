
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Aloe 言語仕様書（ドラフト、日本語・pipe/filter/producer/consumer + delete/with/lock/class 継承/generics 更新版）</title>
  <meta name="last-updated" content="2025-11-29T11:20" />
  <style>
    /* レイアウトだけ最低限。フォントはブラウザ標準任せにしておく */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe 言語仕様書</h1>
    <div class="tagline">ドラフト版 / Pipe・Filter・Producer・Consumer + delete/with/lock/class 継承/generics 更新</div>
    <div class="updated">最終更新: 2025-11-29 11:20</div>
    <nav>
      <div class="section-title">概要</div>
      <a href="#intro">1. 概要</a>
      <a href="#goals">2. デザイン方針</a>

      <div class="section-title">言語の基本</div>
      <a href="#syntax">3. 基本文法</a>
      <a href="#types">4. 型システム</a>
      <a href="#classes">4.5 クラスと継承</a>
      <a href="#generics">4.6 ジェネリクス</a>
      <a href="#functions-methods">5. 関数とメソッド</a>

      <div class="section-title">パイプ / コレクション</div>
      <a href="#pipe-overview">6. Pipe / Filter モデル</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; 型</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 Pipe 系宣言構文</a>
      <a href="#pipe-operator">6.4 パイプ演算子 <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 標準フィルタ・プロデューサ例</a>

      <div class="section-title">構文拡張</div>
      <a href="#with">7. with 構文</a>
      <a href="#delete">8. delete 構文</a>
      <a href="#lock">9. lock 構文と同期</a>

      <div class="section-title">制御・実行モデル</div>
      <a href="#exceptions">10. 例外処理</a>
      <a href="#runtime">11. 実行モデルとメモリ管理</a>

      <div class="section-title">その他</div>
      <a href="#limits">12. 制限事項と今後の拡張</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. 概要</h1>
      <p>
        Aloe は、静的型付き・シンプルな構文・スタックベースの VM（AloeVM）を持つ
        <strong>実験的プログラミング言語</strong>です。
        特に <strong>Pipe / Filter によるデータフロー記述</strong>と、
        WebAssembly との親和性を重視して設計されています。
      </p>
      <ul>
        <li>静的型付き（コンパイル時に型チェック）</li>
        <li>構文は C 系言語に近いが、機能は必要最小限</li>
        <li>テキスト処理・REST 呼び出し・ログ処理などの
          「データを流して変換する」コードを気持ちよく書ける
        </li>
        <li>実装はスタックベース VM（AloeVM）＋将来的な WebAssembly 出力を想定</li>
      </ul>
      <p class="note">
        この文書は <strong>言語仕様書のドラフト</strong>です。
        実際のコンパイラ・VM 実装と食い違う可能性があります。
      </p>
    </section>

    <section id="goals">
      <h2>2. デザイン方針</h2>
      <h3>2.1 目標</h3>
      <ul>
        <li><strong>読みやすさ</strong>：仕様として読めるドキュメント性</li>
        <li><strong>実装しやすさ</strong>：小さなコンパイラ・VM で実装できる</li>
        <li><strong>Pipe / Filter の一貫性</strong>：データフローの型安全な表現</li>
        <li><strong>Wasm へのブリッジ</strong>：将来的に Wasm コンポーネントモデルと接続しやすい</li>
      </ul>

      <h3>2.2 非目標</h3>
      <ul>
        <li>汎用言語としての「なんでもできる」こと</li>
        <li>JIT 最適化レベルのパフォーマンス競争</li>
        <li>複雑なメタプログラミング（マクロなど）は当面対象外</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. 基本文法</h2>

      <h3>3.1 ソースコードとファイル</h3>
      <ul>
        <li>ソースファイルの文字コードは UTF-8 を想定する。</li>
        <li>1 行コメント: <code>// コメント</code></li>
        <li>複数行コメント: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 トークン</h3>
      <ul>
        <li>識別子: 先頭は英字または <code>_</code>、続く文字に数字を含めてよい。</li>
        <li>キーワードは予約語として識別子に使用できない。</li>
      </ul>

      <h3>3.3 代表的なキーワード</h3>
      <table>
        <tr><th>カテゴリ</th><th>キーワード</th></tr>
        <tr><td>宣言</td><td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td></tr>
        <tr><td>制御</td><td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td></tr>
        <tr><td>関数</td><td><code>method</code></td></tr>
        <tr><td>補助</td><td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td></tr>
      </table>

      <h3>3.4 文と式</h3>
      <ul>
        <li>文の末尾には基本的にセミコロン <code>;</code> を付ける。</li>
        <li>ブロックは <code>{ ... }</code> で囲む。</li>
        <li>制御構文内の条件式は <code>Bool</code> 型でなければならない。</li>
      </ul>

      <pre><code>// 変数宣言
let Threshold: Int = 10;
var Count: Int = 0;

// if 文
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. 型システム</h2>

      <h3>4.1 プリミティブ型</h3>
      <table>
        <tr><th>型</th><th>説明</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>符号付き整数（ビット幅は実装依存。32bit を想定）</td></tr>
        <tr><td><code>Float</code></td><td>浮動小数（32 または 64bit、実装依存）</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 文字列（内部表現は実装依存）</td></tr>
      </table>

      <h3>4.2 配列・コレクション</h3>
      <ul>
        <li>固定長配列: <code>T[]</code></li>
        <li>可変長コレクション・遅延列は <code>Pipe&lt;T&gt;</code> を使用（詳細は 6 章）</li>
      </ul>

      <h3>4.3 構造体（struct）</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> は値型であり、代入時にコピーされる。</li>
        <li>シャローコピーのセマンティクスとし、ネストされた参照型の共有は VM 側仕様に依存する。</li>
      </ul>

      <h3>4.4 列挙型（enum）</h3>
      <ul>
        <li><code>enum</code> は内部表現を <strong>常に <code>Int</code></strong> とする。</li>
        <li><code>enum&lt;String&gt;</code> や <code>enum&lt;Byte&gt;</code> のような
          ジェネリックな列挙は <strong>禁止</strong> とする。
        </li>
        <li>ビットフラグ用途の列挙では、フラグ数は最大 32 個までとする。</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 クラスと継承（class / interface / trait / sealed）</h2>

      <h3>4.5.1 クラス（class）の基本</h3>
      <ul>
        <li><code>class</code> は常に <strong>ヒープ確保される参照型</strong> である。</li>
        <li>代入は <strong>参照コピー（浅いコピー）</strong> とする。</li>
        <li><code>clone</code> キーワードにより、オブジェクトのコピー（新しい参照）を生成できる。</li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // 参照コピー（A と B は同じインスタンスを指す）

var C: User = clone A;  // 新しいインスタンスを生成して、その参照を返す（浅いコピー）</code></pre>

      <p class="note">
        <strong>浅いコピー</strong> とは、フィールドの値をそのままコピーするだけであり、
        フィールドが参照型である場合は参照自体がコピーされることを意味する。
        深いコピーや特殊なクローン動作が必要な型は、将来的にユーザー定義の <code>Clone</code> メソッドなどで拡張する余地を残す。
      </p>

      <h3>4.5.2 クラス継承（単一継承）</h3>
      <p>
        Aloe の <code>class</code> は <strong>単一継承</strong> のみを許可する。
        すなわち、あるクラスは継承元クラスを 1 つだけ指定できる。
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// 以下はコンパイルエラー（クラスの多重継承は禁止）
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>クラス階層は木（あるいは鎖）構造となり、ダイヤモンド継承は発生しない。</li>
        <li>クラス継承は「状態と振る舞いの再利用」を目的とする。</li>
      </ul>

      <h3>4.5.3 interface と trait</h3>
      <p>
        Aloe は、クラスの多重継承を行わない代わりに、
        <strong>interface</strong> と <strong>trait</strong> によって振る舞いの組み合わせを表現する。
      </p>

      <ul>
        <li><code>interface</code> はメソッドシグネチャのみを定義する契約型であり、実装は持たない（デフォルト実装を導入するかどうかは将来検討）。</li>
        <li><code>trait</code> はメソッド実装を持つミックスイン用の単位であり、既存クラスに振る舞いを追加するために使用する。</li>
        <li>1 つのクラスは、<strong>1 つの基底クラス</strong>に加えて、複数の <code>interface</code> を実装し、複数の <code>trait</code> を <code>with</code> で付与できる。</li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose(): Unit;
}

trait Printable {
  method PrintSelf(): Unit {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose(): Unit {
    // リソース解放処理
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        <code>interface</code> と <code>trait</code> の詳細な構文・継承ルール・競合解決（複数 trait から同名メソッドを得た場合の扱い）は、
        本ドラフトでは方向性のみを示し、完全な仕様は今後の検討事項とする。
      </p>

      <h3>4.5.4 sealed による継承禁止</h3>
      <p>
        あるクラスからの継承を禁止する場合は、<code>sealed</code> 修飾子を用いる。
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// 以下はコンパイルエラー（Token は sealed）
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li><code>sealed class</code> は、他のクラスから継承してはならない。</li>
        <li><code>sealed</code> クラスであっても、<code>interface</code> を実装したり、<code>trait</code> を <code>with</code> で付与することは許可される。</li>
        <li>将来的に、sealed クラスと union / パターンマッチの網羅性チェックを結びつける設計も検討される。</li>
      </ul>

      <h3>4.5.5 readonly とクラス</h3>
      <ul>
        <li>クラスのフィールドはデフォルトで可変とする。</li>
        <li>フィールドに <code>readonly</code> 修飾子を付けることで、そのフィールドを不変にできる（代入はコンストラクタ等に制限される想定）。</li>
        <li><code>readonly class</code> を将来的に導入し、クラス全体を強制的に読み取り専用として扱う設計も候補に含める。</li>
      </ul>

      <p class="small">
        本節では、クラスが「ヒープ確保の参照型」「単一継承のみ」「多重継承は interface + trait で表現」「sealed による継承禁止」という
        高レベルな設計方針を定める。詳細なメソッド解決順序や trait の競合解決ルールは、別途仕様で補う。
      </p>
    </section>

    <section id="generics">
      <h2>4.6 ジェネリクス</h2>

      <h3>4.6.1 概要</h3>
      <p>
        Aloe は、型・関数・メソッド・Pipe 系宣言に対して、最低限のジェネリクス機構を提供する。
        目的は、<strong>コレクションや Pipe / Filter を型安全に再利用可能にすること</strong>であり、
        高度な型レベル計算は当面の対象外とする。
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: T -&gt; U): Pipe&lt;U&gt; {
  // 実装略
}</code></pre>

      <h3>4.6.2 ジェネリック型パラメータ</h3>
      <ul>
        <li>型・struct・class・interface・trait・method・producer / filter / consumer などは、<code>&lt;T, U, ...&gt;</code> で型パラメータを受け取ることができる。</li>
        <li>型パラメータ名は先頭大文字（<code>T</code>, <code>TItem</code>, <code>TKey</code> など）を推奨する。</li>
        <li>ジェネリック引数は、使用箇所で具体的な型に束縛される。</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // 実装略
}</code></pre>

      <h3>4.6.3 where による型制約（概要）</h3>
      <p>
        Aloe のジェネリクスは、<code>where</code> 句による型制約を <strong>オプション</strong> としてサポートする。
        制約を付けない単純なジェネリクスが基本だが、0.1 の段階から一部の制約を利用できる。
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int 専用の合計
}</code></pre>

      <p class="note">
        ここでの <code>where</code> は <strong>コンパイル時の型チェック専用</strong> であり、
        ランタイム上の表現（モノモルフィック展開・ボックス化など）の詳細は VM 仕様側で定義される。
      </p>

      <h3>4.6.4 サポートされる制約の種類</h3>
      <p>
        0.1 時点でサポート対象とする制約は以下の通りとする。
      </p>

      <ul>
        <li><strong>値型 / 参照型 制約</strong>
          <ul>
            <li><code>where T: struct</code> … 値型でなければならない。</li>
            <li><code>where T: class</code> … 参照型でなければならない。</li>
          </ul>
        </li>
        <li><strong>プリミティブ型制約</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code> など、プリミティブ型名を直接指定する。</li>
          </ul>
        </li>
        <li><strong>ユーザー定義型制約</strong>
          <ul>
            <li><code>where T: SomeTrait</code> … 特定の <code>trait</code> を実装している型。</li>
            <li><code>where T: MyStruct</code> … 特定の <code>struct</code> 型。</li>
            <li><code>where T: MyClass</code> … 特定の <code>class</code> 型。</li>
          </ul>
        </li>
        <li><strong>任意の具象型名</strong>
          <ul>
            <li><code>where T: Pipe&lt;Int&gt;</code> のように、既存の具体型名をそのまま制約として用いることができる。</li>
          </ul>
        </li>
      </ul>

      <pre><code>// 値型専用
method Zero&lt;T&gt;(): T
  where T: struct
{
  // 実装略
}

// Int 専用 Pipe
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // 実装略
}

// UserInfo を表す struct 専用
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // 実装略
}</code></pre>

      <h3>4.6.5 制約違反時の挙動</h3>
      <ul>
        <li>ジェネリック関数 / 型の呼び出し時に、<code>where</code> 句を満たさない型引数が指定された場合、コンパイルエラーとなる。</li>
        <li>制約が複数指定されている場合は、そのすべてを満たす必要がある。</li>
        <li>現時点では、循環する制約や高度な型クラス風の指定はサポートしない。</li>
      </ul>

      <pre><code>// コンパイルエラー例

// where T: Int なので、T に String は使えない
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- コンパイルエラー</code></pre>

      <p class="small">
        ジェネリクスの内部表現（モノモルフィック展開 or 共有コード + 型タグなど）は AloeVM 側の実装詳細とし、
        本仕様書では「型安全な再利用」と「where による制約チェック」の振る舞いのみを定義する。
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. 関数とメソッド</h2>

      <h3>5.1 method 宣言</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> はトップレベル関数または型にバインドされたメソッドを定義する。</li>
        <li>返り値が無い場合は <code>Unit</code> 型と見なす。</li>
      </ul>

      <h3>5.2 bound によるメソッドバインド</h3>
      <p>
        Aloe では、既存の型にメソッドを「後付け」でバインドするために <code>bound</code> を導入する。
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // 内部表現は VM 依存
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; {
    // 実装略
  }
}</code></pre>

      <p class="note">
        本仕様では特に <code>Pipe&lt;T&gt;</code> に対する <code>bound</code> に、
        <strong>戻り値制限</strong> を設ける（6.2 章参照）。
      </p>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter モデル</h2>

      <p>
        Aloe の特徴は、<strong>Pipe / Filter によるデータフロー</strong>を、
        型付きで一貫したスタイルで書ける点にある。
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        このようなコードは概念的には
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>という関数合成であり、Aloe の <code>|&gt;</code> 演算子はその糖衣構文である。</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; 型</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> は、Aloe における「パイプ世界」を表す型である。
          遅延評価される列・ストリーム・イテレータに相当する。
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> は「要素型 <code>T</code> を流すパイプ」を表す。</li>
          <li>内部表現（イテレータチェーン・コルーチンなど）は VM 実装に依存する。</li>
          <li>標準ライブラリは <code>Pipe&lt;T&gt;</code> を前提に
            producer / transformer / consumer を提供する。
          </li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // 実装依存の内部フィールド
}</code></pre>

        <p class="note">
          <strong>パイプ世界</strong>とは、<code>Pipe&lt;T&gt;</code> を入力・出力とする
          函数たち（producer / transformer / consumer）の合成領域を指す。
          この世界から外へ出るのが consumer である。
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          Pipe / Filter モデルでは、関数（またはオブジェクト）の役割を
          次の 3 種類に分類する。
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>定義</strong>：戻り値型が <code>Pipe&lt;*&gt;</code> である関数・オブジェクトのうち、
            パイプラインの先頭に置かれるもの。
          </li>
          <li><strong>役割</strong>：外部世界（ファイル・HTTP・配列など）から
            データを読み取り、パイプ世界（<code>Pipe&lt;T&gt;</code>）に「流し込む」。
          </li>
          <li><strong>型レベル</strong>：<code>X -&gt; Pipe&lt;T&gt;</code> という形を持つ。
            本仕様では <strong>Producer として設計されるものは必ず <code>Pipe&lt;*&gt;</code> を出力する</strong>。
          </li>
        </ul>

        <h4>6.2.2 Transformer（中間フィルタ）</h4>
        <ul>
          <li><strong>定義</strong>：<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>
            の形を持つ関数またはメソッド。
          </li>
          <li><strong>役割</strong>：パイプ世界の中でデータを変換・フィルタ・ソートなどするが、
            まだ外には出さない。
          </li>
        </ul>

        <p>
          Aloe では、<strong><code>bound Pipe&lt;T&gt;</code> に定義されるメソッド</strong>を、
          原則として transformer（中間フィルタ）専用とする。
        </p>

        <div class="note">
          <strong>制約：</strong><br />
          <code>bound Pipe&lt;T&gt;</code> ブロック内に宣言されるメソッドは、
          その戻り値型として <strong>必ず <code>Pipe&lt;*&gt;</code> を返さなければならない</strong>。<br />
          すなわち、<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> という形に限る。
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: T -&gt; Bool): Pipe&lt;T&gt; { ... }

  // OK: 要素型を変換する transformer
  method Map&lt;U&gt;(Selector: T -&gt; U): Pipe&lt;U&gt; { ... }

  // NG: 戻り値が Pipe ではないため、仕様違反
  // method Count(): Int { ... }  // &lt;-- コンパイルエラーになるべき
}</code></pre>

        <h4>6.2.3 Consumer（終端フィルタ）</h4>

        <ul>
          <li><strong>定義</strong>：
            <code>Pipe&lt;T&gt; -&gt; R</code> の形を持ち、
            戻り値 <code>R</code> が <code>Pipe&lt;*&gt;</code> ではない関数・オブジェクト。
          </li>
          <li><strong>役割</strong>：
            パイプ世界から外へ出るゲート。
            パイプを「消費」し、配列や単一値・外部 I/O などに落とし込む。
          </li>
          <li><strong>戻り値制限</strong>：
            Consumer に関しては <strong>戻り値型に制限はない</strong>。
            <code>T[]</code>, <code>Int</code>, <code>Unit</code> など任意の型を返せるが、
            <code>Pipe&lt;*&gt;</code> を返すことはできない。
          </li>
        </ul>

        <pre><code>// 配列に展開する pure consumer
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// 行数を数える consumer
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 Pipe 系宣言構文（producer / pipe / filter / consumer）</h3>

        <p>
          Aloe では、Pipe / Filter モデルを構成する要素として、
          <strong>producer / pipe / filter / consumer</strong> の 4 種類の宣言を導入する。
          これらはすべて「コンストラクタ付きオブジェクト」として定義され、
          パイプラインに結合されたときに <code>bound</code> ブロックが実行される。
        </p>

        <h4>6.3.1 producer 定義</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // パイプラインに結合されたときの処理
    // 外部リソースからデータを読み取り、output に書き込む
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> はプロデューサー名。</li>
          <li><code>out</code> には、この producer が生成する
            <strong>パイプ世界の出力型</strong>を指定する。
            仕様上、<strong>必ず <code>Pipe&lt;*&gt;</code> 型でなければならない</strong>。
          </li>
          <li><code>bound(output)</code> ブロックは、
            実際にパイプライン先頭に結合されたときの処理を記述する。
            <code>output</code> の型は <code>out</code> に指定した型（<code>Pipe&lt;T&gt;</code>）である。
          </li>
        </ul>

        <p>
          コンストラクタ引数（<code>Params...</code>）は、
          <code>bound</code> ブロック内からそのまま参照できる。
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // Pseudo:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe 定義</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  入力データの型;
  out: 出力データの型;

  bound(input, output) {
    // パイプ同士の結合や、中継・変換処理
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> はパイプ名。</li>
          <li><code>in</code> は「上流」から受け取るデータの型。</li>
          <li><code>out</code> は「下流」へ流すデータの型。</li>
          <li><code>bound(input, output)</code> では、
            <code>input</code> から <code>output</code> へデータを流す実装を書く。
          </li>
        </ul>

        <p class="note">
          Pipe 定義は、外部世界との接続（ソケット・HTTP）や、
          型の異なるストリームの橋渡し（テキスト→JSON など）を表現する用途を想定している。
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON テキスト
  out: T;        // デコードされたオブジェクト

  bound(input, output) {
    // Pseudo:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter 定義</h4>

        <pre><code>filter FilterName(Params...) {
  in:  入力データの型;
  out: 出力データの型;

  bound(input, output) {
    // フィルタ結合時の処理
    // input から output へどのように要素を流すかを記述
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> はフィルタ名。</li>
          <li><code>in</code> / <code>out</code> にはこのフィルタが扱う入出力型を指定する。</li>
          <li>Pipe / Filter モデルにおける「中間フィルタ」の場合、
            <code>in</code> / <code>out</code> はどちらも <code>Pipe&lt;*&gt;</code> になる。
          </li>
          <li><code>bound(input, output)</code> では、
            <code>input</code> から <code>output</code> への変換処理を書く。
          </li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // Pseudo:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // Pseudo:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer 定義</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: 入力データの型;

  bound(input) {
    // パイプライン終端で実行される処理
    // input をすべて消費し、何かしらの値を return する
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> はコンシューマ名。</li>
          <li><code>in</code> には、この consumer が受け取るデータの型を指定する。
            Pipe / Filter モデルでは、<strong>通常は <code>Pipe&lt;T&gt;</code> を指定する</strong>。
          </li>
          <li><code>bound(input)</code> は、パイプライン終端に結合されたときに実行される本体で、
            <code>input</code> を最後まで消費し、任意の型 <code>R</code> の値を <code>return</code> する。
          </li>
          <li><code>R</code> は <code>T[]</code> / <code>Int</code> / <code>Bool</code> / <code>Unit</code> など任意だが、
            <strong><code>Pipe&lt;*&gt;</code> であってはならない</strong>。
          </li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // Pseudo:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // Pseudo:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          まとめると、Pipe 系宣言は次のような役割を持つ：
          <ul>
            <li><strong>producer</strong>：外部世界 → <code>Pipe&lt;*&gt;</code>（必ず <code>Pipe</code> を出力）</li>
            <li><strong>pipe</strong>：型の異なるストリーム同士や外部 I/O の橋渡し</li>
            <li><strong>filter</strong>：主に <code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code> の変換ロジック</li>
            <li><strong>consumer</strong>：<code>Pipe&lt;T&gt;</code> → 任意の非 <code>Pipe</code> 型（パイプ世界からの出口）</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 パイプ演算子 <code>|&gt;</code></h3>

        <h4>6.4.1 言語レベルの定義</h4>
        <p>
          Aloe の <code>|&gt;</code> は、<strong>単なる関数合成の糖衣構文</strong>として定義される。
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>は、次と完全に等価である：</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li><code>F</code> の型が <code>A -&gt; B</code>,
              <code>G</code> の型が <code>B -&gt; C</code> であれば、
              <code>Expr |&gt; F |&gt; G</code> の型は <code>C</code> となる。
          </li>
          <li><code>Pipe&lt;T&gt;</code> に限らず、あらゆる型に対して適用可能である。</li>
        </ul>

        <div class="note">
          したがって、<strong>言語の型システムとしては</strong><br />
          「途中で戻り値の型が変わる」ことは何ら問題ではない。<br />
          Pipe / Filter モデルの制約は、<strong>ライブラリ設計（<code>Pipe&lt;T&gt;</code> と Pipe 系宣言）</strong>で与えられる。
        </div>

        <h4>6.4.2 Pipe&lt;T&gt; と組み合わせた使用</h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>: Producer（<code>String -&gt; Pipe&lt;String&gt;</code>）</li>
          <li><code>Where</code>, <code>Map</code>: Transformer（<code>Pipe&lt;T&gt; -&gt; Pipe&lt;U&gt;</code>）</li>
          <li><code>ToArray</code>: Consumer（<code>Pipe&lt;User&gt; -&gt; User[]</code>）</li>
          <li>パイプ式全体の型は最後の <code>ToArray</code> の戻り値型 <code>User[]</code> となる。</li>
        </ul>

        <p class="warning">
          <strong>注意：</strong><br />
          Consumer を挟んだ後もさらに <code>|&gt;</code> でチェーンすることは
          言語仕様上は可能だが、ほとんどの場合スタイルとして推奨されない。<br />
          例えば <code>ToArray() |&gt; ToArray()</code> のような記述は避けるべきである。
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 標準フィルタ・プロデューサ例</h3>

        <h4>6.5.1 代表的な transformer（filter）</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: T -&gt; Bool) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: T -&gt; U) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 代表的な producer</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 代表的な consumer</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // T[] を返す
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;
  bound(input) { ... }   // Int を返す
}</code></pre>

        <h4>6.5.4 使用例</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with 構文</h2>

      <h3>7.1 概要</h3>
      <p>
        <code>with</code> 構文は、特定のオブジェクトに対する
        連続したプロパティ設定やメソッド呼び出しを簡潔に書くための構文糖衣である。
        さらに Aloe では、<strong>with 対象オブジェクトの寿命をブロック内で保証する「解放ロック」</strong>
        としても機能する。
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 意味</h3>
      <p>
        上記の <code>with</code> ブロックは、表面的な意味としては次と等価である：
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> の <code>Expr</code> は 1 回だけ評価される。</li>
        <li>ブロック内の単純識別子への代入式は、すべて対象オブジェクトのメンバーへのアクセスとして解釈される。</li>
      </ul>

      <h3>7.3 解放ロック（GC ルートとしての動作）</h3>
      <p>
        AloeVM は参照カウンタ＋スライディングコンパクションによるメモリ管理を想定しており、
        <code>with</code> ブロックは次のような「解放ロック」として振る舞う：
      </p>
      <ul>
        <li><code>with (Expr)</code> の評価結果は、隠し変数（GC ルート）として保存される。</li>
        <li>その隠し変数は <strong>ブロックを抜けるまで GC による解放対象から除外される</strong>。</li>
        <li>したがって、with ブロックの実行中は、対象オブジェクトが必ず生存していることが保証される。</li>
      </ul>

      <h3>7.4 with と delete の関係</h3>
      <ul>
        <li><strong>with の対象として使用した変数（上の例では <code>Request</code>）に対して、
          同じ with ブロック内で <code>delete</code> を適用することはコンパイルエラー</strong> とする。
        </li>
        <li>理由：with は「このオブジェクトはここでは生きていてほしい」という意図を表す構文であり、
          その対象を delete するのは意味的に矛盾するため。
        </li>
        <li>一方、同じオブジェクトを参照している別の変数に対して
          <code>delete</code> を行うことは許可される（with によって GC ルートが 1 本残っているため）。</li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request は with に守られているので、ブロック中は必ず生存している

  delete Alias;   // OK: Alias からの参照だけを切る
  Url = "https://example.com/api";  // 依然として利用可能
}

// ここで with の GC ルートが外れ、他に参照が無ければ
// いつか GC によって解放される</code></pre>

      <p class="note">
        まとめると、<code>with</code> は
        <strong>「見た目はプロパティ設定の糖衣」かつ「対象オブジェクトを一時的に GC から保護するロック」</strong>
        として機能する。
      </p>
    </section>

    <section id="delete">
      <h2>8. delete 構文</h2>

      <h3>8.1 概要</h3>
      <p>
        Aloe の <code>delete</code> は、<strong>オブジェクト破棄そのものではなく、
        「変数からの参照を切る」ための構文</strong>である。
      </p>
      <ul>
        <li>実際のオブジェクト破棄（メモリ解放・ファイナライザなど）は
          <strong>ランタイム（AloeVM）の参照カウンタ＋GC</strong> によって行われる。
        </li>
        <li><code>delete</code> は「この変数からはもうこのオブジェクトを使わない」という意図を
          型安全に表現するための仕組みであり、<code>null</code> 代入の代替として位置づけられる。
        </li>
      </ul>

      <h3>8.2 文法</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 静的ルール（コンパイル時）</h3>
      <ul>
        <li><code>Identifier</code> は、そのスコープ内で宣言されている変数でなければならない。</li>
        <li><strong><code>delete</code> を実行した位置以降、その変数を
          読み取り・メンバアクセス・メソッド呼び出しに使用することはコンパイルエラー</strong> とする。
        </li>
        <li>ただし、<strong>再代入して新しい値を代入することは許可される</strong>。
          すなわち、<code>delete</code> は「その変数をいったん未初期化状態に戻す」と見なす。
        </li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Buf を使った処理
DoSomething(Buf);

delete Buf;

// ここから先、Buf を右辺で読むのはコンパイルエラー
// Buf.Length もコンパイルエラー

Buf = NewBuffer();  // 再代入すれば、ここから先は再び利用可能</code></pre>

      <h3>8.4 実行時の意味</h3>
      <p>
        <code>delete Var;</code> が実行されると、VM レベルでは概ね次のように扱われる：
      </p>
      <ul>
        <li>変数 <code>Var</code> が現在指しているオブジェクトへの参照を 1 つ減らす
          （参照カウンタ方式を想定）。</li>
        <li>変数 <code>Var</code> 自身は「未初期化／deleted」状態としてマークされる。</li>
        <li>参照カウンタが 0 になったオブジェクトは、GC のタイミングで解放される。
          <strong><code>delete</code> 実行時に即座にオブジェクトが破棄されるとは限らない</strong>。
        </li>
      </ul>

      <p class="note">
        Aloe 言語仕様としては、<strong>オブジェクト破棄のタイミングは VM・ランタイムの責務</strong>であり、
        <code>delete</code> はあくまで「1 つの変数からの参照を切る」だけである。
      </p>

      <h3>8.5 with 構文との関係</h3>
      <ul>
        <li>7.4 節で述べた通り、<strong>with の対象となっている変数そのものに対して、
          with ブロック内で <code>delete</code> を適用することはコンパイルエラー</strong> とする。
        </li>
        <li>同一オブジェクトを参照する別の変数に対して <code>delete</code> を適用することは許可される。
          with が GC ルートとして対象オブジェクトを保護するためである。
        </li>
      </ul>

      <p class="note">
        将来的に「所有権付きリソース型」などを導入する場合、
        <code>delete</code> がその所有権モデルと連携する可能性はあるが、
        本ドラフトでは <strong>所有権モデルを導入しない前提</strong>で定義している。
      </p>
    </section>

    <section id="lock">
      <h2>9. lock 構文と同期</h2>

      <h3>9.1 概要</h3>
      <p>
        <code>lock</code> 構文は、特定のオブジェクトをロックし、
        そのロック区間中に排他制御や GC の read barrier 最適化を行うための構文である。
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 意味</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> は、<code>Expr</code> で示されるロック対象に対し、
          その区間で排他アクセスを保証する。</li>
        <li>ロックの取得・解放は VM 側で行われる。</li>
        <li>スレッド間共有データに対する更新は、基本的に <code>lock</code> 内に限定することを推奨する。</li>
      </ul>

      <p class="note">
        AloeVM はスライディングコンパクション方式のメモリ管理を想定しており、
        <code>lock</code> ブロック内では同一オブジェクトに対する read barrier チェックを
        可能な限り 1 回に抑える最適化が実装されることを想定する。
      </p>
    </section>

    <section id="exceptions">
      <h2>10. 例外処理</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li><code>try</code> ブロック内で発生した例外は、対応する <code>catch</code> で捕捉できる。</li>
        <li><code>finally</code> ブロックは、例外の有無にかかわらず必ず実行される。</li>
        <li>例外型や階層の詳細は VM 仕様書側で定義される。</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. 実行モデルとメモリ管理</h2>

      <h3>11.1 AloeVM の概要</h3>
      <ul>
        <li>スタックベースのバイトコード VM。</li>
        <li>関数呼び出しはフレームを積む形で実装される。</li>
        <li>GC は参照カウンタ＋スライディングコンパクション方式を想定。</li>
      </ul>

      <h3>11.2 メモリ管理（概要）</h3>
      <ul>
        <li>オブジェクトはヒープ上に確保される。</li>
        <li>一定条件で GC が発動し、生存オブジェクトをスライドさせながらコンパクションする。</li>
        <li><code>with</code> 構文は一時的な GC ルートとしてオブジェクトを保護し、
          <code>lock</code> 構文と組み合わせることで read barrier の回数を削減する最適化を行うことができる。
        </li>
        <li>プログラマは通常、メモリ解放のために <code>delete</code> を使用する必要はなく、
          参照を切る意図を明示したいときに限って利用すればよい。
        </li>
      </ul>

      <p class="small">
        詳細なオペコード一覧および GC 実装仕様は AloeVM 仕様書にて扱う。
      </p>
    </section>

    <section id="limits">
      <h2>12. 制限事項と今後の拡張</h2>

      <h3>12.1 現時点の制限</h3>
      <ul>
        <li>ジェネリクスの表現力は最低限（型クラスや高階ジェネリクスは未定義）。</li>
        <li>モジュールシステムやパッケージ管理は本仕様書では扱わない。</li>
        <li>メタプログラミング機能（マクロ・リフレクションなど）は未定義。</li>
      </ul>

      <h3>12.2 今後の検討課題</h3>
      <ul>
        <li>Pipe / Filter の並列化・fusion 最適化。</li>
        <li>Wasm コンポーネントモデルとの連携仕様。</li>
        <li>エラー処理と Result 型的な表現（例外以外のエラーハンドリング）。</li>
        <li>分散処理やストリーム処理向けの標準ライブラリ拡張。</li>
        <li><code>delete</code> と所有権付きリソース型の統合設計（必要になった場合）。</li>
        <li>trait / interface / sealed とパターンマッチの統合（網羅性チェックなど）。</li>
      </ul>

      <p class="note">
        本ドラフトは特に、
        <strong>Pipe / Filter と Producer / Transformer / Consumer / Pipe / Consumer の関係、</strong>
        ならびにそれらの宣言構文に加え、
        <strong>with / delete / lock / class 継承 / generics の振る舞いと AloeVM のメモリ管理モデルとの関係</strong>
        を明確化するために更新された版である。
      </p>
    </section>

  </main>
</div>
</body>
</html>


なので「ジェネリクスどこ行った問題」は、↑の 4.6 節＋キーワードテーブルの `where` 追加で復活させました。もし元のジェネリクス節で入れていた細かい文言で「これも戻したい」というのがあれば、それも足します。
