
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Aloe 言語仕様書（ドラフト – パイプ／フィルタ／producer／consumer + delete/with/lock/クラス継承/ジェネリクス/event）</title>
  <meta name="last-updated" content="2025-11-30T12:00:00+09:00" />
  <style>
    /* レイアウトのみ最低限。フォントはブラウザ標準に任せる */
    body {
      margin: 0;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 320px;
      background: #111827;
      color: #e5e7eb;
      padding: 1.2rem 1rem;
      box-sizing: border-box;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1rem;
      margin: 0 0 0.25rem;
    }
    .sidebar .tagline {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }
    .sidebar .updated {
      font-size: 0.7rem;
      color: #9ca3af;
      margin-bottom: 0.8rem;
    }
    .sidebar nav a {
      display: block;
      font-size: 0.85rem;
      padding: 0.15rem 0;
      color: #d1d5db;
      text-decoration: none;
    }
    .sidebar nav a:hover {
      color: #ffffff;
      text-decoration: underline;
    }
    .sidebar nav .section-title {
      margin-top: 0.7rem;
      font-size: 0.8rem;
      font-weight: bold;
      color: #9ca3af;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem;
      box-sizing: border-box;
      max-width: 1100px;
    }
    h1, h2, h3, h4 {
      margin-top: 1.6em;
    }
    h1 {
      font-size: 1.6rem;
    }
    h2 {
      font-size: 1.3rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.3rem;
    }
    h3 {
      font-size: 1.1rem;
    }
    code {
      font-family: Consolas, Menlo, Monaco, monospace;
      font-size: 0.9em;
      background: #f3f4f6;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
    }
    pre {
      background: #111827;
      color: #e5e7eb;
      padding: 0.75rem 0.9rem;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul, ol {
      padding-left: 1.3rem;
    }
    table {
      border-collapse: collapse;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.3rem 0.5rem;
    }
    th {
      background: #f3f4f6;
    }
    .note {
      background: #fef3c7;
      border-left: 4px solid #f59e0b;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .warning {
      background: #fee2e2;
      border-left: 4px solid #ef4444;
      padding: 0.4rem 0.6rem;
      margin: 0.7rem 0;
      font-size: 0.9rem;
    }
    .small {
      font-size: 0.85rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>Aloe 言語仕様書</h1>
    <div class="tagline">ドラフト / Pipe, Filter, Producer, Consumer + delete/with/lock/クラス継承/ジェネリクス/event</div>
    <div class="updated">最終更新: 2025-11-30 12:00:00</div>
    <nav>
      <div class="section-title">概要</div>
      <a href="#intro">1. はじめに</a>
      <a href="#goals">2. 設計目標</a>

      <div class="section-title">言語の基本</div>
      <a href="#syntax">3. 基本文法</a>
      <a href="#types">4. 型システム</a>
      <a href="#classes">4.5 クラスと継承</a>
      <a href="#generics">4.6 ジェネリクス</a>
      <a href="#functions-methods">5. 関数とメソッド</a>

      <div class="section-title">パイプ / コレクション</div>
      <a href="#pipe-overview">6. Pipe / Filter モデル</a>
      <a href="#pipe-type">6.1 Pipe&lt;T&gt; 型</a>
      <a href="#pipe-roles">6.2 Producer / Transformer / Consumer</a>
      <a href="#pipe-defs">6.3 パイプ関連宣言</a>
      <a href="#pipe-operator">6.4 パイプ演算子 <code>|&gt;</code></a>
      <a href="#pipe-std">6.5 標準 Filter / Producer</a>

      <div class="section-title">構文拡張</div>
      <a href="#with">7. with 構文</a>
      <a href="#delete">8. delete 構文</a>
      <a href="#lock">9. lock 構文と同期</a>

      <div class="section-title">制御 / 実行時モデル</div>
      <a href="#exceptions">10. 例外処理</a>
      <a href="#runtime">11. 実行モデルとメモリ管理</a>

      <div class="section-title">イベント</div>
      <a href="#event">13. event 構文とイベントモデル</a>

      <div class="section-title">その他</div>
      <a href="#limits">12. 制限事項と今後の展望</a>
    </nav>
  </aside>
  <main class="content">

    <section id="intro">
      <h1>1. はじめに</h1>
      <p>
        Aloe は、静的型付け・シンプルな文法・スタックベースの仮想マシン（AloeVM）を持つ
        実験的なプログラミング言語である。
        特に <strong>Pipe / Filter 形式のデータフロー</strong> と WebAssembly との相互運用性を重視して設計されている。
      </p>
      <ul>
        <li>静的型付け（コンパイル時に型チェックを行う）</li>
        <li>C 系の見た目の構文だが、機能セットは意図的に小さくしている</li>
        <li>テキスト処理、REST 呼び出し、ログ処理など、<br />「データの流れと変換」を気持ちよく書けることを重視</li>
        <li>スタックベース VM（AloeVM）および将来の WebAssembly バックエンドを前提にしている</li>
      </ul>
      <p class="note">
        本ドキュメントは <strong>言語仕様のドラフト</strong> である。<br />
        実際のコンパイラ／VM 実装とは差異が存在する可能性がある。
      </p>
    </section>

    <section id="goals">
      <h2>2. 設計目標</h2>
      <h3>2.1 目標</h3>
      <ul>
        <li><strong>可読性</strong>：仕様書そのものがドキュメントとして読めること。</li>
        <li><strong>実装容易性</strong>：小さなコンパイラと VM で実装できること。</li>
        <li><strong>Pipe / Filter の一貫性</strong>：型安全なデータフロー表現。</li>
        <li><strong>Wasm への橋渡し</strong>：将来の Wasm コンポーネントモデルと接続しやすいこと。</li>
      </ul>

      <h3>2.2 非目標</h3>
      <ul>
        <li>「なんでもできる」汎用言語になること。</li>
        <li>高度に最適化された JIT コンパイラと性能面で競うこと。</li>
        <li>複雑なメタプログラミング（マクロ等）は現在の範囲外とする。</li>
      </ul>
    </section>

    <section id="syntax">
      <h2>3. 基本文法</h2>

      <h3>3.1 ソースファイル</h3>
      <ul>
        <li>ソースファイルは UTF-8 エンコードを想定する。</li>
        <li>1 行コメント: <code>// comment</code></li>
        <li>複数行コメント: <code>/* ... */</code></li>
      </ul>

      <h3>3.2 トークン</h3>
      <ul>
        <li>識別子: 先頭は英字または <code>_</code>、以降は英字・数字・<code>_</code>。</li>
        <li>キーワードは予約語であり、識別子として使用できない。</li>
      </ul>

      <h3>3.3 代表的なキーワード</h3>
      <table>
        <tr><th>カテゴリ</th><th>キーワード</th></tr>
        <tr>
          <td>宣言</td>
          <td><code>let</code>, <code>var</code>, <code>type</code>, <code>struct</code>, <code>enum</code>, <code>class</code>, <code>interface</code>, <code>trait</code>, <code>sealed</code></td>
        </tr>
        <tr>
          <td>制御</td>
          <td><code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>lock</code></td>
        </tr>
        <tr>
          <td>関数</td>
          <td><code>method</code></td>
        </tr>
        <tr>
          <td>補助</td>
          <td><code>with</code>, <code>delete</code>, <code>clone</code>, <code>where</code></td>
        </tr>
      </table>

      <h3>3.4 文と式</h3>
      <ul>
        <li>多くの文はセミコロン <code>;</code> で終わる。</li>
        <li>ブロックは <code>{ ... }</code> で囲む。</li>
        <li>制御構文の条件式は <code>Bool</code> 型でなければならない。</li>
      </ul>

      <pre><code>// 変数宣言
let Threshold: Int = 10;
var Count: Int = 0;

// if 文
if (Count &gt; Threshold) {
  Print("over");
} else {
  Print("ok");
}</code></pre>
    </section>

    <section id="types">
      <h2>4. 型システム</h2>

      <h3>4.1 プリミティブ型</h3>
      <table>
        <tr><th>型</th><th>説明</th></tr>
        <tr><td><code>Bool</code></td><td><code>true</code> / <code>false</code></td></tr>
        <tr><td><code>Int</code></td><td>符号付き整数（ビット幅は実装依存。ここでは 32 ビットを想定）</td></tr>
        <tr><td><code>Float</code></td><td>浮動小数点数（32 または 64 ビット、実装依存）</td></tr>
        <tr><td><code>String</code></td><td>UTF-8 文字列（内部表現は実装依存）</td></tr>
      </table>

      <h3>4.2 配列とコレクション</h3>
      <ul>
        <li>固定長配列: <code>T[]</code></li>
        <li>可変長かつ遅延評価の列は <code>Pipe&lt;T&gt;</code> を使用する（詳細は 6 章）。</li>
      </ul>

      <h3>4.3 struct</h3>
      <pre><code>struct User {
  Id: Int;
  Name: String;
  IsActive: Bool;
}</code></pre>
      <ul>
        <li><code>struct</code> は値型であり、代入は値のコピーになる。</li>
        <li>コピーは浅いコピーであり、ネストした参照型フィールドの共有などは VM 実装に依存する。</li>
        <li>struct は最大 1 つの別の struct から継承してもよい（struct の単一継承）。</li>
        <li>struct が <code>interface</code> を実装することは<strong>禁止</strong>される。
          （trait やジェネリック制約にどう関与させるかは今後の仕様で補足する。）
        </li>
      </ul>

      <h3>4.4 enum</h3>
      <ul>
        <li><code>enum</code> は常に内部的には <strong><code>Int</code></strong> として表現される。</li>
        <li><code>enum&lt;String&gt;</code> や <code>enum&lt;Byte&gt;</code> のような「ジェネリック enum」は
          <strong>禁止</strong>される。
        </li>
        <li>ビットフラグ用途の enum は最大 32 個までのフラグに制限される。</li>
      </ul>

      <pre><code>enum LogLevel {
  Trace = 0;
  Debug = 1;
  Info  = 2;
  Warn  = 3;
  Error = 4;
}</code></pre>
    </section>

    <section id="classes">
      <h2>4.5 クラスと継承（class / interface / trait / sealed）</h2>

      <h3>4.5.1 クラスの基本</h3>
      <ul>
        <li><code>class</code> は常に <strong>ヒープ確保される参照型</strong> である。</li>
        <li>代入は <strong>参照のコピー（浅いコピー）</strong> を行う。</li>
        <li><code>clone</code> キーワードは、オブジェクトの浅いコピーを作成し、新しい参照を返す。</li>
        <li>すべてのクラスは<strong>clone 可能</strong>であり、「clone 不可」を型レベルで宣言する手段は提供しない。<br />
          clone の禁止や注意事項を表現したい場合は API 設計やコーディング規約で対応する。
        </li>
      </ul>

      <pre><code>class User {
  Name: String;
  Age: Int;
}

var A: User = NewUser();
var B: User = A;        // 参照コピー（A と B は同じインスタンスを指す）

var C: User = clone A;  // 浅いコピーされた新しいインスタンスへの参照を返す</code></pre>

      <p class="note">
        <strong>浅いコピー</strong> とは「フィールドの値をそのままコピーする」ことを意味する。<br />
        フィールド自体が参照型である場合、その参照値がコピーされる。
        深いコピーや独自の複製ロジックが必要な型は、<code>Clone</code> メソッドなどのユーザー定義 API を
        <code>clone</code> の上に追加することで表現できる。
      </p>

      <h3>4.5.2 共通基底クラス Object と ToString / Dump</h3>
      <p>
        Aloe のすべてのクラス型は、暗黙に共通基底クラス <code>Object</code> を継承する。
        （ユーザーが明示的に <code>: Object</code> と書く必要はない。）
      </p>
      <ul>
        <li>
          <code>Object</code> は参照型のルートであり、次のメソッドを提供する：
          <ul>
            <li><code>method ToString(): String</code></li>
            <li><code>method Dump(): String</code></li>
          </ul>
        </li>
        <li>
          <code>ToString()</code> の既定実装は、そのインスタンスの<strong>型名</strong>を返す。<br />
          クラスは必要に応じてこれを override し、人間が読みやすい文字列表現を返してもよい。
        </li>
        <li>
          <code>Dump()</code> の既定実装は、そのインスタンスの<strong>デバッグ向け表現</strong>を返す。
          具体的な文字列表現は実装依存とするが、クラスはフィールド内容などを含めた詳細なダンプを行うよう
          override してもよい。
        </li>
        <li>
          <code>Dump()</code> は、組み込み consumer <code>dump</code>（6.5.3 節）から呼び出されることを前提とした
          「var_dump 相当」の文字列生成用途を想定している。
        </li>
      </ul>

      <h3>4.5.3 クラス継承（単一継承）</h3>
      <p>
        Aloe の <code>class</code> は <strong>単一継承</strong> のみをサポートする。<br />
        つまり、クラスが指定できる基底クラスはちょうど 1 つである。
      </p>

      <pre><code>class Base {
  Id: Int;
}

class Derived : Base {
  Name: String;
}

// 以下はコンパイルエラー（クラスの多重継承は禁止）
class Bad : Base, OtherBase {
}</code></pre>

      <ul>
        <li>クラス階層は木（あるいは鎖）の構造を取り、ダイヤモンド継承は発生しない。</li>
        <li>クラス継承は状態と振る舞いの再利用のためのメカニズムである。</li>
      </ul>

      <h3>4.5.4 interface と trait</h3>
      <p>
        クラスに対して多重継承を許可する代わりに、
        Aloe では <strong>interface</strong> と <strong>trait</strong> を使って振る舞いの合成を行う。
      </p>

      <ul>
        <li><code>interface</code> はメソッドシグネチャのみを定義し、実装は持たない
          （デフォルト実装を許可するかどうかは今後の検討事項）。
        </li>
        <li><code>trait</code> はメソッド実装を持てるミックスイン単位であり、
          既存のクラスに振る舞いを追加するために用いる。
        </li>
        <li>クラスは <strong>1 つの基底クラス</strong> を持ち、複数の <code>interface</code> を実装し、
          複数の <code>trait</code> を <code>with</code> で適用できる。
        </li>
      </ul>

      <pre><code>interface IDisposable {
  method Dispose();
}

trait Printable {
  method PrintSelf() {
    Print(this.ToString());
  }
}

class FileHandle : BaseFile implements IDisposable with Printable {
  method Dispose() {
    // リソース解放処理
  }

  method ToString(): String {
    return "FileHandle(...)";
  }
}</code></pre>

      <p class="note">
        <code>interface</code> と <code>trait</code> の詳細な文法やルール
        （継承、複数の trait で同じメソッドが定義されたときの衝突解決など）は
        本ドラフトでは完全には定義しない。ここでは方向性のみを示す。
      </p>

      <h3>4.5.5 sealed クラス</h3>
      <p>
        特定のクラスからの継承を禁止するために、Aloe は <code>sealed</code> 修飾子を提供する。
      </p>

      <pre><code>sealed class Token {
  Kind: TokenKind;
  Text: String;
}

// これはコンパイルエラー（Token は sealed）
class KeywordToken : Token {
}</code></pre>

      <ul>
        <li><code>sealed class</code> は基底クラスとして使用できない。</li>
        <li><code>sealed</code> であっても、そのクラスが interface を実装したり、
          <code>with</code> によって trait を適用することは可能である。
        </li>
        <li>将来的には、sealed クラスと union／パターンマッチを組み合わせて、
          網羅性チェックをサポートすることを検討している。
        </li>
      </ul>

      <h3>4.5.6 readonly とクラス</h3>
      <ul>
        <li>クラスのフィールドはデフォルトで可変である。</li>
        <li>フィールドに <code>readonly</code> 修飾子を付けると、そのフィールドは不変になる：
          <ul>
            <li>そのフィールドへの代入は
              <strong>フィールド初期化子</strong> または
              <strong>同じクラスのコンストラクタ内</strong> でのみ許可される。
            </li>
            <li>それ以外の場所からの代入はコンパイルエラーとなる。</li>
          </ul>
        </li>
        <li><code>readonly class</code> はクラス全体を論理的にイミュータブルにする：
          <ul>
            <li>すべてのインスタンスフィールドは暗黙的に <code>readonly</code> と同等に扱われる。</li>
            <li>フィールドへの代入はフィールド初期化子と、そのクラスのコンストラクタ内にのみ許される。</li>
            <li>コンストラクタの完了後は、そのインスタンスのフィールドを書き換えるコードは
              どこからも許可されない。
            </li>
          </ul>
        </li>
        <li><code>readonly</code> と <code>clone</code> は直交している：
          <code>readonly class</code> であっても <code>clone</code> によって複製できる。
          clone の結果は、同じ不変状態を持つ別インスタンスである。
        </li>
      </ul>

      <p class="small">
        本セクションでは、クラスはヒープ上の参照型で単一継承のみをサポートし、
        複数の振る舞いは interface + trait で合成し、sealed によって継承禁止を表現し、
        <code>readonly</code> によってフィールド単位またはクラス全体のイミュータビリティを表現するという、
        高レベルな方針を定める。<br />
        メソッド解決順序や trait の衝突解決の詳細は別途仕様化する。
      </p>
    </section>

    <section id="generics">
      <h2>4.6 ジェネリクス</h2>

      <h3>4.6.1 概要</h3>
      <p>
        Aloe は、型・関数・メソッド・パイプ関連宣言に対して最小限のジェネリクス機構を提供する。<br />
        目的は、コレクションや Pipe / Filter を型安全に再利用可能にすることであり、
        高度な型レベル計算をサポートすることではない。
      </p>

      <pre><code>type Box&lt;T&gt; {
  Value: T;
}

struct Pair&lt;TLeft, TRight&gt; {
  Left: TLeft;
  Right: TRight;
}

method Map&lt;T, U&gt;(Source: Pipe&lt;T&gt;, Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; {
  // 実装は省略
}</code></pre>

      <h3>4.6.2 ジェネリック型パラメータ</h3>
      <ul>
        <li>型、struct、class、interface、trait、method、
          および producer/filter/consumer 宣言は <code>&lt;T, U, ...&gt;</code> で型パラメータを受け取れる。
        </li>
        <li>型パラメータ名は一般的に大文字で始めることが推奨される
          （<code>T</code>, <code>TItem</code>, <code>TKey</code> など）。
        </li>
        <li>型引数は利用箇所で具体的な型に束縛される。</li>
      </ul>

      <pre><code>type List&lt;T&gt; {
  Items: T[];
}

method FirstOrDefault&lt;T&gt;(Source: Pipe&lt;T&gt;): T {
  // 実装は省略
}</code></pre>

      <h3>4.6.3 where 型制約（概要）</h3>
      <p>
        Aloe のジェネリクスは、<code>where</code> 句を用いた任意の型制約をサポートする。<br />
        デフォルトは制約なしだが、バージョン 0.1 の段階でいくつかの基本的な制約をサポートする。
      </p>

      <pre><code>method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  // Int 専用の合計処理
}</code></pre>

      <p class="note">
        ここでの <code>where</code> は純粋に <strong>コンパイル時の型チェック</strong> のためだけに存在する。<br />
        実行時表現（モノモーフィック展開か、型タグを持つ共有コードかなど）は VM 仕様に委ねられる。
      </p>

      <h3>4.6.4 サポートされる制約の種類</h3>
      <p>
        バージョン 0.1 では、以下の種類の制約をサポートする：
      </p>

      <ul>
        <li><strong>値型 / 参照型 制約</strong>
          <ul>
            <li><code>where T: struct</code> – <code>T</code> は値型でなければならない。</li>
            <li><code>where T: class</code> – <code>T</code> は参照型でなければならない。</li>
          </ul>
        </li>
        <li><strong>プリミティブ型制約</strong>
          <ul>
            <li><code>where T: Int</code>, <code>where T: Float</code>, <code>where T: Bool</code> など、
              プリミティブ型名を直接指定できる。
            </li>
          </ul>
        </li>
        <li><strong>ユーザー定義型制約</strong>
          <ul>
            <li><code>where T: SomeTrait</code> – trait <code>SomeTrait</code> を実装している型。</li>
            <li><code>where T: MyStruct</code> – struct <code>MyStruct</code> とちょうど同じ型。</li>
            <li><code>where T: MyClass</code> – class <code>MyClass</code> とちょうど同じ型。</li>
          </ul>
        </li>
        <li><strong>任意の具体型名</strong>
          <ul>
            <li>既存の具体型名であれば何でも指定できる（例: <code>where T: Pipe&lt;Int&gt;</code>）。</li>
          </ul>
        </li>
      </ul>

      <pre><code>// 値型専用ジェネリック
method Zero&lt;T&gt;(): T
  where T: struct
{
  // 実装は省略
}

// Int 専用の Pipe
method Average&lt;T&gt;(Source: Pipe&lt;T&gt;): Float
  where T: Int
{
  // 実装は省略
}

// 特定の struct 型専用
method PrintUser&lt;T&gt;(User: T)
  where T: UserInfo
{
  // 実装は省略
}</code></pre>

      <h3>4.6.5 制約違反時の挙動</h3>
      <ul>
        <li>ジェネリック関数／型に与えた型引数が <code>where</code> の制約を満たさない場合、
          それはコンパイルエラーとなる。
        </li>
        <li>複数の制約が指定されている場合、それらすべてを同時に満たす必要がある。</li>
        <li>循環する制約や高度な typeclass 的構造は現時点ではサポートしない。</li>
      </ul>

      <pre><code>// コンパイルエラーの例:

// where T: Int なので、T は String にはできない
method Sum&lt;T&gt;(Source: Pipe&lt;T&gt;): T
  where T: Int
{
  ...
}

var Lines: Pipe&lt;String&gt; = ReadLines("log.txt");
var Result = Sum(Lines);  // &lt;-- コンパイルエラー</code></pre>

      <p class="small">
        ジェネリクスの内部表現（モノモーフィック展開か、型タグ付き共有コードか等）は AloeVM が定義する。<br />
        本言語仕様では、型安全な再利用と <code>where</code> ベースの制約チェックの振る舞いに焦点を当てる。
      </p>
    </section>

    <section id="functions-methods">
      <h2>5. 関数とメソッド</h2>

      <h3>5.1 method 宣言</h3>
      <pre><code>method Add(a: Int, b: Int): Int {
  return a + b;
}</code></pre>

      <ul>
        <li><code>method</code> はトップレベル関数、または型にバインドされたメソッドを定義する。</li>
        <li>戻り値を明示しない場合、そのメソッドは「戻り値なし」（void）として扱われる。</li>
        <li>Aloe には <code>Unit</code> 型は存在せず、戻り値なしは型としては表現されない。</li>
      </ul>

      <h3>5.2 bound によるメソッドバインディング</h3>
      <p>
        Aloe では、<code>bound</code> を用いて既存の型にメソッドを追加する。
      </p>

      <pre><code>type Pipe&lt;T&gt; {
  // 内部表現は VM 依存
}

bound Pipe&lt;T&gt; {
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; {
    // 実装は省略
  }
}</code></pre>

      <p class="note">
        <code>Pipe&lt;T&gt;</code> に対しては、<code>bound</code> ブロックで宣言されるメソッドの
        戻り値に関する<strong>制約</strong>を導入する（詳細は 6.2 を参照）。
      </p>

      <h3>5.3 関数型の表現（Func&lt;...:...&gt;）</h3>
      <p>
        Aloe では、関数型はすべて <code>Func&lt;...:...&gt;</code> 記法で表現する。
        <code>-&gt;</code> を用いた関数型表記は言語仕様として存在しない。
      </p>
      <ul>
        <li><code>Func&lt;T:U&gt;</code> は「引数 <code>T</code> を受け取り、<code>U</code> を返す関数」を表す。</li>
        <li><code>Func&lt;A, B:R&gt;</code> は「引数 <code>A</code> と <code>B</code> を受け取り、<code>R</code> を返す関数」を表す。</li>
        <li>戻り値なし（void）の関数は <code>Func&lt;T:&gt;</code> または <code>Func&lt;T:void&gt;</code> のように書ける。</li>
      </ul>
    </section>

    <section id="pipe-overview">
      <h2>6. Pipe / Filter モデル</h2>

      <p>
        Aloe の特徴的な点は、
        <strong>Pipe / Filter 形式のデータフロー</strong> を
        型安全かつ一貫したスタイルで表現できることである。
      </p>

      <pre><code>ReadLines("access.log")
  |&gt; Where (.StartsWith("[ERROR]"))
  |&gt; Map   (ParseLogLine)
  |&gt; Where (.Level == LogLevel.Error)
  |&gt; ToArray();</code></pre>

      <p>
        概念的には、上記は次のようなネストした呼び出しと等価である：
      </p>

      <pre><code>ToArray(
  Where(
    Map(
      Where(ReadLines("access.log"), ...),
      ...),
    ...));</code></pre>

      <p>Aloe の <code>|&gt;</code> 演算子は、このような関数合成のためのシンタックスシュガーである。</p>

      <section id="pipe-type">
        <h3>6.1 Pipe&lt;T&gt; 型</h3>

        <p>
          <code>Pipe&lt;T&gt;</code> は Aloe における「パイプ世界（pipe world）」を表し、
          遅延シーケンス・ストリーム・イテレータに相当する。
        </p>

        <ul>
          <li><code>Pipe&lt;T&gt;</code> は「要素型 <code>T</code> が流れるパイプ」を表す。</li>
          <li>内部表現（イテレータの連結、コルーチンなど）は VM 依存である。</li>
          <li>標準ライブラリは <code>Pipe&lt;T&gt;</code> を用いた producer / transformer / consumer を提供する。</li>
        </ul>

        <pre><code>type Pipe&lt;T&gt; {
  // 実装依存の内部フィールド
}</code></pre>

        <p class="note">
          <strong>パイプ世界</strong> とは、<code>Pipe&lt;T&gt;</code> を受け取り／返す関数群
          （producer / transformer / consumer）によって構成される領域を指す。<br />
          consumer はパイプ世界からの出口である。
        </p>
      </section>

      <section id="pipe-roles">
        <h3>6.2 Producer / Transformer / Consumer</h3>

        <p>
          Pipe / Filter モデルでは、関数やオブジェクトを次の 3 つの役割に分類する：
        </p>

        <h4>6.2.1 Producer</h4>
        <ul>
          <li><strong>定義</strong>：
            戻り値の型が <code>Pipe&lt;*&gt;</code> であり、パイプラインの先頭に現れる関数／オブジェクト。
          </li>
          <li><strong>役割</strong>：
            ファイル・HTTP・配列など外部世界からデータを読み取り、
            パイプ世界（<code>Pipe&lt;T&gt;</code>）に「流し込む」。
          </li>
          <li><strong>型</strong>：
            形としては <code>Func&lt;X:Pipe&lt;T&gt;&gt;</code> を取る。
            producer は常に <code>Pipe&lt;*&gt;</code> を出力するよう設計される。
          </li>
        </ul>

        <h4>6.2.2 Transformer（中間フィルタ）</h4>
        <ul>
          <li><strong>定義</strong>：
            型 <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code> を持つ関数／メソッド。</li>
          <li><strong>役割</strong>：
            パイプ世界の内部でデータを変換・フィルタ・ソートする。パイプ世界の外には出ない。
          </li>
        </ul>

        <p>
          Aloe では、<strong><code>bound Pipe&lt;T&gt;</code></strong> 内で定義されるメソッドは、
          原則として transformer（中間フィルタ）専用とする。
        </p>

        <div class="note">
          <strong>制約：</strong><br />
          <code>bound Pipe&lt;T&gt;</code> ブロック内で宣言されるメソッドは、<br />
          戻り値として <strong>必ず <code>Pipe&lt;*&gt;</code></strong> を返さなければならない。<br />
          つまり、型は <code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code> でなければならない。
        </div>

        <pre><code>bound Pipe&lt;T&gt; {
  // OK: transformer
  method Where(Predicate: Func&lt;T:Bool&gt;): Pipe&lt;T&gt; { ... }

  // OK: 要素型を変更する
  method Map&lt;U&gt;(Selector: Func&lt;T:U&gt;): Pipe&lt;U&gt; { ... }

  // NG: 戻り値が Pipe ではないため、コンパイルエラーとすべき
  // method Count(): Int { ... }
}</code></pre>

        <h4>6.2.3 Consumer（終端フィルタ）</h4>

        <ul>
          <li><strong>定義</strong>：
            型 <code>Func&lt;Pipe&lt;T&gt;:R&gt;</code> を持ち、<code>R</code> が <code>Pipe&lt;*&gt;</code> ではない関数／オブジェクト。
          </li>
          <li><strong>役割</strong>：
            パイプ世界から外部世界への出口として、パイプをすべて消費し、
            配列・スカラー値・外部 I/O といった形に変換する。
          </li>
          <li><strong>戻り値の型</strong>：
            <code>R</code> は <code>Pipe&lt;*&gt;</code> でない限り制約はない。
            <code>T[]</code>、<code>Int</code>、<code>Unit</code>、<code>Bool</code> など任意の型を取れる。
          </li>
        </ul>

        <pre><code>// パイプを配列に具現化する consumer
method ToArray&lt;T&gt;(Source: Pipe&lt;T&gt;): T[] { ... }

// 要素数を数える consumer
method Count&lt;T&gt;(Source: Pipe&lt;T&gt;): Int { ... }</code></pre>

      </section>

      <section id="pipe-defs">
        <h3>6.3 パイプ関連宣言（producer / pipe / filter / consumer）</h3>

        <p>
          Aloe は Pipe / Filter コンポーネントを構築するために、
          <strong>producer</strong>・<strong>pipe</strong>・<strong>filter</strong>・<strong>consumer</strong>
          の 4 種類の宣言形式を導入する。<br />
          これらはすべて「コンストラクタを持つオブジェクト」として扱われ、
          パイプラインに接続されたときにその <code>bound</code> ブロックが実行される。
        </p>

        <h4>6.3.1 producer 宣言</h4>

        <pre><code>producer ProducerName(Params...) {
  out: Pipe&lt;T&gt;;

  bound(output) {
    // Producer がパイプラインに接続されたときに実行される
    // 外部リソースからデータを読み取り、output に書き込む
  }
}</code></pre>

        <ul>
          <li><code>ProducerName</code> は producer の名前。</li>
          <li><code>out</code> はパイプ世界の <strong>出力型</strong> を指定する。
            これは必ず <code>Pipe&lt;*&gt;</code> 型でなければならない。
          </li>
          <li><code>bound(output)</code> はパイプライン接続時の振る舞いを定義する。
            <code>output</code> の型は <code>out</code> に指定した型（例: <code>Pipe&lt;T&gt;</code>）。
          </li>
        </ul>

        <p>
          コンストラクタ引数（<code>Params...</code>）は <code>bound</code> ブロックの中から参照できる。
        </p>

        <pre><code>producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;

  bound(output) {
    // 疑似コード:
    //   let file = OpenFile(Path);
    //   for each line in file:
    //     output.write(line);
    //   file.close();
  }
}</code></pre>

        <h4>6.3.2 pipe 宣言</h4>

        <pre><code>pipe PipeName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // パイプ同士をつなぎ、転送／変換処理を行う
  }
}</code></pre>

        <ul>
          <li><code>PipeName</code> は pipe の名前。</li>
          <li><code>in</code> は「上流」から入ってくる型。</li>
          <li><code>out</code> は「下流」に流す型。</li>
          <li><code>bound(input, output)</code> は <code>input</code> から <code>output</code> への
            変換処理を記述する。
          </li>
        </ul>

        <p class="note">
          pipe 宣言は、ソケット・HTTP などの外部リソースとの接続や、
          異なるストリーム型（テキスト → JSON など）の橋渡し用途を想定している。
        </p>

        <pre><code>pipe JsonDecode&lt;T&gt;() {
  in:  String;   // JSON テキスト
  out: T;        // デコードされたオブジェクト

  bound(input, output) {
    // 疑似コード:
    //   for each line in input:
    //     let obj: T = JsonParse&lt;T&gt;(line);
    //     output.write(obj);
  }
}</code></pre>

        <h4>6.3.3 filter 宣言</h4>

        <pre><code>filter FilterName(Params...) {
  in:  InputType;
  out: OutputType;

  bound(input, output) {
    // input から output への要素の流し方を定義する
  }
}</code></pre>

        <ul>
          <li><code>FilterName</code> は filter の名前。</li>
          <li><code>in</code> / <code>out</code> は入力と出力の型を指定する。</li>
          <li>Pipe / Filter 連鎖における中間フィルタでは、通常 <code>in</code> / <code>out</code> ともに
            <code>Pipe&lt;*&gt;</code> を取る。
          </li>
          <li><code>bound(input, output)</code> は両者の間の変換処理を記述する。</li>
        </ul>

        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;

  bound(input, output) {
    // 疑似コード:
    //   for each item in input:
    //     if (Predicate(item)):
    //       output.write(item);
  }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;

  bound(input, output) {
    // 疑似コード:
    //   for each item in input:
    //     output.write(Selector(item));
  }
}</code></pre>

        <h4>6.3.4 consumer 宣言</h4>

        <pre><code>consumer ConsumerName(Params...) {
  in: InputType;

  bound(input) {
    // パイプラインの末尾で実行される
    // input を消費し、何らかの値を返す
  }
}</code></pre>

        <ul>
          <li><code>ConsumerName</code> は consumer の名前。</li>
          <li><code>in</code> は入力の型を指定する。
            Pipe / Filter モデルにおいては、多くの場合 <strong><code>Pipe&lt;T&gt;</code></strong> となる。
          </li>
          <li><code>bound(input)</code> はパイプライン末尾で実行され、
            <code>input</code> を完全に消費し、任意の型 <code>R</code> の値を返す。
          </li>
          <li><code>R</code> は <code>T[]</code>・<code>Int</code>・<code>Bool</code>・<code>Unit</code> など任意の型を取れるが、
            <strong><code>Pipe&lt;*&gt;</code> であってはならない</strong>。
          </li>
        </ul>

        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // 疑似コード:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // 疑似コード:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}</code></pre>

        <p class="note">
          まとめると、パイプ関連宣言の役割は次のようになる：
          <ul>
            <li><strong>producer</strong>：外部世界 → <code>Pipe&lt;*&gt;</code>（常に <code>Pipe</code> を出力）</li>
            <li><strong>pipe</strong>：異種ストリーム間および外部 I/O との橋渡し</li>
            <li><strong>filter</strong>：主に <code>Pipe&lt;T&gt;</code> → <code>Pipe&lt;U&gt;</code> の変換</li>
            <li><strong>consumer</strong>：<code>Pipe&lt;T&gt;</code> → 非 <code>Pipe</code> 型（パイプ世界からの出口）</li>
          </ul>
        </p>

      </section>

      <section id="pipe-operator">
        <h3>6.4 パイプ演算子 <code>|&gt;</code></h3>

        <h4>6.4.1 言語レベルでの定義</h4>
        <p>
          Aloe の <code>|&gt;</code> は、<strong>単純な関数合成</strong> のためのシンタックスシュガーとして定義される。
        </p>

        <pre><code>Expr |&gt; F |&gt; G</code></pre>

        <p>は、正確には次と等価である：</p>

        <pre><code>G(F(Expr))</code></pre>

        <ul>
          <li><code>F</code> が型 <code>Func&lt;A:B&gt;</code> を持ち、<code>G</code> が型 <code>Func&lt;B:C&gt;</code> を持つとき、
            <code>Expr |&gt; F |&gt; G</code> の型は <code>C</code> になる。
          </li>
          <li>この演算子はあらゆる型に適用可能であり、<code>Pipe&lt;T&gt;</code> に限定されない。</li>
        </ul>

        <div class="note">
          したがって、型システムの観点からは、
          「パイプラインの途中で戻り値の型が変わる」こと自体は問題にならない。<br />
          Pipe / Filter モデルにおける制約は、
          <strong><code>Pipe&lt;T&gt;</code> とパイプ関連宣言によるライブラリ設計</strong> によって提供され、
          演算子そのものではない。
        </div>

        <h4>6.4.2 Pipe&lt;T&gt; と <code>|&gt;</code> の利用</h4>

        <pre><code>ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; Map   (ParseUser)
  |&gt; Where (.IsActive)
  |&gt; ToArray();</code></pre>

        <ul>
          <li><code>ReadLines</code>：producer（<code>Func&lt;String:Pipe&lt;String&gt;&gt;</code>）</li>
          <li><code>Where</code>・<code>Map</code>：transformer（<code>Func&lt;Pipe&lt;T&gt;:Pipe&lt;U&gt;&gt;</code>）</li>
          <li><code>ToArray</code>：consumer（<code>Func&lt;Pipe&lt;User&gt;:User[]&gt;</code>）</li>
          <li>パイプ式全体の型は <code>ToArray</code> の戻り値である <code>User[]</code> となる。</li>
        </ul>

        <p class="warning">
          <strong>注意:</strong><br />
          言語仕様上は、consumer の後にさらに <code>|&gt;</code> を続けてもよいが、
          スタイル的にはあまり推奨されない。<br />
          例えば <code>ToArray() |&gt; ToArray()</code> のようなパターンは避けるべきである。
        </p>
      </section>

      <section id="pipe-std">
        <h3>6.5 標準 Filter と Producer</h3>

        <h4>6.5.1 代表的な transformer（filter）</h4>
        <pre><code>filter Where&lt;T&gt;(Predicate: Func&lt;T:Bool&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}

filter Map&lt;T, U&gt;(Selector: Func&lt;T:U&gt;) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;U&gt;;
  bound(input, output) { ... }
}

filter Take&lt;T&gt;(Count: Int) {
  in:  Pipe&lt;T&gt;;
  out: Pipe&lt;T&gt;;
  bound(input, output) { ... }
}</code></pre>

        <h4>6.5.2 代表的な producer</h4>
        <pre><code>producer FromArray&lt;T&gt;(Items: T[]) {
  out: Pipe&lt;T&gt;;
  bound(output) { ... }
}

producer ReadLines(Path: String) {
  out: Pipe&lt;String&gt;;
  bound(output) { ... }
}</code></pre>

        <h4>6.5.3 代表的な consumer</h4>
        <pre><code>consumer ToArray&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var buffer: List&lt;T&gt;;
    // 疑似コード:
    //   for each item in input:
    //     buffer.add(item);
    //   return buffer.toArray();
    return buffer.toArray();
  }
}

consumer Count&lt;T&gt; {
  in: Pipe&lt;T&gt;;

  bound(input) {
    var c: Int = 0;
    // 疑似コード:
    //   for each item in input:
    //     c = c + 1;
    //   return c;
    return c;
  }
}

// デバッグ用の組み込み consumer
consumer dump {
  in: Object;

  bound(input) {
    // 実装依存:
    // input が単一オブジェクト、コレクション、木構造などであることを判別し、
    // 適切に input.Dump() または要素の Dump() を呼び出してデバッグ出力に書き出す。
    // 戻り値は Unit（戻り値なし）として扱われる。
  }
}</code></pre>

        <p>
          <code>dump</code> は組み込み consumer であり、パイプラインの末尾で
          <code>|&gt; dump</code> と書くことで、任意のオブジェクトの <code>Dump()</code> メソッドを使った
          デバッグ表示を行う。
        </p>
        <ul>
          <li>
            入力が通常のオブジェクトである場合、そのオブジェクトに対してちょうど 1 回
            <code>Dump()</code> を呼び出し、その結果の文字列を実装依存のデバッグ出力に書き出す。
          </li>
          <li>
            入力がコレクション（<code>Pipe&lt;T&gt;</code> や配列など反復可能な型）である場合、
            すべての要素に対して順番に <code>Dump()</code> を呼び出す。
          </li>
          <li>
            入力が木構造またはそれに類するオブジェクトグラフである場合、
            実装はノードを順番にたどりながら各ノードの <code>Dump()</code> を呼び出してよい。
          </li>
          <li>
            オブジェクトグラフの走査中に循環参照（同一インスタンスを 2 回以上たどろうとする状態）が
            検出された場合、その時点より下位の要素のダンプはスキップしなければならない。
          </li>
          <li>
            ただし、コレクション全体としては処理を継続し、
            循環を含んだ要素の次の要素以降についてはダンプを続行する。
          </li>
        </ul>
        <p class="small">
          実装は循環参照を検出した箇所で「<code>(cycle)</code>」などのマーカーを出力してもよいが、
          その具体的な文言や表現は実装依存とする。
        </p>

        <h4>6.5.4 使用例</h4>
        <pre><code>let ActiveUserNames: String[] =
  ReadLines("users.json")
    |&gt; Where (.Trim().Length &gt; 0)
    |&gt; Map   (ParseUser)
    |&gt; Where (.IsActive)
    |&gt; Map   (.Name)
    |&gt; ToArray();

// デバッグ目的でパイプラインの途中結果を確認する例
ReadLines("users.json")
  |&gt; Where (.Trim().Length &gt; 0)
  |&gt; dump;   // 各行の Dump() を呼び出してデバッグ出力する</code></pre>
      </section>
    </section>

    <section id="with">
      <h2>7. with 構文</h2>

      <h3>7.1 概要</h3>
      <p>
        <code>with</code> 構文は、同じ対象オブジェクトに対するプロパティ代入やメソッド呼び出しを
        繰り返し書くためのシンタックスシュガーである。<br />
        Aloe ではこれに加え、そのブロックの間、対象オブジェクトを生存させる
        <strong>「ライフタイムロック」</strong> の役割も持つ。
      </p>

      <pre><code>struct HttpRequest {
  Url: String;
  Method: String;
  TimeoutSeconds: Int;
}

var Request: HttpRequest;

with (Request) {
  Url = "https://example.com/api";
  Method = "GET";
  TimeoutSeconds = 5;
}</code></pre>

      <h3>7.2 セマンティクス</h3>
      <p>
        上記の <code>with</code> ブロックは、意味的には次のコードと等価である：
      </p>

      <pre><code>{
  Request.Url = "https://example.com/api";
  Request.Method = "GET";
  Request.TimeoutSeconds = 5;
}</code></pre>

      <ul>
        <li><code>with (Expr) { ... }</code> における <code>Expr</code> は<strong>ちょうど 1 回</strong> 評価される。</li>
        <li>ブロック内の単純な識別子への代入は、対象オブジェクトのメンバアクセスとして解釈される。</li>
      </ul>

      <h3>7.3 ライフタイムロック（GC ルートとしての振る舞い）</h3>
      <p>
        AloeVM は、参照カウントとスライディングコンパクションを組み合わせた
        メモリ管理方式を想定している。<br />
        このモデルにおいて、<code>with</code> ブロックは「ライフタイムロック」として振る舞う：
      </p>
      <ul>
        <li><code>with (Expr)</code> の評価結果は隠し変数（GC ルート）に保存される。</li>
        <li>この隠し変数はブロックを抜けるまでオブジェクトを保持し、
          その間 <strong>オブジェクトが解放されない</strong> ことが保証される。
        </li>
        <li>したがって、ブロックの実行中、そのオブジェクトは生存していることが保証される。</li>
      </ul>

      <h3>7.4 with と delete の関係</h3>
      <ul>
        <li>同じ変数を <code>with</code> の対象にしているブロック内で、
          その変数に対して <code>delete</code> を行うのはコンパイルエラーとする。
        </li>
        <li>理由は、<code>with</code> が「このオブジェクトはここでは生きていてほしい」という意図を表し、
          <code>delete</code> がそれと矛盾するためである。
        </li>
        <li>ただし、同じオブジェクトを指している <em>別の変数</em> に対して <code>delete</code> することは許可される。
          <code>with</code> による GC ルートが残っているため、オブジェクト自体は生存し続ける。
        </li>
      </ul>

      <pre><code>var Request: HttpRequest = GetRequest();
var Alias: HttpRequest = Request;

with (Request) {
  // Request は with によって保護され、このブロック内では必ず生きている

  delete Alias;   // OK: Alias の参照を消すだけ
  Url = "https://example.com/api";  // 依然として利用可能
}

// with ブロックを抜けると GC ルートは解除される。
// 他に参照が残っていなければ、オブジェクトは最終的に解放される。</code></pre>

      <p class="note">
        まとめると、<code>with</code> は
        <strong>「メンバアクセスのシンタックスシュガー」</strong> であると同時に、
        <strong>「対象オブジェクトを一時的な GC ルートとして保持する仕組み」</strong> でもある。<br />
        lock 構文と組み合わせて同じ対象を保護したい場合は、9.3 節の <code>lock with</code> 構文を利用できる。
      </p>
    </section>

    <section id="delete">
      <h2>8. delete 構文</h2>

      <h3>8.1 概要</h3>
      <p>
        Aloe において <code>delete</code> は、<strong>オブジェクトを直接破棄しない</strong>。<br />
        代わりに、<strong>変数から参照を取り除く</strong> ための構文として扱われる。
      </p>
      <ul>
        <li>実際のオブジェクト破棄（メモリ解放・ファイナライザなど）は、
          <strong>参照カウント + GC を用いる実行時（AloeVM）</strong> が行う。
        </li>
        <li><code>delete</code> は「この変数はもうこのオブジェクトを指さない」という意図を
          型安全に表現するためのものであり、null 代入の代わりとして用いる。
        </li>
      </ul>

      <h3>8.2 文法</h3>
      <pre><code>DeleteStatement ::= 'delete' Identifier ';'</code></pre>

      <h3>8.3 静的ルール（コンパイル時）</h3>
      <ul>
        <li><code>Identifier</code> は現在のスコープで宣言されている変数でなければならない。</li>
        <li><strong><code>delete</code> の後、その変数から読み取ったり、メンバアクセス・メソッド呼び出しを行うのはコンパイルエラー</strong> となる。</li>
        <li>ただし、その変数に新しい値を再代入することは可能である。
          概念的には、<code>delete</code> は変数を「未初期化状態」に戻すとみなせる。
        </li>
      </ul>

      <pre><code>var Buf: Buffer = NewBuffer();

// Buf を使用
DoSomething(Buf);

delete Buf;

// これ以降、Buf や Buf.Length を読むのはコンパイルエラー

Buf = NewBuffer();  // 再代入後は再び使用可能</code></pre>

      <h3>8.4 実行時セマンティクス</h3>
      <p>
        <code>delete Var;</code> が実行されると、VM は概ね次のように振る舞う：
      </p>
      <ul>
        <li><code>Var</code> が現在指しているオブジェクトに対する参照カウントを 1 減らす
          （参照カウント方式を想定）。
        </li>
        <li><code>Var</code> 自体は「未初期化／削除済み」としてマークされる。</li>
        <li>オブジェクトの参照カウントが 0 になったとき、そのオブジェクトは GC の裁量で解放される。<br />
          <strong>つまり、<code>delete</code> を実行した瞬間に必ず破棄されるとは限らない。</strong>
        </li>
      </ul>

      <p class="note">
        この言語仕様では、オブジェクトがいつ破棄されるかのタイミングは VM／ランタイムの責務とする。<br />
        <code>delete</code> はあくまで 1 つの変数からそのオブジェクトへの参照を取り除くだけである。
      </p>

      <h3>8.5 with との相互作用</h3>
      <ul>
        <li>7.4 節で述べた通り、<code>with</code> の対象となっている変数に対して、
          その <code>with</code> ブロック内で <code>delete</code> を行うのはコンパイルエラーとする。
        </li>
        <li>同じオブジェクトを指している別の変数に対して <code>delete</code> することは許可される。
          <code>with</code> による GC ルートが残っているため、オブジェクトは生存し続けるからである。
        </li>
      </ul>

      <p class="note">
        将来、Aloe に「所有権付きリソース型」やオーナーシップモデルを導入する場合は、
        <code>delete</code> をそのモデルと統合することも検討される。<br />
        本ドラフトでは、<strong>所有権モデルは存在しない</strong> 前提で記述している。
      </p>
    </section>

    <section id="lock">
      <h2>9. lock 構文と同期</h2>

      <h3>9.1 概要</h3>
      <p>
        <code>lock</code> 構文は、特定のオブジェクトに対してロックを取得し、
        ブロックの実行中、そのオブジェクトに対する排他アクセスと
        読み取りバリアの最適化を保証する。
      </p>

      <pre><code>var SharedCounter: Int = 0;

lock (SharedCounter) {
  SharedCounter = SharedCounter + 1;
}</code></pre>

      <h3>9.2 セマンティクス</h3>
      <ul>
        <li><code>lock (Expr) { Body }</code> は、<code>Expr</code> が表すオブジェクトに対するロックを取得し、
          <code>Body</code> ブロック内での排他アクセスを保証する。
        </li>
        <li>ロックの取得と解放は VM によって実装される。</li>
        <li>スレッド間で共有されるデータの更新は、基本的に <code>lock</code> ブロックの中に閉じ込めるべきである。</li>
      </ul>

      <p class="note">
        AloeVM はスライディングコンパクションを用いたメモリ管理を想定している。<br />
        <code>lock</code> ブロック内では、VM は読み取りバリアを最適化し、
        各オブジェクトに対するチェックを可能な限り 1 回に抑えることができる。
      </p>

      <h3>9.3 lock with 構文（lock + with の複合）</h3>
      <p>
        同じ対象オブジェクトに対して「排他ロック」と「ライフタイムロック（with）」を
        同時に適用したい場面のために、Aloe は <code>lock with</code> 構文を提供する。
      </p>

      <pre><code>lock with (Conn) {
  // ここでは:
  //   - Conn に対して排他ロックが取得されている
  //   - Conn は with によって GC ルートとして保持されている
  //   - Conn のメンバは省略して書ける（RequestUrl など）
}</code></pre>

      <h4>9.3.1 文法</h4>
      <pre><code>LockWithStatement ::= 'lock' 'with' '(' Expression ')' Block</code></pre>

      <p>
        <code>lock with (Expr) { Body }</code> は、「<code>Expr</code> を 1 回だけ評価し、その結果を
        <code>lock</code> と <code>with</code> の両方の対象として扱う」複合構文である。
      </p>

      <h4>9.3.2 デシュガリング（意味的な等価コード）</h4>
      <p>
        <code>lock with (Expr) { Body }</code> は、意味的には次のコードと等価である：
      </p>

      <pre><code>{
  let __tmp = Expr;
  lock (__tmp) {
    with (__tmp) {
      Body
    }
  }
}</code></pre>

      <ul>
        <li><code>Expr</code> はちょうど 1 回だけ評価され、その結果は一時変数 <code>__tmp</code> に束縛される。</li>
        <li>その後、<code>__tmp</code> を対象とする <code>lock</code> と <code>with</code> がネストして適用される。</li>
        <li>したがって、<code>Body</code> の実行中:
          <ul>
            <li>対象オブジェクトに対する排他アクセスが保証される（<code>lock</code> のセマンティクス）。</li>
            <li>対象オブジェクトは with による GC ルートとして保持され、生存が保証される。</li>
            <li>対象オブジェクトのメンバは <code>with</code> と同様に省略して参照できる。</li>
          </ul>
        </li>
      </ul>

      <h4>9.3.3 スタイルと制約</h4>
      <ul>
        <li><code>lock with</code> は、「特定のリソースを排他的かつ安全な寿命の範囲で操作する」という
          意図を 1 つの構文で表現するための糖衣構文である。
        </li>
        <li><code>with lock (Expr)</code> や <code>lock &amp; with (Expr)</code> のような別表記は
          言語仕様としては定義しない。<br />
          同様の目的には必ず <code>lock with</code> を用いる。
        </li>
        <li><code>lock with</code> ブロック内の挙動は、9.2 節の <code>lock</code> および
          7.3 節の <code>with</code> のルールの組み合わせとして解釈される。</li>
      </ul>

      <pre><code>var Conn: Connection = OpenConnection();

lock with (Conn) {
  Send("PING");
  var Resp: String = Receive();
  Print(Resp);
}

// ここまで来たらロック解除＆with のライフタイムロックも解除される。</code></pre>
    </section>

    <section id="exceptions">
      <h2>10. 例外処理</h2>

      <h3>10.1 try / catch / finally</h3>
      <pre><code>try {
  DoSomething();
} catch (ex: Error) {
  LogError(ex);
} finally {
  Cleanup();
}</code></pre>

      <ul>
        <li><code>try</code> ブロック内で投げられた例外は、対応する <code>catch</code> で捕捉できる。</li>
        <li><code>finally</code> ブロックは、例外が投げられたかどうかに関わらず必ず実行される。</li>
        <li>例外型や階層の詳細は VM 仕様側で定義される。</li>
      </ul>
    </section>

    <section id="runtime">
      <h2>11. 実行モデルとメモリ管理</h2>

      <h3>11.1 AloeVM の概要</h3>
      <ul>
        <li>スタックベースのバイトコード VM。</li>
        <li>関数呼び出しはコールスタック上にフレームを積む。</li>
        <li>GC は参照カウント + スライディングコンパクションを用いる想定。</li>
      </ul>

      <h3>11.2 メモリ管理（概要）</h3>
      <ul>
        <li>オブジェクトはヒープ上に確保される。</li>
        <li>一定の条件を満たした時に GC が実行され、生存オブジェクトをスライドさせてメモリをコンパクトにする。</li>
        <li><code>with</code> はオブジェクトを生存させる一時的な GC ルートとして働き、
          <code>lock</code> と組み合わせることで読み取りバリアの最適化を可能にする。
        </li>
        <li>通常、メモリ管理のために <code>delete</code> を呼ぶ必要はない。
          参照を明示的に破棄したい場合のみ <code>delete</code> を使用する。
        </li>
      </ul>

      <p class="small">
        詳細なオペコード一覧や GC 実装の詳細は AloeVM 仕様書で提供される。
      </p>
    </section>

    <section id="limits">
      <h2>12. 制限事項と今後の展望</h2>

      <h3>12.1 現在の制限事項</h3>
      <ul>
        <li>ジェネリクスの表現力は最小限であり、typeclass や高階ジェネリクスは定義されていない。</li>
        <li>モジュールシステムやパッケージ管理は本ドキュメントの範囲外である。</li>
        <li>メタプログラミング（マクロ・リフレクション等）は定義されていない。</li>
      </ul>

      <h3>12.2 今後の展望</h3>
      <ul>
        <li>Pipe / Filter パイプラインの並列化や融合最適化。</li>
        <li>Wasm コンポーネントモデルとの統合。</li>
        <li>例外に加えて Result 型のようなエラー処理の導入。</li>
        <li>分散処理・ストリーミング向けの標準ライブラリ拡張。</li>
        <li>必要に応じた所有権付きリソース型と <code>delete</code> の統合。</li>
        <li>trait / interface / sealed / readonly とパターンマッチおよび網羅性チェックとの統合。</li>
      </ul>

      <p class="note">
        本ドラフトでは特に、<br />
        <strong>Pipe / Filter と Producer / Transformer / Consumer / Pipe / Consumer の関係と宣言形式</strong>、<br />
        および
        <strong>with / delete / lock / クラス継承 / readonly / clone / generics と AloeVM のメモリモデルとの関係</strong>
        を明確にすることに重点を置いている。
      </p>
    </section>

    <section id="event">
      <h2>13. event 構文とイベントモデル</h2>

      <h3>13.1 目的と位置づけ</h3>
      <p>
        Aloe の <code>event</code> 構文は、
        「ここは外部コードからハンドラを登録できる通知ポイントである」という契約を
        言語レベルで表現するためのものである。
      </p>
      <ul>
        <li>外部コードはイベントにハンドラ（コールバック）を登録・解除できる。</li>
        <li>イベントの発火（通知の実行）は、原則としてイベントを宣言した側のみが行える。</li>
      </ul>
      <p>
        実装レベルでは、<code>event</code> は標準ライブラリ型 <code>Event&lt;TArgs&gt;</code> の
        シンタックスシュガーとして扱われる。
      </p>
      <ul>
        <li><code>event Clicked&lt;ClickedArgs&gt;;</code> は、
          型 <code>Event&lt;ClickedArgs&gt;</code> のフィールドを 1 つ持つのと等価である。
        </li>
        <li>ただし通常のフィールドとは異なり、外部コードからの再代入や直接の <code>Raise</code> 呼び出しは
          禁止される（コンパイルエラー）。</li>
      </ul>

      <h3>13.2 Event&lt;TArgs&gt; とハンドラ型</h3>

      <h4>13.2.1 ハンドラ型</h4>
      <p>
        イベントハンドラの関数型は、標準型エイリアスとして次のように定義される：
      </p>
      <pre><code>type EventHandler&lt;TArgs&gt; = Func&lt;TArgs:Task&gt;;</code></pre>
      <ul>
        <li>引数: <code>TArgs</code>（イベント引数の型）</li>
        <li>戻り値: <code>Task</code><br />
          非同期ハンドラを自然にサポートするため、イベントハンドラは
          「完了を表す <code>Task</code> を返す関数」としてモデル化される。
        </li>
      </ul>
      <p class="note">
        将来的には、<code>Func&lt;TArgs:Task&lt;TResult&gt;&gt;</code> 型のハンドラを扱う
        <code>Event&lt;TArgs, TResult&gt;</code> のような拡張を検討する余地があるが、
        バージョン 0.1 では <code>Task</code> 戻り値を基本とする。
      </p>

      <h4>13.2.2 Event&lt;TArgs&gt; の役割（概念）</h4>
      <p>
        <code>Event&lt;TArgs&gt;</code> は、イベントハンドラの集合とその一括実行ロジックを持つ型である。
      </p>
      <pre><code>type Event&lt;TArgs&gt; {
  Handlers: List&lt;EventHandler&lt;TArgs&gt;&gt;;
}

bound Event&lt;TArgs&gt; {
  method Add(Handler: EventHandler&lt;TArgs&gt;): Task {
    Handlers.Add(Handler);
  }

  method Remove(Handler: EventHandler&lt;TArgs&gt;): Task {
    // ハンドラの同一性判定の詳細は VM / ランタイム仕様に委ねる
    Handlers.Remove(Handler);
  }

  method Raise(Args: TArgs): Task {
    // すべてのハンドラを順番に await し、
    // 全て終了したら完了する Task を返す
    foreach (H in Handlers) {
      await H(Args);
    }
  }
}</code></pre>
      <p class="note">
        言語仕様としては、
        <code>Event&lt;TArgs&gt;</code> が「イベント集合」の実体であり、
        <code>event</code> 構文がそのフィールド宣言＋アクセス制御の糖衣構文である、
        という関係性のみを定める。
      </p>

      <h3>13.3 event 宣言の文法</h3>

      <h4>13.3.1 宣言位置</h4>
      <p><code>event</code> は以下の場所で宣言できる：</p>
      <ul>
        <li><code>struct</code> 本体</li>
        <li><code>class</code> 本体</li>
        <li><code>interface</code> 本体</li>
      </ul>
      <p>
        トップレベル（ファイル直下）や <code>trait</code> 内での宣言は、
        バージョン 0.1 では定義しない。
      </p>

      <h4>13.3.2 文法（概要）</h4>
      <pre><code>EventDeclaration ::=
    'event' Identifier '&lt;' Type '&gt;' ';'</code></pre>
      <p>例：</p>
      <pre><code>struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        上記宣言は、意味的には次のフィールド宣言と等価である：
      </p>
      <pre><code>struct Button {
  private Clicked: Event&lt;ClickedArgs&gt;;
}</code></pre>
      <p>ただし通常のフィールドと異なり、以下の制約が追加される：</p>
      <ul>
        <li>外部コードから <code>Clicked</code> への再代入はできない（コンパイルエラー）。</li>
        <li>外部コードから <code>Clicked.Raise(...)</code> を直接呼び出すことはできない。</li>
        <li>外部コードから <code>delete Clicked;</code> を行うことも禁止される。</li>
      </ul>

      <h3>13.4 イベント購読／解除構文（<code>+=</code> / <code>-=</code>）</h3>

      <h4>13.4.1 文法</h4>
      <pre><code>EventAddStatement    ::= PrimaryExpression '.' Identifier '+=' EventHandlerExpression ';'
EventRemoveStatement ::= PrimaryExpression '.' Identifier '-=' EventHandlerExpression ';'</code></pre>
      <ul>
        <li><code>PrimaryExpression.Identifier</code> は <code>event</code> 宣言されたメンバでなければならない。</li>
        <li><code>EventHandlerExpression</code> は型 <code>Func&lt;TArgs:Task&gt;</code> に暗黙変換可能な式でなければならない。</li>
      </ul>

      <h4>13.4.2 型ルール</h4>
      <p>
        <code>event X&lt;TArgs&gt;;</code> が宣言されているとき、
      </p>
      <ul>
        <li><code>Target.X</code> の型は <code>Event&lt;TArgs&gt;</code> である。</li>
        <li><code>Target.X += H;</code> が許可されるのは、
          <code>H</code> の型が <code>Func&lt;TArgs:Task&gt;</code>（またはそれに暗黙変換可能）である場合のみ。</li>
        <li><code>Target.X -= H;</code> についても同様の制約が適用される。</li>
      </ul>

      <h4>13.4.3 デシュガリング（意味的な等価コード）</h4>
      <p>意味的には次のように解釈される：</p>
      <pre><code>Target.X += H;
// は意味的に:
await Target.X.Add(H);</code></pre>
      <pre><code>Target.X -= H;
// は意味的に:
await Target.X.Remove(H);</code></pre>
      <p class="note">
        <code>Add</code> / <code>Remove</code> を <code>Task</code> 戻り値とすることで、
        <code>+=</code> / <code>-=</code> による購読／解除も非同期文として扱うことができる。
        必要に応じて、将来バージョンで fire-and-forget なバリエーションを検討する。
      </p>

      <h3>13.5 イベントの発火（Raise）のルール</h3>

      <h4>13.5.1 発火は定義側のみ許可</h4>
      <p>
        <code>event</code> 宣言されたメンバに対する <code>Raise</code> 呼び出しは、
        次のスコープからのみ許可される：
      </p>
      <ul>
        <li>そのイベントを宣言している <code>struct</code> / <code>class</code> のメソッド</li>
        <li>同じ型に対する <code>bound</code> ブロック内のメソッド</li>
      </ul>
      <p>
        それ以外のコード（外部モジュールや別クラス）からの
        <code>Clicked.Raise(...)</code> 呼び出しはコンパイルエラーとなる。
      </p>
      <p class="note">
        これにより、「イベントを公開している側だけが発火権限を持つ」という責務分離を保証できる。
      </p>

      <h4>13.5.2 発火の基本形</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}</code></pre>

      <h3>13.6 interface の event と実装</h3>
      <p><code>interface</code> でも <code>event</code> を宣言できる。</p>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

interface IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <p>
        この場合、<code>IButton</code> を <code>implements</code> する <code>struct</code> / <code>class</code> は、
        対応する <code>event</code> を必ず宣言しなければならない。
      </p>
      <pre><code>struct Button implements IButton {
  event Clicked&lt;ClickedArgs&gt;;
}</code></pre>
      <ul>
        <li>イベント名 <code>Clicked</code> が一致していない場合</li>
        <li>型引数 <code>ClickedArgs</code> が異なる場合</li>
      </ul>
      <p>はいずれもインターフェース実装不備としてコンパイルエラーとなる。</p>

      <h3>13.7 使用例</h3>

      <h4>13.7.1 Button と Clicked イベント</h4>
      <pre><code>struct ClickedArgs {
  ButtonId: String;
}

struct Button {
  event Clicked&lt;ClickedArgs&gt;;
}

bound Button {
  method OnNativeClick(Id: String): Task {
    let Args: ClickedArgs = { ButtonId = Id };
    await Clicked.Raise(Args);
  }
}

method SetupButton(): Task {
  var Btn: Button = CreateButton("OK");

  // 非同期ハンドラを登録
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Print("Clicked: " + Args.ButtonId);
  };

  // 別のハンドラを登録
  Btn.Clicked += async (Args: ClickedArgs): Task {
    Log("button clicked");
  };
}</code></pre>

      <h4>13.7.2 イベント解除</h4>
      <pre><code>method SetupAndTearDown(Btn: Button): Task {
  let Handler: Func&lt;ClickedArgs:Task&gt; =
    async (Args: ClickedArgs): Task {
      Print("temp handler");
    };

  // 登録
  Btn.Clicked += Handler;

  // 何か処理…

  // 解除
  Btn.Clicked -= Handler;
}</code></pre>

      <h3>13.8 with / lock と Event&lt;TArgs&gt; の組み合わせ（参考）</h3>
      <p>
        <code>Event&lt;TArgs&gt;</code> 自体も通常の参照型であるため、
        必要に応じて <code>with</code> や <code>lock with</code> と組み合わせて
        スレッドセーフに発火処理を行うこともできる。
      </p>
      <pre><code>struct Hub {
  event MessageReceived&lt;String&gt;;
}

bound Hub {
  method RaiseMessage(Msg: String): Task {
    lock with (MessageReceived) {
      await MessageReceived.Raise(Msg);
    }
  }
}</code></pre>

      <h3>13.9 まとめ</h3>
      <ul>
        <li><code>event</code> は <code>Event&lt;TArgs&gt;</code> の構文糖衣とアクセス制御ルールを提供する。</li>
        <li>外部コードは <code>+=</code> / <code>-=</code> によるハンドラ登録・解除のみが可能であり、
          イベントの発火や参照の差し替えはできない。</li>
        <li>ハンドラは <code>Func&lt;TArgs:Task&gt;</code> 型で統一し、非同期前提のイベントモデルとする。</li>
        <li>インターフェースにも <code>event</code> を宣言でき、イベント契約を型レベルで表現できる。</li>
        <li>C# の <code>event</code> に似た使い勝手を提供しつつ、
          <code>delegate</code> 型を言語に追加せず、
          Aloe の関数型と <code>Task</code> を素直に利用する設計とする。</li>
      </ul>
    </section>

  </main>
</div>
</body>
</html>

