<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Aloe 言語仕様書（ドラフト、日本語版）</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Yu Gothic", sans-serif;
      line-height: 1.7;
      margin: 2rem;
      max-width: 1100px;
    }
    h1, h2, h3, h4, h5 {
      margin-top: 1.6em;
    }
    pre, code {
      font-family: "JetBrains Mono", "Cascadia Code", Consolas, "Ricty Diminished", monospace;
      font-size: 0.95em;
    }
    pre {
      background: #f7f7f7;
      padding: 0.75rem 1rem;
      border-radius: 4px;
      overflow-x: auto;
    }
    ul, ol {
      padding-left: 1.4em;
    }
  </style>
</head>
<body>

<h1>Aloe 言語仕様書（ドラフト）</h1>

<p>
この文書は、Aloe 言語の英語版仕様書
(<code>https://stk2k.github.io/Aloe-lang/Documents/en/Aloe-lang-spec-en.html</code>)
をベースにした日本語版ドラフトです。<br>
さらに、本書では <strong>4.2 with ブロック</strong> に対して、
<strong>class / struct / enum を対象にした型ベース with（static メンバー／列挙子への短縮アクセス）</strong>
の拡張を含めています。
</p>

<h2>章構成</h2>
<ul>
  <li>0. 概要</li>
  <li>1. 基本文法</li>
  <li>2. 型システム</li>
  <li>3. 数値と暗黙変換</li>
  <li>4. ブロックとスコープ</li>
  <li>5. 変数と定数</li>
  <li>6. フィールド宣言</li>
  <li>7. クラス / 構造体 / インタフェース / トレイト</li>
  <li>8. delete と null</li>
  <li>9. is 演算子</li>
  <li>10. 配列・リスト・セット・マップ</li>
  <li>11. enum / bitfield enum</li>
  <li>12. main ブロック</li>
  <li>13. 一時変数 `_`</li>
  <li>14. swap キーワード</li>
  <li>15. 演算子の優先順位と結合規則</li>
  <li>16. 例外</li>
  <li>17. モジュール / namespace / import</li>
  <li>18. パイプとフィルタ（pipe / filter）</li>
</ul>

<hr>

<h2>0. 概要</h2>

<p>
Aloe は静的型付けのスクリプト言語であり、シンプルで直感的な記法を目指しています。<br>
Aloe プログラムはスタックベースの仮想マシン（AloeVM）上で動作し、主に以下を目標とします。
</p>

<ul>
  <li>教育用途や小規模アプリケーションで読み書きしやすいこと</li>
  <li>C# ランタイムおよび WebAssembly (WASM) 環境で実行できること</li>
  <li><code>pipe</code> と <code>filter</code> によるデータフロー指向の記述</li>
</ul>

<p>特徴の例：</p>
<ul>
  <li>静的型付け
    <ul>
      <li><code>var</code> による型推論</li>
      <li><code>let</code> による明示的な型指定</li>
    </ul>
  </li>
  <li>値型 / 参照型
    <ul>
      <li><code>struct</code> … 値型</li>
      <li><code>class</code> … 参照型</li>
    </ul>
  </li>
  <li>GC ベースのメモリ管理（具体的なアルゴリズムは VM 実装依存）</li>
  <li><code>= null</code> の代入はソースコードでは直接書かない
    <ul>
      <li>内部的には参照型は null を取り得るが、明示的代入には <code>delete</code> を使う</li>
    </ul>
  </li>
  <li>パイプライン（pipe &amp; filter）スタイルのデータフロー向き設計</li>
</ul>

<hr>

<h2>1. 基本文法</h2>

<h3>1.1 コメント</h3>

<pre><code>// 行コメント

/* 複数行
   コメント */
</code></pre>

<ul>
  <li><code>//</code> から行末までが行コメント。</li>
  <li><code>/*</code> ～ <code>*/</code> がブロックコメント。</li>
  <li>ブロックコメントのネストは未定義（サポートしない想定）。</li>
</ul>

<h3>1.2 識別子</h3>

<ul>
  <li>使用可能文字：英字 (A–Z, a–z)、数字 (0–9)、アンダースコア <code>_</code></li>
  <li>先頭文字は英字または <code>_</code> でなければならない</li>
  <li>大文字小文字は区別される</li>
  <li>キーワードと同じ綴りは使用できない</li>
  <li><code>_</code> で始まる識別子は「プライベート」扱いとし、外部からは参照しない慣習</li>
  <li>ユニコードの文字も使用可（空白・区切り記号などは除外）</li>
</ul>

<h3>1.3 キーワード</h3>

<pre><code>abstract
as
async
bitfield
break
case
catch
class
const
construct
continue
delete
do
else
enum
extends
false
field
finally
for
if
import
implements
in
interface
is
let
main
method
namespace
new
null
private
protected
public
readonly
return
sealed
static
struct
super
switch
swap
this
throw
throws
trait
true
try
var
void
while
with
yield
</code></pre>

<ul>
  <li><code>package</code> は使わず、<code>namespace</code> を利用する。</li>
  <li><code>final</code> は廃止し、拡張禁止には <code>sealed</code> を用いる。</li>
  <li><code>instanceof</code> は廃止し、型チェックには <code>is</code> を用いる。</li>
</ul>

<h3>1.4 リテラル</h3>

<ul>
  <li>整数リテラル：<code>10</code>, <code>0</code>, <code>-5</code>, <code>0x1A</code>, <code>0b1010</code> など</li>
  <li>浮動小数点リテラル：<code>10.5</code>, <code>0.0</code>, <code>-3.14</code></li>
  <li>10進小数リテラル：<code>10.1234...:d</code> 形式（C# の <code>decimal</code> に相当）</li>
  <li>真偽値リテラル：<code>true</code>, <code>false</code></li>
  <li>文字列リテラル：<code>"Hello, World!"</code></li>
  <li>文字リテラル：<code>'A'</code>, <code>'z'</code> など</li>
  <li>null リテラル：<code>null</code>（リテラルとして存在するが、直接代入には使わない）</li>
  <li>配列リテラル：<code>[1, 2, 3]</code></li>
  <li>リストリテラル：<code>(1, 2, 3)</code></li>
  <li>セットリテラル：<code>{1, 2, 3}</code></li>
  <li>マップリテラル：<code>["key1": 10, "key2": 20]</code></li>
  <li>enum リテラル：<code>EnumType.Value1</code></li>
  <li>struct リテラル：<code>Point { x: 0, y: 1 }</code></li>
  <li>オブジェクト生成：<code>new ClassName()</code></li>
</ul>

<h3>1.5 文の終端（セミコロン）</h3>

<ul>
  <li>すべての文はセミコロン <code>;</code> で終わる。</li>
  <li>改行による自動セミコロン挿入は行わない。</li>
</ul>

<pre><code>var x = 10;
x = x + 1;
print(x);
</code></pre>

<h3>1.6 空白</h3>

<ul>
  <li>スペース、タブ、改行はトークン区切りとして扱われる。</li>
  <li>連続する空白は 1 つの区切りとして扱う。</li>
  <li>インデントに意味はない（Python とは異なる）。</li>
</ul>

<h3>1.7 大文字・小文字</h3>

<ul>
  <li>識別子とキーワードは大文字小文字を区別。</li>
  <li>キーワードはすべて小文字。</li>
</ul>

<hr>

<h2>2. 型システム</h2>

<h3>2.1 プリミティブ型</h3>

<ul>
  <li><code>int</code> / <code>integer</code> – 整数</li>
  <li><code>float</code> – 浮動小数点数</li>
  <li><code>bool</code> / <code>boolean</code> – 真偽値</li>
  <li><code>decimal</code> – 高精度 10 進数</li>
  <li><code>string</code> – 文字列（内部的には Unicode）</li>
  <li><code>char</code> – 1 文字</li>
  <li><code>byte</code> – 0〜255 の整数</li>
  <li><code>void</code> – 戻り値なし（メソッド戻り値専用）</li>
  <li><code>null</code> は型ではなくリテラル。</li>
</ul>

<p>動的型 <code>any</code> は存在せず、動的型付けはサポートしない。</p>

<h3>2.2 合成型 / ユーザー定義型</h3>

<ul>
  <li>配列：<code>T[]</code></li>
  <li>リスト：<code>T()</code></li>
  <li>セット：<code>T{}</code></li>
  <li>マップ：<code>map&lt;T&gt;</code> または <code>map&lt;K/V&gt;</code></li>
  <li><code>struct</code></li>
  <li><code>class</code></li>
  <li><code>enum</code>, <code>bitfield enum</code></li>
  <li>非同期タスク：<code>task</code></li>
  <li>パイプ：<code>pipe&lt;T&gt;</code>（18章参照）</li>
</ul>

<h3>2.3 値型 / 参照型</h3>

<ul>
  <li>値型:
    <ul>
      <li><code>int</code>, <code>float</code>, <code>decimal</code>, <code>bool</code>, <code>byte</code>, <code>char</code></li>
      <li><code>struct</code></li>
      <li><code>enum</code>, <code>bitfield enum</code>（内部表現は int32）</li>
    </ul>
  </li>
  <li>参照型:
    <ul>
      <li><code>class</code></li>
      <li><code>string</code>（実装的には参照型）</li>
      <li><code>task</code>, <code>pipe&lt;T&gt;</code> など</li>
    </ul>
  </li>
</ul>

<h4>構造体の制約とコピー</h4>

<ul>
  <li>struct のフィールドにはプリミティブ型と他の struct のみを持てる。</li>
  <li>class などの参照型フィールドは持てない。</li>
  <li>struct の代入は常に値コピー。</li>
</ul>

<h4>class と struct の比較</h4>

<ul>
  <li>class は struct をフィールドとして持てる。</li>
  <li>class インスタンスを別の変数に代入すると参照がコピーされる。</li>
</ul>

<hr>

<h2>3. 数値と暗黙変換</h2>

<h3>3.1 int と float</h3>

<ul>
  <li><code>int</code> と <code>float</code> が同一式に現れると結果は <code>float</code> に昇格する。
    <ul>
      <li><code>int + float → float</code> など</li>
    </ul>
  </li>
</ul>

<h3>3.2 decimal</h3>

<ul>
  <li>高精度 10 進数。</li>
  <li><code>int</code> / <code>float</code> と混在する場合、必要に応じて <code>decimal</code> に昇格しうる。</li>
  <li>オーバーフロー / アンダーフロー / 桁あふれは <code>OverflowException</code> として扱う。</li>
</ul>

<h3>3.3 enum と int</h3>

<ul>
  <li>Aloe にはキャスト構文はない。</li>
  <li>enum と int 間の暗黙 / 明示の変換はいずれも禁止。</li>
  <li>enum と数値型の混在式は（bitfield enum のビット演算を除き）コンパイルエラー。</li>
  <li>内部表現としては enum / bitfield enum はすべて int32。</li>
</ul>

<h3>3.4 byte と char</h3>

<ul>
  <li><code>byte</code>
    <ul>
      <li>範囲は 0–255。</li>
      <li>byte 同士の演算は許可されるが範囲外はエラー。</li>
      <li>byte と int の混在式は int に昇格。</li>
    </ul>
  </li>
  <li><code>char</code>
    <ul>
      <li>算術演算は不可。</li>
      <li>比較演算（<code>==</code>, <code>&lt;</code> など）は char 同士のみ。</li>
      <li>数値型との暗黙変換は行わない。</li>
    </ul>
  </li>
</ul>

<h3>3.5 NaN / Infinity</h3>

<ul>
  <li>数値オーバーフロー/アンダーフローは NaN/Infinity ではなく例外で扱う。</li>
  <li><code>ZeroDivisionException</code> は 0 / 0.0 で常に投げる。</li>
</ul>

<hr>

<h2>4. ブロックとスコープ</h2>

<p>
Aloe におけるブロックは <code>{</code> と <code>}</code> で囲まれ、各ブロックが新しいスコープを導入する。
</p>

<ul>
  <li><code>main</code> ブロック</li>
  <li>クラス定義ブロック</li>
  <li>メソッド定義ブロック</li>
  <li>任意の <code>{ ... }</code> ブロック</li>
</ul>

<h3>4.1 静的（レキシカル）スコープとシャドウイング</h3>

<ul>
  <li>Aloe は静的スコープ。</li>
  <li>内側ブロックで同名変数を宣言すると外側の変数をシャドウする。</li>
  <li>フィールドとローカル変数名がぶつかった場合、ローカル変数が優先され、
      フィールドには <code>this.</code> でアクセスする。</li>
</ul>

<pre><code>class Sample {
    field value: int = 1;
    method foo(): void {
        var value = 2;        // フィールドをシャドウ
        print(value);         // 2
        print(this.value);    // 1
    }
}
</code></pre>

<h3>4.2 with ブロック（メンバー省略記法）</h3>

<p>
Aloe には、同一オブジェクトのメンバーアクセスを簡潔に書くための
<code>with</code> ブロックがある。
</p>

<pre><code>with (user) {
    .name = "Alice";
    .age  = .age + 1;
    print(.name);
}
</code></pre>

<ul>
  <li><code>with (expr) { ... }</code> ブロック内では：
    <ul>
      <li><code>.Member</code> は <code>(expr).Member</code> の省略形。</li>
      <li><code>expr</code> はブロックの先頭で 1 度だけ評価され、内部の一時変数にキャプチャされる。</li>
      <li>特別な一時変数 <code>_</code> は「with 対象オブジェクト」を指す。
        <ul>
          <li>たとえば <code>log(_);</code> のように渡せる。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>ネストした <code>with</code> ブロック：
    <ul>
      <li>内側の <code>with</code> が <code>.</code> の解決および <code>_</code> をシャドウする。</li>
      <li>外側オブジェクトへは通常の変数名を通してアクセスできる。</li>
    </ul>
  </li>
  <li>同じブロックに複数の <code>with</code> を並べることもできる（C# の <code>using</code> 的な形）：</li>
</ul>

<pre><code>with (user), (profile) {
    .name = "Alice";  // user / profile 双方の name に対して解決を試みる
}
</code></pre>

<ul>
  <li>どのオブジェクトのメンバーに解決するかの順序は実装依存。</li>
  <li>ただし曖昧な場合（複数オブジェクトが同じメンバーを持つ）はコンパイルエラーとする。</li>
</ul>

<p>
<code>with</code> はあくまで構文糖衣であり、意味的にはすべて
明示的な <code>obj.member</code>（または <code>TypeName.member</code>）に書き換えた後で
型チェック・コード生成を行うことができる。
</p>

<h4>4.2.1 型名を対象にした with（class / struct / enum の static / 列挙子アクセス・拡張）</h4>

<p>
通常の <code>with (expr)</code> に加えて、<strong>型名</strong> を対象にした
<code>with</code> を利用できる。
</p>

<pre><code>with (TypeName) {
    .SomeStaticMethod();
    .SomeStaticField = 1;
}
</code></pre>

<p>
ここで <code>TypeName</code> は次のいずれかでなければならない：
</p>

<ul>
  <li><code>class</code> 型</li>
  <li><code>struct</code> 型</li>
  <li><code>enum</code> / <code>bitfield enum</code></li>
</ul>

<p>この場合、<code>with</code> は「型コンテキスト with」として解釈される：</p>

<ul>
  <li><code>()</code> 内の式は実行時に値として評価されない。
    <ul>
      <li>コンパイラは <code>TypeName</code> を型として解決し、インスタンス生成などは行わない。</li>
    </ul>
  </li>
  <li>ブロック内では：
    <ul>
      <li><code>.Member</code> は <code>TypeName.Member</code> の省略形として解釈される。
        <ul>
          <li>対象となる <code>Member</code> は次のいずれか：
            <ul>
              <li>static フィールド</li>
              <li>static メソッド</li>
              <li>enum / bitfield enum の列挙子</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>一時変数 <code>_</code> は <code>TypeName</code> の static コンテキストを表す
          擬似オブジェクトとして振る舞う。
        <ul>
          <li><code>_.Member</code> も <code>TypeName.Member</code> と等価。</li>
        </ul>
      </li>
      <li>型ベース <code>with</code> 内でインスタンスメンバーにアクセスすることはコンパイルエラー。</li>
    </ul>
  </li>
</ul>

<p>
型ベース <code>with</code> でも、ローカル変数・外側スコープの変数が同名で存在する場合はそちらが優先される。
列挙子や static メンバーを明示したい場合は <code>TypeName.Member</code> または <code>.Member</code> / <code>_.Member</code> を用いる。
</p>

<h5>例：class / struct の static アクセス</h5>

<pre><code>struct AngleUtil {
    static field Pi: float = 3.14159;

    static method degToRad(deg: float): float {
        return deg * Pi / 180.0;
    }
}

class MathUtil {
    static method max(a: int, b: int): int {
        if (a > b) return a;
        return b;
    }
}

main(args: string[]) {
    with (AngleUtil) {
        var rad = degToRad(90.0);  // AngleUtil.degToRad(90.0)
        print(.Pi);                // AngleUtil.Pi
    }

    with (MathUtil) {
        var m = max(10, 20);       // MathUtil.max(10, 20)
        print(m);
    }
}
</code></pre>

<h5>例：enum の列挙子アクセス</h5>

<pre><code>enum Color {
    Red,
    Green,
    Blue
}

main(args: string[]) {
    with (Color) {
        var c1: Color = Red;     // Color.Red
        var c2: Color = Blue;    // Color.Blue
        print(c1);
        print(c2);
    }
}
</code></pre>

<p>
型ベース <code>with</code> も複数ターゲット構文に混在させることができる：
</p>

<pre><code>with (user), (Color) {
    // .name → user.name
    // .Red  → Color.Red
}
</code></pre>

<p>
この場合も、解決順序は実装依存だが、曖昧な場合はコンパイルエラーとする。
</p>

<hr>

<h2>5. 変数と定数</h2>

<h3>5.1 var（型推論）</h3>

<pre><code>var i = 10;
var f = 10.5;
var s = "Hello";
var c = 'A';
var b = 255;
var arr = [1, 2, 3];
var lst = (1, 2, 3);
var st  = {1, 2, 3};
var mp  = ["key": 10];
var fb  = new FizzBuzz();
</code></pre>

<ul>
  <li>変数の型は右辺の式から推論される。</li>
  <li><code>var x = 1;</code> は常に <code>int</code>。</li>
  <li><code>var x = 1.0;</code> は <code>float</code> として扱われる（<code>decimal</code> の候補にはならない）。</li>
  <li><code>var x = null;</code> はコンパイルエラー（型が推論不可）。</li>
</ul>

<h3>5.2 let（明示的な型）</h3>

<pre><code>let i: int = 10;
let f: float = 10.5;
let d: decimal = 10.12345678901234567890:d;
let s: string = "Hello, Aloe!";
let c: char = 'A';
let b: byte = 255;

let arr: int[] = [1, 2, 3];
let lst: int() = (1, 2, 3);
let st : int{} = {1, 2, 3};
let mp : map&lt;string/int&gt; = ["key": 10];
</code></pre>

<h3>5.3 定数（const）</h3>

<pre><code>const MaxCount: int = 100;
const Pi: float = 3.14159;
const AppName: string = "Aloe VM";
</code></pre>

<ul>
  <li><code>const</code> 変数は再代入できない。</li>
  <li>const には型注釈が必須。</li>
</ul>

<hr>

<h2>6. フィールド宣言（field / readonly field）</h2>

<p>
class / struct のフィールドは <code>field</code> キーワードで宣言する。
</p>

<pre><code>class Sample {
    field count: int = 0;
    field name: string = "default";

    readonly field id: int;

    construct(id: int) {
        this.id = id; // OK: コンストラクタ内のみ代入可
    }
    method change(): void {
        this.count = this.count + 1; // OK
        // this.id = 2; // NG: readonly field はコンストラクタ外で代入不可
    }
}
</code></pre>

<ul>
  <li><code>field</code> … 通常のフィールド。</li>
  <li><code>readonly field</code> … コンストラクタ内のみ書き込み可、それ以降は読み取り専用。</li>
  <li>struct / class の両方で同じ意味。</li>
</ul>

<hr>

<h2>7. クラス / 構造体 / インタフェース / トレイト</h2>

<h3>7.1 class</h3>

<pre><code>class FizzBuzz {
    field _count: int = 0;
    field name: string = "FizzBuzz";

    construct() {
    }

    method run(): void {
        var i = 1;
        while (i &lt;= 100) {
            // ...
            i = i + 1;
        }
    }
}
</code></pre>

<ul>
  <li>class は参照型。</li>
  <li><code>sealed class</code> は <code>extends</code> で継承できない。</li>
  <li>単一継承のみサポート。</li>
</ul>

<h3>7.2 struct</h3>

<pre><code>struct Point {
    field x: int;
    field y: int;

    construct(x: int, y: int) {
        this.x = x;
        this.y = y;
    }
}
</code></pre>

<ul>
  <li>struct は値型。</li>
  <li>フィールドはプリミティブ型と他の struct に限定（参照フィールド禁止）。</li>
  <li>struct のコピーは常に値コピー。</li>
  <li>struct の継承はサポートしない（<code>sealed struct</code> は「拡張禁止」マーカーとしてのみ有効）。</li>
</ul>

<h3>7.3 継承と sealed</h3>

<pre><code>class Base {
    method foo(): void { }
}

class Derived extends Base {
    method bar(): void { }
}

sealed class FinalDerived extends Base {
    // これ以上の継承は不可
}
</code></pre>

<h3>7.4 interface</h3>

<pre><code>interface ILogger {
    method log(msg: string): void;
}

class ConsoleLogger implements ILogger {
    method log(msg: string): void {
        print(msg);
    }
}
</code></pre>

<ul>
  <li><code>implements</code> キーワードでインタフェースを実装。</li>
  <li><code>is</code> 演算子でインタフェース実装有無を判定。</li>
</ul>

<h3>7.5 trait</h3>

<pre><code>trait Trait_A {
    method hello(): void {
        print("Hello from Trait_A");
    }
}
</code></pre>

<h4>with を使った trait 適用</h4>

<pre><code>var obj = new SomeClass() with Trait_A;
obj.hello(); // Trait_A 由来のメソッド（衝突がなければ）
</code></pre>

<h4>非破壊的 add/remove（+ / -）</h4>

<pre><code>var obj2 = obj + Trait_A;  // obj は変わらず、obj2 に Trait_A が付与される
var obj3 = obj2 - Trait_A; // obj3 は Trait_A を除いた obj2
</code></pre>

<h4>as によるエイリアス</h4>

<pre><code>var obj2 = obj + Trait_A as a;
obj2.a.hello(); // OK

// obj2.hello(); // NG: alias のみで直接メンバ合成はしない
</code></pre>

<h4>trait の衝突</h4>

<ul>
  <li>複数の trait が同名フィールド / メソッドを定義しているとコンパイルエラー。</li>
  <li><code>as a</code> などのエイリアス付きで適用した trait は名前衝突の対象外。</li>
  <li>class 本体と trait メンバの衝突の扱いは今後の仕様で定義予定。</li>
</ul>

<hr>

<h2>8. delete と null</h2>

<pre><code>var obj = new FizzBuzz();
delete obj;  // VM レベルでは obj = null と等価
</code></pre>

<ul>
  <li><code>delete obj;</code> は内部的に <code>obj = null</code> と同等。</li>
  <li>ソースコード中で <code>obj = null;</code> を直接書くことはできない。</li>
  <li>参照型は内部的には null を取り得るが、型システムは null 追跡を行わない。</li>
  <li>フィールドやローカルが null（削除済み）の状態で参照されると <code>NullReferenceException</code> が発生しうる。</li>
</ul>

<hr>

<h2>9. is 演算子</h2>

<pre><code>if (obj is FizzBuzz) {
    // 実行時型が FizzBuzz またはその派生クラスであれば true
}

if (obj is ILogger) {
    // obj が ILogger を実装していれば true
}

if (obj is Trait_A) {
    // obj が Trait_A を with / + で持っていれば true
}
</code></pre>

<ul>
  <li><code>is</code> は実行時の型チェックを行う。</li>
  <li>継承関係（Derived は Base でもある）を考慮する。</li>
  <li>インタフェースや trait に対しても使用できる。</li>
</ul>

<hr>

<h2>10. 配列・リスト・セット・マップ</h2>

<h3>10.1 配列（T[]）</h3>

<pre><code>var arr: int[] = [1, 2, 3];
var matrix: float[][] = [[1.0, 2.0], [3.0, 4.0]];
</code></pre>

<h3>10.2 リスト（T()）</h3>

<pre><code>var lst: int() = (1, 2, 3);
var objLst: FizzBuzz() = (new FizzBuzz(), new FizzBuzz());
</code></pre>

<h3>10.3 セット（T{}）</h3>

<pre><code>var st: int{} = {1, 2, 3};
var structSt: Point{} = {Point { x:0, y:0 }, Point { x:1, y:1 }};
</code></pre>

<h3>10.4 マップ（map&lt;K/V&gt;）</h3>

<pre><code>var mp: map&lt;int&gt; = ["key1": 10, "key2": 20];          // デフォルトのキー型は string
var mp2: map&lt;string/float&gt; = ["key1": 10.5, "key2": 20.5];
var objMp: map&lt;FizzBuzz&gt; = ["obj1": new FizzBuzz(), "obj2": new FizzBuzz()];
</code></pre>

<hr>

<h2>11. enum と bitfield enum</h2>

<h3>11.1 通常の enum</h3>

<pre><code>enum Color {
    Red,
    Green,
    Blue
}
</code></pre>

<ul>
  <li>内部表現はすべて int32。</li>
  <li><code>enum&lt;byte&gt;</code>, <code>enum&lt;string&gt;</code> のような基礎型を変えるジェネリック enum は許可しない。</li>
  <li>enum 型も <strong>型ベース with の対象</strong> となり、<code>with (Color) { Red; }</code> のように列挙子に短縮アクセスできる。</li>
</ul>

<h3>11.2 bitfield enum</h3>

<pre><code>bitfield enum LogFlags {
    None = 1 &lt;&lt; 0,
    Info = 1 &lt;&lt; 3,
    Warn,
}
</code></pre>

<h4>b(n) 記法</h4>

<pre><code>bitfield enum LogFlags {
    None : b(0),
    Info : b(3),
    Warn,            // 直前までの最大 b(n) は 3; Warn は b(4) = 1 &lt;&lt; 4 になる
}
</code></pre>

<ul>
  <li><code>b(n)</code> はビット n（<code>1 &lt;&lt; n</code>）を表す。</li>
  <li><code>Name : b(n)</code> でその列挙子にビット n を割り当てる。</li>
  <li><code>bitfield enum</code> で有効なビット数は最大 32（<code>n</code> は 0–31）。</li>
  <li>同一ビットを共有する列挙子があっても、コンパイラは警告を出すにとどめ、エラーにはしない。</li>
  <li>基礎型は常に int32 であり <code>bitfield enum&lt;byte&gt;</code> などはコンパイルエラー。</li>
</ul>

<hr>

<h2>12. main ブロック</h2>

<pre><code>main(args: string[]) {
    var fb = new FizzBuzz();
    fb.run();
    _ = 0; // プロセスの終了コード (int)
}
</code></pre>

<ul>
  <li>プログラムのエントリポイント。</li>
  <li><code>args</code> はコマンドライン引数の文字列配列。</li>
  <li>main ブロック内では、一時変数 <code>_</code> は常に <code>int</code> 型であり、その値がプロセスの終了コードとなる。</li>
</ul>

<hr>

<h2>13. 一時変数 `_`</h2>

<pre><code>main(args: string[]) {
    var x = 10;
    _ = x + 5;   // _ は int
}

method foo(): void {
    var x = 10;
    _ = x + 5;   // このブロックにおける _ の型がここで推論される
}
</code></pre>

<ul>
  <li><code>_</code> は任意のブロックで宣言なしに使用できる特別な一時変数。</li>
  <li>main ブロックでは <code>_</code> は常に int。</li>
  <li>それ以外のブロックでは、そのブロック内で最初に代入した式の型が <code>_</code> の型となる。</li>
  <li><strong>with ブロック内では、<code>_</code> は追加で「現在の with 対象」を指す：</strong>
    <ul>
      <li>通常の with（<code>with (expr)</code>）では、その評価結果オブジェクト。</li>
      <li>型ベース with（<code>with (TypeName)</code>）では、その型の static コンテキストを表す擬似オブジェクト。</li>
      <li>内側にさらに <code>_</code> の型推論や別の with があればそちらによりシャドウされる。</li>
    </ul>
  </li>
</ul>

<hr>

<h2>14. swap キーワード</h2>

<pre><code>var a = 10;
var b = 20;
swap (a, b);
print(a); // 20
print(b); // 10
</code></pre>

<ul>
  <li><code>swap (x, y);</code> は x と y の値（または参照）を入れ替える。</li>
  <li>型の互換性や swap が妥当かどうかはコンパイル時にチェックされる。</li>
</ul>

<hr>

<h2>15. 演算子の優先順位と結合規則</h2>

<h3>15.1 優先順位（高い順）</h3>

<ol>
  <li>メンバー / 呼び出し
    <ul>
      <li><code>x.y</code>, <code>x[y]</code>, <code>x(args...)</code></li>
    </ul>
  </li>
  <li>単項演算子
    <ul>
      <li><code>+x</code>, <code>-x</code>, <code>!x</code>, <code>delete x</code></li>
    </ul>
  </li>
  <li>乗除
    <ul><li><code>*</code>, <code>/</code>, <code>%</code></li></ul>
  </li>
  <li>加減
    <ul><li><code>+</code>, <code>-</code></li></ul>
  </li>
  <li>シフト
    <ul><li><code>&lt;&lt;</code>, <code>&gt;&gt;</code></li></ul>
  </li>
  <li>関係演算
    <ul><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li></ul>
  </li>
  <li>等価
    <ul><li><code>==</code>, <code>!=</code></li></ul>
  </li>
  <li>ビット AND
    <ul><li><code>&amp;</code></li></ul>
  </li>
  <li>ビット XOR
    <ul><li><code>^</code></li></ul>
  </li>
  <li>ビット OR
    <ul>
      <li><code>|</code></li>
      <li>※パイプライン文では <code>|</code> は別の意味を持つ（18章参照）。</li>
    </ul>
  </li>
  <li>論理 AND
    <ul><li><code>&amp;&amp;</code></li></ul>
  </li>
  <li>論理 OR
    <ul><li><code>||</code></li></ul>
  </li>
  <li>代入
    <ul><li><code>=</code></li></ul>
  </li>
</ol>

<p>複合代入（<code>+=</code> など）はまだ仕様化されていない。</p>

<h3>15.2 結合規則</h3>

<ul>
  <li>単項演算子：右結合。</li>
  <li>代入：右結合。</li>
  <li>それ以外の 2 項演算子：左結合。</li>
</ul>

<hr>

<h2>16. 例外とエラーハンドリング</h2>

<pre><code>try {
    // 例外が発生するかもしれないコード
}
catch (e) {
    // 例外処理
}
finally {
    // 必ず実行される後処理
}
</code></pre>

<h3>16.1 標準例外階層（概要）</h3>

<pre><code>Exception
├── SystemException
│   ├── NullReferenceException
│   ├── IndexOutOfBoundsException
│   ├── OverflowException
│   ├── ZeroDivisionException
│   ├── InvalidOperationException
│   ├── NotImplementedException
│   ├── TimeoutException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   └── FormatException
└── IOException
    ├── FileNotFoundException
    ├── EndOfStreamException
    └── IOException (general)
</code></pre>

<ul>
  <li><code>OverflowException</code> はオーバーフロー / アンダーフローの双方に用いる。</li>
  <li><code>ZeroDivisionException</code> は 0 / 0.0 による除算で投げる。</li>
  <li>パース・フォーマットエラー（JSON 等）は <code>FormatException</code> を使う。</li>
  <li>VM レベルの致命的エラー（メモリ不足など）は実装依存。</li>
</ul>

<hr>

<h2>17. Modules / namespace / import</h2>

<pre><code>namespace Aloe.Sample {
    import Aloe.Core.Logging;

    class App {
        // ...
    }
}
</code></pre>

<ul>
  <li><code>namespace</code> は論理的な名前空間（モジュールのようなもの）を定義する。</li>
  <li><code>import</code> は他の namespace やシンボルを参照するために用いる。</li>
  <li>ファイルと namespace の対応や循環 import の扱いは詳細なモジュール仕様で定義予定。</li>
</ul>

<hr>

<h2>18. パイプとフィルタ（pipe / filter）</h2>

<p>
Aloe は <code>pipe&lt;T&gt;</code> と <code>filter(...)</code> を用いて、
タスクや I/O 間のストリーミングデータフローを表現する。
</p>

<h3>18.1 pipe&lt;T&gt; の基本</h3>

<ul>
  <li><code>pipe&lt;T&gt;</code> は T 型の値のストリーム。
    <ul>
      <li><code>pipe&lt;byte&gt;</code> … OS の標準入力やソケットなどのバイト列</li>
      <li><code>pipe&lt;string&gt;</code> … 文字列ストリーム</li>
    </ul>
  </li>
  <li>パイプは「コピーベース」。タスク間で共有メモリではなく値コピーで渡す。</li>
</ul>

<pre><code>let p: pipe&lt;int&gt; = pipe&lt;int&gt;.create();
</code></pre>

<p>概念的なインタフェース：</p>

<ul>
  <li><code>write(value: T): void</code> – 値を追加</li>
  <li><code>close(): void</code> – 終端通知</li>
  <li><code>next(): T?</code> – 次の要素を取得（EOF で null 的値）</li>
  <li><code>take(count: int): T()</code> – 最大 count 個をリストとして取得</li>
  <li><code>peek(): T?</code> – 次の要素を消費せず参照</li>
</ul>

<h4>18.1.1 組み込みパイプ</h4>

<ul>
  <li>VM が用意するパイプ：
    <ul>
      <li><code>stdin : pipe&lt;byte&gt;</code></li>
      <li><code>stdout : pipe&lt;byte&gt;</code></li>
      <li><code>stderr : pipe&lt;byte&gt;</code>（任意）</li>
    </ul>
  </li>
</ul>

<h3>18.2 filter(...) の基本</h3>

<p>
<code>filter(F)</code> はパイプライン中の中間変換ステージを表す。
</p>

<ul>
  <li>例：<code>filter(utf8)</code>, <code>filter(json&lt;User&gt;)</code>, <code>filter(lineSplit)</code></li>
  <li>フィルタ定義は、どの入力 / 出力型を扱うかを宣言する。</li>
</ul>

<h4>18.2.1 フィルタ定義</h4>

<pre><code>filter lineSplit {
    in:  pipe&lt;string&gt;;
    out: pipe&lt;string&gt;;

    bound(input, output) {
        foreach (chunk in input) {
            let lines = chunk.split("\n");
            foreach (line in lines) {
                output.write(line);
            }
        }
        output.close();
    }
}
</code></pre>

<ul>
  <li><code>filter Name { ... }</code> でフィルタ定義。</li>
  <li><code>in:</code> / <code>out:</code> で <code>bound</code> の入出力型を宣言。</li>
  <li><code>bound(input, output)</code> がフィルタ接続時に実行される本体。</li>
</ul>

<h4>18.2.2 フィルタオプション</h4>

<pre><code>filter(json&lt;User&gt;: JsonOptions.PrettyPrint | JsonOptions.IncludeNulls)
</code></pre>

<ul>
  <li>オプションは <code>:</code> の後に <code>|</code> で結合して指定。</li>
  <li>各フィルタは自前のオプション型（たとえば bitfield enum の <code>JsonOptions</code> など）をもつ。</li>
  <li>オプション省略時はフィルタのデフォルトオプションが使われる。</li>
</ul>

<p>
個々の標準フィルタ（<code>utf8</code>, <code>json&lt;T&gt;</code>, <code>lineSplit</code> 等）の詳細は
「標準フィルタライブラリ」仕様に委ねられる。
</p>

<h3>18.3 パイプライン文と <code>|</code></h3>

<p>
パイプライン文は <code>|</code> で pipe と filter をつなぐ：
</p>

<pre><code>stdin
    | filter(utf8)
    | filter(json&lt;DateTime&gt;)
    | dates;
</code></pre>

<p>非形式的な文法：</p>

<pre><code>pipeline_stmt: pipe_term ('|' pipe_term)+ ';'
</code></pre>

<ul>
  <li><code>pipe_term</code> になれるもの：
    <ul>
      <li><code>pipe&lt;T&gt;</code> 型の変数（<code>stdin</code>, <code>stdout</code> 等）</li>
      <li><code>filter(...)</code> 式</li>
    </ul>
  </li>
  <li>パイプライン文は「文」であり、式コンテキストでは <code>|</code> は常にビット OR 演算子。</li>
</ul>

<h4>18.3.1 接続セマンティクス</h4>

<pre><code>A | B | C;
</code></pre>

<ul>
  <li><code>A</code> の出力が <code>B</code> の入力へ。</li>
  <li><code>B</code> の出力が <code>C</code> の入力へ。</li>
  <li>型チェックにより、各ステージの出力型と次のステージの入力型の整合を確認する。</li>
  <li>パイプライン文自体は接続を確立する副作用だけを持ち、値を返さない。</li>
</ul>

<h3>18.4 foreach と pipe</h3>

<pre><code>foreach (line in lines) {
    print("Input: " + line);
}
</code></pre>

<ul>
  <li><code>foreach (x in p)</code> は内部的に <code>p.next()</code> を EOF まで呼び出す。</li>
  <li>書き込み側が <code>close()</code> を呼ぶと、読み側は EOF を検知してループを終了する。</li>
</ul>

<h4>18.4.1 next / take / peek</h4>

<ul>
  <li><code>next()</code> – 次の要素を返し、読み位置を進める。</li>
  <li><code>take(n)</code> – 最大 n 要素をリストで取得。</li>
  <li><code>peek()</code> – 次の要素を消費せず参照。</li>
</ul>

<h3>18.5 close と EOF 伝播</h3>

<ul>
  <li><code>p.close()</code> 呼び出し後の <code>write()</code> は無効（ランタイムエラーになり得る）。</li>
  <li>フィルタは入力 EOF を検知したら、出力側も <code>close()</code> すべき。</li>
  <li>複数フィルタからなるチェーンでは、EOF が上流から下流へ伝わり、最後の <code>foreach</code> / <code>next()</code> が終了する。</li>
</ul>

<h3>18.6 pipe を使った並行モデル</h3>

<ul>
  <li>タスク同士の主な通信手段は <code>pipe&lt;T&gt;</code>。</li>
  <li>共有可変データ構造を直接共有せず、基本的に shared-nothing モデルを想定。</li>
  <li>各 <code>pipe&lt;T&gt;</code> は概念的には「1 producer / 1 consumer」向け。</li>
</ul>

<h3>18.7 例：簡単な REST 風パイプライン</h3>

<pre><code>class User {
    field id: int;
    field name: string;
}

main(args: string[]) {
    let req: pipe&lt;byte&gt; = pipe&lt;byte&gt;.create();
    let users: pipe&lt;User&gt; = pipe&lt;User&gt;.create();

    // stdin から users までのパイプラインを構成
    stdin
        | filter(utf8)              // 標準フィルタライブラリ（UTF-8）
        | filter(json&lt;User&gt;)       // 標準フィルタライブラリ（JSON &lt;-&gt; User）
        | users;

    // パイプラインから最初のユーザーを取得
    let u: User? = users.next();
    if (u is User) {
        print("User: " + u.name);
    }

    _ = 0;
}
</code></pre>

<p>
<code>utf8</code>, <code>json&lt;T&gt;</code> などの標準フィルタの挙動やオプションは、
このコア言語仕様ではなく、別途「標準フィルタライブラリ」仕様で定義される。
</p>

<hr>

<p>
以上が、Aloe 言語仕様書（ドラフト、日本語版）です。<br>
本書には、元の英語版に対する <strong>with ブロックの型対応拡張（class / struct / enum）</strong> が反映されています。
</p>

</body>
</html>
```0
