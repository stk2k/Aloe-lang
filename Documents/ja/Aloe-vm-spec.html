```html
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>AloeVM 仕様書（ドラフト）</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }
    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM 仕様書</h1>
    <small>（現時点のドラフト。今後変更・拡張される可能性があります。）</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. 概要</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. 実行モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. VM 値モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. コールスタックとフレーム</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. ヒープとメモリ管理方針</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. パイプ / フィルタの表現</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC バイナリ形式</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. 命令セットと WASM 対応</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. 未決事項・TODO</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. 概要 -->
    <section id="vm-ch0" class="chapter">
      <h2>0. 概要</h2>
      <p>
        AloeVM は、Aloe 言語の実行用に設計された <strong>スタックベースの仮想マシン</strong> です。<br>
        ここでは以下を定義します：
      </p>
      <ul>
        <li>実行モデル（スタックマシン／フレーム構造）</li>
        <li>VM レベルの値モデル（プリミティブ・構造体・クラス・enum・pipe/filter 等）</li>
        <li>ヒープとメモリ管理の方針</li>
        <li>パイプ / フィルタの VM 上での表現</li>
        <li>AloeBC（Aloe バイトコード）バイナリ形式</li>
        <li>WebAssembly（WASM）との対応ポリシー</li>
      </ul>
      <div class="note">
        AloeVM には 2 つの想定ランタイムがあります：
        <ul>
          <li>C# 実装（.NET 上で動作する VM）</li>
          <li>WASM ネイティブ実装（aloe2wasm によって直接 WASM にコンパイルされたコード）</li>
        </ul>
        本仕様は主に「C# 実装 VM + AloeBC」の振る舞いを定義し、<br>
        WASM 側は「命令セットをほぼ 1:1 でマッピングする」「GC は WASM 実行系に任せる」という方針を示します。
      </div>
    </section>

    <!-- 1. 実行モデル -->
    <section id="vm-ch1" class="chapter">
      <h2>1. 実行モデル</h2>

      <h3>1.1 スタックマシンとしてのモデル</h3>
      <ul>
        <li>VM は <strong>オペランドスタック</strong> を中心としたスタックマシンである。</li>
        <li>算術命令・比較命令などはスタックトップから値を取り出し、結果を再びスタックに積む。</li>
        <li>ローカル変数・引数は <strong>フレーム内ローカル領域</strong> に保持される。</li>
      </ul>

      <h3>1.2 実行単位</h3>
      <ul>
        <li>実行単位は「関数（メソッド）」であり、Aloe のメソッド／main ブロックに対応する。</li>
        <li>各関数は AloeBC 内で <strong>関数テーブル</strong> に登録されており、エントリには
          <ul>
            <li>コードオフセット</li>
            <li>ローカル変数数</li>
            <li>引数数</li>
            <li>例外ハンドラテーブルへの参照</li>
          </ul>
          などを保持する。
        </li>
      </ul>

      <h3>1.3 例外処理モデル</h3>
      <ul>
        <li>Aloe の <code>try / catch / finally</code> は VM レベルでも例外ハンドラテーブルに展開される。</li>
        <li>例外は VM 内で <strong>オブジェクト参照</strong> として扱い、スロー時にスタックを巻き戻す。</li>
        <li>WASM 実装では、ホストの例外モデルまたは多値戻り＋エラーコードパターンへマッピングする。</li>
      </ul>

      <h3>1.4 実行モード</h3>
      <ul>
        <li><strong>VM 実行モード</strong>:
          <ul>
            <li>C# 実装 VM が AloeBC を直接読み込み、命令を逐次解釈または JIT コンパイルする。</li>
          </ul>
        </li>
        <li><strong>WASM ネイティブモード</strong>:
          <ul>
            <li>aloe2wasm により、AloeVM 命令列をほぼ 1:1 対応で WASM 命令列へ変換し、AloeVM 自体は存在しない。</li>
            <li>GC・低レベルのメモリ管理は WASM ランタイム（実行系）に委譲する。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 2. VM 値モデル -->
    <section id="vm-ch2" class="chapter">
      <h2>2. VM 値モデル</h2>

      <h3>2.1 VM 値のカテゴリ</h3>
      <p>VM 上で扱う値は、概念的に以下のカテゴリに分かれる。</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>例</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>整数（int32）</td>
              <td><code>int</code>, <code>enum</code>, <code>bitfield enum</code></td>
              <td>32bit 符号付き整数。enum は常に int ベース。</td>
            </tr>
            <tr>
              <td>整数（その他）</td>
              <td><code>byte</code></td>
              <td>内部的には int32 にパックして扱ってもよい。</td>
            </tr>
            <tr>
              <td>浮動小数点</td>
              <td><code>float</code></td>
              <td>32bit IEEE754。</td>
            </tr>
            <tr>
              <td>decimal</td>
              <td><code>decimal</code></td>
              <td>C# decimal と同程度の精度を持つ 128bit 近似表現（実装依存）。</td>
            </tr>
            <tr>
              <td>bool</td>
              <td><code>bool</code></td>
              <td>内部表現は 1byte or int32。命令セットでは int と同じ比較命令を再利用可。</td>
            </tr>
            <tr>
              <td>char</td>
              <td><code>char</code></td>
              <td>Unicode コードポイント（実装は UTF-16 でも UTF-32 でもよい）。</td>
            </tr>
            <tr>
              <td>オブジェクト参照</td>
              <td><code>class</code> インスタンス、<code>string</code></td>
              <td>ヒープオブジェクトへのハンドル（例: 64bit ID）。</td>
            </tr>
            <tr>
              <td>構造体</td>
              <td><code>struct</code></td>
              <td>VM 上では「値の塊」。実装により inline / boxed を選択。</td>
            </tr>
            <tr>
              <td>pipe</td>
              <td><code>pipe&lt;T&gt;</code></td>
              <td>VM レベルで専用タグを持つ。実装は OS パイプ／ソケット等。</td>
            </tr>
            <tr>
              <td>filter</td>
              <td><code>filter Foo</code></td>
              <td>VM レベルで専用タグ。関数＋接続情報のラッパ。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <strong>enum / bitfield enum</strong> は VM レベルでは <strong>常に int32</strong> として表現される。<br>
        bitfield enum の有効ビットは 0～31（最大 32 bit）に制限される。
      </div>

      <h3>2.2 AloeObject とヒープオブジェクト</h3>
      <p>
        C# 実装 VM では、ヒープ上のオブジェクトは <strong>オブジェクト ID（例: 64bit 整数）</strong> で識別される。
      </p>
      <ul>
        <li>VM 上でのオブジェクト値:
          <ul>
            <li>スタックやローカルには単に <code>objectId: long</code> が積まれる（<strong>AloeObject</strong>）。</li>
          </ul>
        </li>
        <li>メモリマネージャ側で、オブジェクト ID → メタデータを管理する:
          <ul>
            <li>クラス／構造体の <strong>フィールドリスト（参照スロット定義）</strong></li>
            <li>フィールドごとの <strong>値スロット</strong>（プリミティブ値 or 他オブジェクト ID）</li>
            <li>trait 合成後の最終的なフィールドレイアウト</li>
          </ul>
        </li>
        <li>構造体も同じ枠組みで扱える:
          <ul>
            <li>値型であっても、ヒープ上に配置する場合は同様に「フィールドリスト＋値スロット」で管理可能。</li>
            <li>VM の最適化次第で、スタック上に inline 展開するかどうかを切り替えられる。</li>
          </ul>
        </li>
      </ul>

      <h3>2.3 pipe / filter の VM タグ</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> と <code>filter</code> は、クラスインスタンスとは別の <strong>専用 VM 値タグ</strong> を持つ。</li>
        <li>ただし WASM 対応のため、内部表現は「ref 型」（例: <code>externref</code> / <code>funcref</code> / <code>anyref</code> 相当）にマッピングしやすい構造にする。</li>
        <li>pipe は「末端バッファ＋同期オブジェクトへの参照」、filter は「バインド済みハンドラ関数＋ in/out メタ情報」などを持つ。</li>
      </ul>
    </section>

    <!-- 3. コールスタックとフレーム -->
    <section id="vm-ch3" class="chapter">
      <h2>3. コールスタックとフレーム</h2>

      <h3>3.1 フレーム構造</h3>
      <p>各関数呼び出しは「フレーム」を生成する。フレームは少なくとも以下を持つ。</p>
      <ul>
        <li>戻りアドレス（次に実行する命令の PC）</li>
        <li>前のフレームへのリンク</li>
        <li>ローカル変数領域</li>
        <li>引数領域</li>
        <li>一時値スロット（必要なら）</li>
      </ul>

      <h3>3.2 呼び出し規約（概要）</h3>
      <ul>
        <li>関数呼び出し命令（例: <code>CALL</code>）は、引数をスタック上に積んだ状態で実行される。</li>
        <li>フレーム作成後、引数はローカル領域に移される（またはスタック上に残したままインデックス指定）。</li>
        <li>戻り値はスタックトップに 1 つだけ積まれる。</li>
        <li>void 関数は戻り値を積まない。</li>
      </ul>

      <h3>3.3 例外フレーム</h3>
      <ul>
        <li>例外ハンドラテーブルに基づき、スタックのどこまで巻き戻すかを決定する。</li>
        <li>巻き戻し後、catch ブロック先頭にジャンプし、例外オブジェクトをローカルまたはスタックに渡す。</li>
      </ul>
    </section>

    <!-- 4. ヒープとメモリ管理方針 -->
    <section id="vm-ch4" class="chapter">
      <h2>4. ヒープとメモリ管理方針（C# 実装 VM）</h2>

      <h3>4.1 スロットベースのヒープレイアウト</h3>
      <ul>
        <li>C# 実装 VM のヒープは、固定長スロットの配列として管理される。</li>
        <li>1 スロットあたりのバイト数は設定ファイルの <code>memory.slot_size_bytes</code> で指定し、
          未指定時のデフォルト値は <strong>16 バイト</strong> とする。</li>
        <li>すべてのヒープオブジェクトは、スロット境界（スロット先頭アドレス）から開始し、
          1 個以上の <strong>連続スロット</strong> を占有する。
          <ul>
            <li>オブジェクトの「長さ」はスロット数（<code>lengthSlots</code>）で管理される。</li>
            <li>実際のバイト長は <code>lengthSlots × slot_size_bytes</code> となる。</li>
          </ul>
        </li>
        <li>実装上、ヒープは 1 つまたは複数の「アリーナ」に分割されてもよい。
          <ul>
            <li>単一アリーナ構成の場合：全オブジェクトを 1 つのスロット配列で管理する。</li>
            <li>将来の最適化として、サイズクラスごとに別アリーナ（16/32/64 バイトなど）を持つ構成も許容する。</li>
          </ul>
        </li>
      </ul>

      <h3>4.2 ハンドルと変数テーブル</h3>
      <ul>
        <li>第 2 章で述べたとおり、ヒープオブジェクトは <strong>オブジェクト ID（ハンドル）</strong> によって識別される。</li>
        <li>VM 内部では、ハンドルから実際のヒープ上の位置を引くために、
          <strong>変数テーブル（またはオブジェクトテーブル）</strong> を持つ。
          典型的には以下の情報を保持する：
          <ul>
            <li>所属アリーナ ID</li>
            <li>先頭スロット index（整数）</li>
            <li>占有スロット数（<code>lengthSlots</code>）</li>
            <li>参照カウント（refcount）</li>
            <li>型情報への参照（クラス／構造体のメタデータ ID）</li>
          </ul>
        </li>
        <li>VM のオペコードやランタイムは、<strong>生ポインタではなくハンドル</strong> を扱う。
          <ul>
            <li>ハンドル → テーブル → 先頭スロットアドレス、という 2 段階で物理メモリに到達する。</li>
            <li>オブジェクトの移動（コンパクション）が発生しても、変数テーブルの 1 箇所を書き換えるだけで済む。</li>
          </ul>
        </li>
      </ul>

      <h3>4.3 参照カウントによる寿命管理</h3>
      <ul>
        <li>各ヒープオブジェクトは <strong>参照カウント（reference count）</strong> を持つ。</li>
        <li>参照カウントの増減タイミング（例）:
          <ul>
            <li>ローカル変数やフィールドにハンドルを格納する際にインクリメント。</li>
            <li>変数がスコープから抜ける／フィールドから別の値に置き換えられるときにデクリメント。</li>
          </ul>
        </li>
        <li>参照カウントが 0 になったオブジェクトは「到達不能」とみなし、
          そのオブジェクトが占有していたスロットを次のように扱う：
          <ul>
            <li>スロットの内容を 0 で初期化する（論理的に「空き」として扱いやすくする）。</li>
            <li>スロット状態テーブル（<code>slot_used[i] = false</code> など）を更新し、空きスロットとしてマークする。</li>
          </ul>
        </li>
        <li>循環参照（<code>A → B → A</code> 等）は参照カウントだけでは解放できないため、
          <strong>実装上の制約または将来の補助 GC</strong> によって対処する：
          <ul>
            <li>言語レベルで強い循環を作りにくい設計（所有権／weak 参照）を推奨する。</li>
            <li>または必要に応じて、低優先度のマーク＆スイープを併用し、循環のみを回収してもよい。</li>
          </ul>
        </li>
      </ul>

      <h3>4.4 アクセス時スライディング・コンパクション</h3>
      <p>
        AloeVM のヒープは、断片化を防ぐために <strong>「アクセス時に少しだけ詰める」スライディング・コンパクション</strong> を行う。
        これは、オブジェクトにアクセスしたタイミングでそのオブジェクトを前方にスライドさせ、
        スロットの空きを徐々に前方へ集約していく仕組みである。
      </p>
      <ul>
        <li>変数ハンドルにアクセスする命令は、概念的に以下の処理を行う：
          <ol>
            <li>ハンドルから変数テーブルを引き、<code>(arenaId, slotIndex, lengthSlots)</code> を取得する。</li>
            <li>同じアリーナ内で、<code>slotIndex - lengthSlots</code> から <code>slotIndex - 1</code> までのスロットが
              すべて空き（未使用）であるかを確認する。
              <ul>
                <li>単純化のため、実装では「スロット状態テーブルのフラグ」を見るだけでもよい。</li>
              </ul>
            </li>
            <li>もし上記の範囲が完全に空きであれば、
              <ul>
                <li>オブジェクトを前方に <code>lengthSlots</code> スロット分スライドさせる（コピー）。</li>
                <li>旧領域（元の <code>slotIndex ～ slotIndex + lengthSlots - 1</code>）を 0 クリアし、空きスロットとしてマークする。</li>
                <li>変数テーブル内の <code>slotIndex</code> を <code>slotIndex - lengthSlots</code> に更新する。</li>
              </ul>
            </li>
            <li>更新後の先頭スロットから、実際のオブジェクトフィールドにアクセスする。</li>
          </ol>
        </li>
        <li>このルールにより、1 回のアクセスで触るメモリ量は高々「自分のサイズ（<code>lengthSlots</code> スロット）」に抑えられる。
          <ul>
            <li>「ヒープ全体を走査して一気に詰める」タイプの stop-the-world GC を避け、
              断片化解消コストを <strong>アクセスに分散</strong> できる。</li>
          </ul>
        </li>
        <li>すべてのオブジェクトはスロット境界から始まるため、スライド後も必ずスロット境界に揃った整合性の取れたレイアウトが維持される。</li>
        <li>この「アクセス時スライド」は必須ではなく、実装によっては
          <ul>
            <li>頻度を下げる（一定回数に 1 回だけ実施）</li>
            <li>1 アクセスあたりの最大移動スロット数に上限を設ける</li>
          </ul>
          などの調整を行ってよい。
        </li>
      </ul>

      <h3>4.5 アロケーション戦略</h3>
      <ul>
        <li>新しいオブジェクトを確保する際、メモリマネージャは以下を行う：
          <ol>
            <li>必要なスロット数 <code>lengthSlots</code> を計算する（<code>ceil(objectSizeBytes / slot_size_bytes)</code>）。</li>
            <li>現在のアリーナ内、または複数アリーナの中から、<strong>十分な連続空きスロット</strong> を探索する。</li>
            <li>見つかった先頭スロットにオブジェクトを配置し、スロット状態テーブルと変数テーブルを更新する。</li>
          </ol>
        </li>
        <li>空きスロットの管理方法は実装に依存するが、典型的には以下のいずれか：
          <ul>
            <li>単純な線形探索（プロトタイプ段階）</li>
            <li>連続スロット範囲のフリーリスト</li>
            <li>ビットマップ＋first-fit/best-fit アルゴリズム</li>
          </ul>
        </li>
        <li>どのアリーナにも必要な連続空きスロットが見つからない場合：
          <ul>
            <li>アクセス時スライドの頻度を一時的に上げて断片化を軽減する。</li>
            <li>またはヒープを拡張し、新しいアリーナを追加する。</li>
          </ul>
        </li>
      </ul>

      <h3>4.6 delete と解放タイミング</h3>
      <ul>
        <li>Aloe 言語の <code>delete x;</code> は、「変数 <code>x</code> が保持しているハンドルへの参照を切る」という意味であり、
          その瞬間に物理的なメモリが解放されることは <strong>保証されない</strong>。</li>
        <li>参照カウントが 0 になったオブジェクトは、次のタイミングで解放処理対象となる：
          <ul>
            <li>カウンタが 0 になった瞬間に、そのオブジェクトのスロットを 0 クリアし、空きスロットとしてマークする。</li>
            <li>または低優先度のバックグラウンド処理で順次解放してもよい（実装依存）。</li>
          </ul>
        </li>
        <li>したがって、Aloe プログラムは「delete 直後に必ずヒープ使用量が減る」とは期待してはいけない。
          あくまで <strong>「そのオブジェクトはもはや利用されない」という論理的な宣言</strong> に過ぎない。</li>
      </ul>

      <h3>4.7 WASM 実装時のメモリ管理</h3>
      <div class="note">
        WASM ネイティブモードでは、AloeVM 独自のスロット制メモリ管理および参照カウントは必須ではない。<br>
        GC・メモリ確保・解放は <strong>WASM 実行系およびホストランタイムに委譲</strong>する。
      </div>
      <ul>
        <li>Aloe のオブジェクトは、WASM の <code>struct</code> / <code>array</code> / <code>ref</code> などへ直接マッピングされうる。</li>
        <li>WASM GC やホストランタイム（例: .NET, JVM, JS）の GC が責務を負うため、
          本章で述べたスロットレイアウト・アクセス時スライドは C# 実装 VM の内部仕様に留まる。</li>
        <li>aloe2wasm などのコンパイラは、AloeVM の抽象メモリモデルを維持しつつ、
          実際の GC はターゲット環境の仕組みに任せることが推奨される。</li>
      </ul>
    </section>

    <!-- 5. パイプ / フィルタ -->
    <section id="vm-ch5" class="chapter">
      <h2>5. パイプ / フィルタの VM 表現</h2>

      <h3>5.1 pipe&lt;T&gt;</h3>
      <ul>
        <li>VM レベルで <strong>PIPE</strong> タグを持つ値として表現する。</li>
        <li>内部には以下のような情報を持つ想定:
          <ul>
            <li>バッファ（リングバッファ／キュー）</li>
            <li>同期プリミティブ（ロック／条件変数など）</li>
            <li>要素の型情報（ランタイム型情報への参照）</li>
          </ul>
        </li>
        <li>複数スレッドからアクセスしても壊れないよう、実装はスレッドセーフであること。</li>
        <li>実装例:
          <ul>
            <li>OS パイプ／ソケット</li>
            <li>メモリマップドファイル上のリングバッファ</li>
          </ul>
        </li>
      </ul>

      <h3>5.2 filter</h3>
      <ul>
        <li>filter は専用タグ（FILTER）を持つ値として表現される。</li>
        <li>filter 値は、概念的には
          <ul>
            <li>「bound 関数へのポインタ」</li>
            <li>フィルタ定義メタ情報（in/out 型）</li>
          </ul>
          をまとめた構造体。
        </li>
        <li>ユーザ定義フィルタも同じ仕組みで表現できる。</li>
      </ul>

      <h3>5.3 パイプライン文の実行モデル</h3>
      <pre><code class="language-aloe">
A | filter(F) | B;
      </code></pre>
      <ul>
        <li>VM はこの文を「接続構築命令」の列に展開する。</li>
        <li>典型的な流れ:
          <ol>
            <li><code>A</code> の出力 pipe を解決する。</li>
            <li><code>filter(F)</code> のインスタンスを生成し、<code>bound(input, output)</code> を別タスク／スレッドとして起動。</li>
            <li>出力 pipe を <code>B</code> に接続する。</li>
          </ol>
        </li>
        <li>実装によっては、複数フィルタを 1 スレッド内で順次処理する最適化も可能。</li>
      </ul>

      <h3>5.4 パイプのライフサイクルと VM 命令</h3>
      <p>
        pipe は VM レベルでは、概ね次の 4 フェーズを持つライフサイクルとして扱う：
        <strong>生成</strong> → <strong>接続</strong> → <strong>切断</strong> → <strong>削除</strong>。
        それぞれのフェーズは、7 章で定義する「pipe / filter / 接続カテゴリ（カテゴリ ID = 0x0A）」の命令によって操作される。
      </p>
      <ul>
        <li><strong>生成フェーズ（Create）</strong>
          <ul>
            <li>新しい pipe インスタンスを確保し、バッファや同期オブジェクトを初期化する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_NEW</code>:
                  <ul>
                    <li>引数として要素型 ID、バッファサイズ、オプションフラグなどを取る。</li>
                    <li>戻り値として pipe ハンドル（VM 値としての PIPE タグ付きハンドル）をスタックに積む。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>接続フェーズ（Connect）</strong>
          <ul>
            <li>既存の pipe に対して、producer / consumer / filter を接続する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_BIND_PRODUCER</code>:
                  <ul>
                    <li>pipe ハンドルと producer 側エンドポイント（メソッド／タスク）を結び付ける。</li>
                  </ul>
                </li>
                <li><code>PIPE_BIND_CONSUMER</code>:
                  <ul>
                    <li>pipe ハンドルと consumer 側エンドポイントを結び付ける。</li>
                  </ul>
                </li>
                <li><code>PIPE_CONNECT</code>:
                  <ul>
                    <li>複数の pipe と filter をまとめて「パイプライン」として接続する高レベル命令として定義してもよい。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>切断フェーズ（Disconnect）</strong>
          <ul>
            <li>producer / consumer / filter を pipe から切り離し、新たなデータの流入・流出を止める。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_DISCONNECT</code>:
                  <ul>
                    <li>指定したエンドポイントを pipe から切り離す。</li>
                    <li>既にバッファ内に存在するデータの扱い（破棄する／最後まで読み出させる）は実装ポリシーで決める。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>削除フェーズ（Delete / Close）</strong>
          <ul>
            <li>pipe 自体をクローズし、関連するバッファや同期オブジェクトを解放する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_CLOSE</code>:
                  <ul>
                    <li>pipe ハンドルをクローズし、参照カウントをデクリメントする。</li>
                    <li>参照カウントが 0 になった時点で、ヒープ上の pipe オブジェクトが解放候補となる。</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Aloe 言語レベルの <code>delete</code> や <code>with</code> ブロック終了時の暗黙クローズは、
              これらの命令にコンパイルされる想定である。</li>
          </ul>
        </li>
      </ul>
      <div class="note">
        producer / consumer として動作するコードは、通常は「通常の関数／メソッド＋スレッド（またはタスク）」の組み合わせで表現される。<br>
        必要に応じて、<code>PRODUCER_START</code>, <code>PRODUCER_STOP</code>, <code>CONSUMER_START</code>, <code>CONSUMER_STOP</code> のような
        制御専用命令を 0x0A カテゴリ内に追加してもよい。
      </div>
    </section>

    <!-- 6. AloeBC バイナリ形式 -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC バイナリ形式</h2>

      <h3>6.1 全体構造</h3>
      <p>AloeBC（Aloe Byte Code）は、AloeVM 向けコンパイル結果を格納するバイナリフォーマットである。</p>

      <h3>6.2 ヘッダ</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>オフセット</th>
              <th>サイズ</th>
              <th>フィールド</th>
              <th>内容</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 byte</td>
              <td>Magic</td>
              <td>ASCII 文字列 <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>メジャーバージョン</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>マイナーバージョン</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>ビルド番号</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Reserved</td>
              <td>予約（0 固定）</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 byte</td>
              <td>HeaderSize</td>
              <td>ヘッダ全体のサイズ（リトルエンディアン）</td>
            </tr>
            <tr>
              <td>14</td>
              <td>4 byte</td>
              <td>ConstPoolOffset</td>
              <td>定数プールの先頭オフセット</td>
            </tr>
            <tr>
              <td>18</td>
              <td>4 byte</td>
              <td>TypeTableOffset</td>
              <td>型テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>22</td>
              <td>4 byte</td>
              <td>FuncTableOffset</td>
              <td>関数テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>26</td>
              <td>4 byte</td>
              <td>CodeSectionOffset</td>
              <td>コードセクションの先頭オフセット</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>エンディアンは <strong>リトルエンディアン</strong> を前提とする。</p>

      <h3>6.3 定数プール（概要）</h3>
      <ul>
        <li>文字列リテラル、数値リテラル、型情報などを一元管理する。</li>
        <li>各エントリは「タグ + 長さ + 本体」で構成される可変長レコード。</li>
        <li>タグの例:
          <ul>
            <li>0x01: UTF-8 文字列</li>
            <li>0x02: int32</li>
            <li>0x03: float32</li>
            <li>0x04: decimal</li>
          </ul>
        </li>
      </ul>

      <h3>6.4 型テーブル（概要）</h3>
      <ul>
        <li>各 Aloe 型（class / struct / enum / bitfield enum / pipe&lt;T&gt; など）に ID を割り当てる。</li>
        <li>enum / bitfield enum は VM 上では <strong>int32 値型</strong> としてフラグ付けされる。</li>
        <li>bitfield enum の有効ビット数（0～31）はメタ情報として保持してもよい（警告発生などに利用）。</li>
      </ul>

      <h3>6.5 関数テーブル・コードセクション</h3>
      <ul>
        <li>関数テーブル:
          <ul>
            <li>関数シグネチャ（引数の型、戻り値の型）</li>
            <li>ローカル変数の数</li>
            <li>コードセクション内のオフセット・長さ</li>
          </ul>
        </li>
        <li>コードセクション:
          <ul>
            <li>VM 命令列をバイト列として格納。</li>
            <li>命令セットの詳細は第 7 章参照。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 7. 命令セットと WASM 対応 -->
    <section id="vm-ch7" class="chapter">
      <h2>7. 命令セットと WASM 対応（概要）</h2>

      <h3>7.1 命令カテゴリ</h3>
      <p>命令セットはおおよそ以下のカテゴリに分かれる想定であり、各カテゴリには 1 バイトのカテゴリ ID を割り当てる。</p>
      <ul>
        <li>スタック操作命令
          <ul>
            <li>PUSH, POP, DUP, SWAP など</li>
          </ul>
        </li>
        <li>算術・論理命令
          <ul>
            <li>ADD, SUB, MUL, DIV, MOD</li>
            <li>AND, OR, XOR, SHL, SHR</li>
          </ul>
        </li>
        <li>比較命令
          <ul>
            <li>CMPEQ, CMPNE, CMPLT, CMPLE, CMPGT, CMPGE</li>
          </ul>
        </li>
        <li>制御フロー命令
          <ul>
            <li>JMP, JMP_IF_TRUE, JMP_IF_FALSE</li>
          </ul>
        </li>
        <li>関数呼び出し命令
          <ul>
            <li>CALL, RET</li>
          </ul>
        </li>
        <li>オブジェクト操作命令
          <ul>
            <li>NEWOBJ, GETFIELD, SETFIELD など</li>
          </ul>
        </li>
        <li>配列・コレクション操作命令（将来）</li>
        <li>pipe / filter / producer / consumer / 接続・切断命令</li>
        <li>例外処理・VM 管理・デバッグ命令</li>
      </ul>

      <div class="note">
        命令セットの「数値（opcode）」「バイナリフォーマットとしての具体的ビット配置」は<br>
        まだ確定しておらず、今後「命令セット表」として定義する予定。
      </div>

      <h3>7.2 命令 ID の構成（カテゴリ + 連番）</h3>
      <p>
        AloeVM の各命令には、<strong>16bit（2 バイト）の命令 ID</strong> を割り当てる。<br>
        命令 ID は上位 1 バイトを <strong>カテゴリ ID</strong>、下位 1 バイトを <strong>カテゴリ内連番</strong> として扱う。
      </p>
      <ul>
        <li>16bit 命令 ID の構成:
          <ul>
            <li>上位 8bit: カテゴリ ID（例: スタック操作 = 0x01, 算術 = 0x02 など）</li>
            <li>下位 8bit: カテゴリ内での連番（そのカテゴリのオペコード表の並び順）</li>
          </ul>
        </li>
        <li>数式で表すと、命令 ID は次のように求めることができる：
          <pre><code>OpcodeID = (Category &lt;&lt; 8) | IndexInCategory</code></pre>
        </li>
        <li>具体例:
          <ul>
            <li>スタック操作カテゴリ（カテゴリ ID = <code>0x01</code>）の 1 番目の命令 → <code>0x0101</code></li>
            <li>同カテゴリの 2 番目の命令 → <code>0x0102</code></li>
            <li>算術カテゴリ（カテゴリ ID = <code>0x02</code>）の 3 番目の命令 → <code>0x0203</code></li>
          </ul>
        </li>
      </ul>

      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ ID（上位 1 バイト）</th>
              <th>カテゴリ名（例）</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0x01</td>
              <td>スタック操作命令</td>
              <td><code>PUSH</code>, <code>POP</code>, <code>DUP</code>, <code>SWAP</code> など</td>
            </tr>
            <tr>
              <td>0x02</td>
              <td>算術命令</td>
              <td><code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>, <code>MOD</code> など</td>
            </tr>
            <tr>
              <td>0x03</td>
              <td>論理・ビット演算命令</td>
              <td><code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>SHL</code>, <code>SHR</code> など</td>
            </tr>
            <tr>
              <td>0x04</td>
              <td>比較命令</td>
              <td><code>CMPEQ</code>, <code>CMPNE</code>, <code>CMPLT</code>, <code>CMPLE</code>, <code>CMPGT</code>, <code>CMPGE</code></td>
            </tr>
            <tr>
              <td>0x05</td>
              <td>制御フロー命令</td>
              <td><code>JMP</code>, <code>JMP_IF_TRUE</code>, <code>JMP_IF_FALSE</code> など</td>
            </tr>
            <tr>
              <td>0x06</td>
              <td>呼び出し・戻り命令</td>
              <td><code>CALL</code>, <code>RET</code> など</td>
            </tr>
            <tr>
              <td>0x07</td>
              <td>メモリアクセス命令</td>
              <td>ローカル／引数／グローバル／フィールドの load/store など</td>
            </tr>
            <tr>
              <td>0x08</td>
              <td>オブジェクト / 配列命令</td>
              <td><code>NEWOBJ</code>, <code>NEWARR</code>, <code>GETFIELD</code>, <code>SETFIELD</code> など</td>
            </tr>
            <tr>
              <td>0x09</td>
              <td>例外・エラー命令</td>
              <td><code>THROW</code>, <code>RETHROW</code>, <code>LEAVE</code> など</td>
            </tr>
            <tr>
              <td>0x0A</td>
              <td>pipe / filter / 接続命令</td>
              <td>pipe 生成・接続・切断・producer/consumer 起動など</td>
            </tr>
            <tr>
              <td>0x0B</td>
              <td>VM 管理・デバッグ命令</td>
              <td><code>NOP</code>, <code>HALT</code>, <code>BREAKPOINT</code> など</td>
            </tr>
            <tr>
              <td>0xF0〜0xFF</td>
              <td>実装依存・実験用命令</td>
              <td>特定実装でのみ使用される拡張命令の予約領域</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        具体的なオペコード表では、各カテゴリごとに「カテゴリ内連番（下位 1 バイト）」を 0x01 から順に割り当てる。<br>
        デバッグログやダンプでは、<code>0x0A03 (PIPE_DISCONNECT)</code> のように 16 進数表現とニーモニックの両方を表示することを推奨する。
      </div>

      <h3>7.3 暫定オペコード表（抜粋）</h3>
      <p>
        実装を始める際のたたき台として、いくつか代表的な命令に暫定的な命令 ID を割り当てておく。<br>
        ここに示す値はプロトタイプ用であり、最終版では変更される可能性がある。
      </p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Opcode ID（16進）</th>
              <th>カテゴリ</th>
              <th>連番（下位バイト）</th>
              <th>ニーモニック</th>
              <th>概要</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0x0101</td>
              <td>スタック操作</td>
              <td>0x01</td>
              <td>PUSH_I32</td>
              <td>即値 int32 をスタックに積む。</td>
            </tr>
            <tr>
              <td>0x0102</td>
              <td>スタック操作</td>
              <td>0x02</td>
              <td>POP</td>
              <td>スタックトップを 1 つ捨てる。</td>
            </tr>
            <tr>
              <td>0x0103</td>
              <td>スタック操作</td>
              <td>0x03</td>
              <td>DUP</td>
              <td>スタックトップを 1 つ複製する。</td>
            </tr>

            <tr>
              <td>0x0201</td>
              <td>算術</td>
              <td>0x01</td>
              <td>ADD_I32</td>
              <td>int32 を 2 つ取り出して加算し、結果を積む。</td>
            </tr>
            <tr>
              <td>0x0202</td>
              <td>算術</td>
              <td>0x02</td>
              <td>SUB_I32</td>
              <td>int32 を 2 つ取り出して減算し、結果を積む。</td>
            </tr>

            <tr>
              <td>0x0401</td>
              <td>比較</td>
              <td>0x01</td>
              <td>CMPEQ_I32</td>
              <td>int32 の等値比較を行い、bool を積む。</td>
            </tr>

            <tr>
              <td>0x0501</td>
              <td>制御フロー</td>
              <td>0x01</td>
              <td>JMP</td>
              <td>絶対または相対オフセットへ無条件ジャンプ。</td>
            </tr>
            <tr>
              <td>0x0502</td>
              <td>制御フロー</td>
              <td>0x02</td>
              <td>JMP_IF_TRUE</td>
              <td>スタックトップが true の場合にのみジャンプ。</td>
            </tr>

            <tr>
              <td>0x0601</td>
              <td>呼び出し</td>
              <td>0x01</td>
              <td>CALL</td>
              <td>関数テーブル上の ID を指定して呼び出し、新しいフレームを作成。</td>
            </tr>
            <tr>
              <td>0x0602</td>
              <td>呼び出し</td>
              <td>0x02</td>
              <td>RET</td>
              <td>現在のフレームを破棄し、呼び出し元へ復帰。</td>
            </tr>

            <tr>
              <td>0x0701</td>
              <td>メモリアクセス</td>
              <td>0x01</td>
              <td>LDLOC</td>
              <td>ローカル変数スロットから値を読み出して積む。</td>
            </tr>
            <tr>
              <td>0x0702</td>
              <td>メモリアクセス</td>
              <td>0x02</td>
              <td>STLOC</td>
              <td>スタックトップをローカル変数スロットに書き込む。</td>
            </tr>

            <tr>
              <td>0x0A01</td>
              <td>pipe / 接続</td>
              <td>0x01</td>
              <td>PIPE_NEW</td>
              <td>新しい pipe インスタンスを生成し、ハンドルを積む。</td>
            </tr>
            <tr>
              <td>0x0A02</td>
              <td>pipe / 接続</td>
              <td>0x02</td>
              <td>PIPE_CONNECT</td>
              <td>pipe と filter / producer / consumer 間の接続を構築する。</td>
            </tr>
            <tr>
              <td>0x0A03</td>
              <td>pipe / 接続</td>
              <td>0x03</td>
              <td>PIPE_DISCONNECT</td>
              <td>指定されたエンドポイントを pipe から切断する。</td>
            </tr>
            <tr>
              <td>0x0A04</td>
              <td>pipe / 接続</td>
              <td>0x04</td>
              <td>PIPE_CLOSE</td>
              <td>pipe をクローズし、関連リソースの解放をトリガする。</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="note">
        ここで挙げた命令 ID はあくまで「暫定のたたき台」であり、実装の過程で不足命令の追加や番号の再配置を行ってよい。<br>
        ただし「カテゴリ ID + 連番」という 2 バイト構成ルール自体は変えない前提とする。
      </div>

      <h3>7.4 WASM への 1:1 マッピング方針</h3>
      <ul>
        <li>基本算術・比較命令は、可能な限り WASM の <code>i32.add</code>, <code>i32.lt_s</code> などへ 1:1 でマッピングする。</li>
        <li>スタック操作も WASM のスタックマシンと概念的に一致するため、ほぼそのまま変換可能。</li>
        <li>例外処理は、WASM の exception handling 拡張またはエラーコード + ブロック構造の組み合わせで表現する。</li>
        <li>pipe / filter は、WASM の <code>ref</code> 型＋ホスト関数を用いて実装されることが多い。</li>
      </ul>

      <h3>7.5 aloe2wasm の役割</h3>
      <ul>
        <li>Aloe ソース → AloeBC → AloeVM 実行 という経路とは別に、
          <ul>
            <li>Aloe ソース → 中間 IR → WASM という <strong>ネイティブ WASM ビルド</strong> 経路を用意する。</li>
          </ul>
        </li>
        <li>このとき、AloeVM 命令セットと WASM 命令セットが近いほど、コンパイラ実装が単純になる。</li>
        <li>理想的には「AloeVM 命令列をそのまま WASM にシリアライズするだけ」で動作するレベルを目指す。</li>
      </ul>
    </section>

    <!-- 8. 未決事項・TODO -->
    <section id="vm-ch8" class="chapter">
      <h2>8. 未決事項・TODO</h2>

      <h3>8.1 まだ決まっていない事項</h3>
      <ul>
        <li>各命令の opcode 割り当てと、正確なバイナリ形式（命令セット表）</li>
        <li>例外ハンドラテーブルの具体的なフォーマット（範囲指定、catch 種別など）</li>
        <li>構造体の inline 展開と box/unbox の扱い</li>
        <li>スロットアリーナ構成の詳細（単一アリーナか複数サイズクラスか）</li>
        <li>参照カウントと循環検出（補助 GC）を併用する場合のアルゴリズム</li>
        <li>pipe / filter のスレッドモデル（1 フィルタ 1 スレッドか、ワーカー共有か）</li>
        <li>WASM 版での pipe / filter の標準 ABI（ホストとのインターフェース）</li>
      </ul>

      <h3>8.2 将来の拡張候補</h3>
      <ul>
        <li>JIT コンパイル層（ホット関数のネイティブコード化）</li>
        <li>デバッガフック（ブレークポイント・ステップ実行・変数ウォッチ）</li>
        <li>プロファイラ API（実行時間・割り当てメモリの計測）</li>
        <li>分散実行（複数プロセス／ノードにまたがる pipe のサポート）</li>
      </ul>

      <div class="note">
        現在の仕様書の内容だけでも、<strong>Aloe コンパイラ / C# 実装の AloeVM / aloe2wasm のプロトタイプ</strong>は実装可能なレベルを目指している。<br>
        ただし、命令セット表やメモリ管理の細部は試行錯誤しつつブラッシュアップしていく前提。
      </div>
    </section>

  </main>
</div>
</body>
</html>
```
