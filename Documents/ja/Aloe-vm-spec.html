<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="edit-version" content="7" />
  <meta name="edit-date" content="2025-12-03T19:31:09+09:00" />
  <title>AloeVM 仕様書（ドラフト）</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.7;
      color: #222;
    }
    .layout {
      display: flex;
      min-height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #111827;
      color: #f9fafb;
      padding: 1rem 0.75rem 2rem;
      position: sticky;
      top: 0;
      align-self: flex-start;
      max-height: 100vh;
      overflow-y: auto;
    }
    .sidebar h1 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      padding: 0 0.25rem;
    }
    .sidebar small {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 0.75rem;
      padding: 0 0.25rem;
    }
    .nav-section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin: 0.75rem 0 0.25rem;
      padding: 0 0.25rem;
    }
    .nav-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .nav-list li {
      margin: 0;
    }
    .nav-link {
      display: block;
      padding: 0.25rem 0.5rem;
      margin: 0 0.1rem;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #e5e7eb;
      text-decoration: none;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .nav-link:hover {
      background: #374151;
    }
    .nav-link.active {
      background: #4b5563;
      color: #ffffff;
      font-weight: 600;
    }
    .content {
      flex: 1;
      padding: 1.5rem 2rem 3rem;
      max-width: 980px;
      margin: 0 auto;
    }
    .chapter {
      display: none;
      padding-bottom: 2rem;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 2rem;
    }
    .chapter.active {
      display: block;
    }
    h2, h3, h4 {
      line-height: 1.3;
    }
    h2 {
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.25rem;
      margin-top: 0;
    }
    pre {
      background: #f5f5f5;
      padding: 0.75rem 1rem;
      overflow-x: auto;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    code {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      font-size: 0.9rem;
    }
    hr {
      margin: 2rem 0;
      border: none;
      border-top: 1px solid #e5e7eb;
    }
    .note {
      padding: 0.5rem 0.75rem;
      border-left: 4px solid #888;
      background: #fafafa;
      margin: 1rem 0;
      font-size: 0.9rem;
    }
    .table-wrap {
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      font-size: 0.9rem;
      margin: 0.5rem 0 1rem;
      min-width: 60%;
    }
    th, td {
      border: 1px solid #d1d5db;
      padding: 0.35rem 0.6rem;
      text-align: left;
      vertical-align: top;
    }
    th {
      background: #f3f4f6;
      font-weight: 600;
    }
    ul, ol { padding-left: 1.3rem; }
    @media (max-width: 800px) {
      .layout { flex-direction: column; }
      .sidebar {
        width: 100%;
        position: static;
        max-height: none;
        display: flex;
        flex-wrap: wrap;
      }
      .sidebar h1, .sidebar small, .nav-section-title {
        width: 100%;
      }
      .nav-list {
        display: flex;
        flex-wrap: wrap;
      }
      .nav-list li {
        flex: 0 0 50%;
      }
      .content {
        padding: 1rem 1rem 3rem;
      }
    }
  </style>
  <script>
    function showChapter(id) {
      const chapters = document.querySelectorAll('.chapter');
      chapters.forEach(ch => ch.classList.remove('active'));
      const target = document.getElementById(id);
      if (target) target.classList.add('active');

      const links = document.querySelectorAll('.nav-link');
      links.forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector('.nav-link[data-target="' + id + '"]');
      if (activeLink) activeLink.classList.add('active');

      if (window.innerWidth <= 800) {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      const first = document.querySelector('.chapter');
      if (first) first.classList.add('active');
      const firstLink = document.querySelector('.nav-link');
      if (firstLink) firstLink.classList.add('active');

      document.querySelectorAll('.nav-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          showChapter(a.dataset.target);
        });
      });
    });
  </script>
</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h1>AloeVM 仕様書</h1>
    <small>（現時点のドラフト。今後変更・拡張される可能性があります。）</small>

    <div class="nav-section">
      <div class="nav-section-title">Chapters</div>
      <ul class="nav-list">
        <li><a class="nav-link" data-target="vm-ch0">0. 概要</a></li>
        <li><a class="nav-link" data-target="vm-ch1">1. 実行モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch2">2. VM 値モデル</a></li>
        <li><a class="nav-link" data-target="vm-ch3">3. コールスタックとフレーム</a></li>
        <li><a class="nav-link" data-target="vm-ch4">4. ヒープとメモリ管理方針</a></li>
        <li><a class="nav-link" data-target="vm-ch5">5. パイプ / フィルタの表現</a></li>
        <li><a class="nav-link" data-target="vm-ch6">6. AloeBC バイナリ形式</a></li>
        <li><a class="nav-link" data-target="vm-ch7">7. 命令セットと WASM 対応</a></li>
        <li><a class="nav-link" data-target="vm-ch8">8. 未決事項・TODO</a></li>
      </ul>
    </div>
  </aside>

  <main class="content">

    <!-- 0. 概要 -->
    <section id="vm-ch0" class="chapter">
      <h2>0. 概要</h2>
      <p>
        AloeVM は、Aloe 言語の実行用に設計された <strong>スタックベースの仮想マシン</strong> です。<br />
        ここでは以下を定義します：
      </p>
      <ul>
        <li>実行モデル（スタックマシン／フレーム構造）</li>
        <li>VM レベルの値モデル（プリミティブ・構造体・クラス・enum・pipe/filter 等）</li>
        <li>ヒープとメモリ管理の方針</li>
        <li>パイプ / フィルタの VM 上での表現</li>
        <li>AloeBC（Aloe バイトコード）バイナリ形式</li>
        <li>WebAssembly（WASM）との対応ポリシー</li>
      </ul>
      <div class="note">
        AloeVM には 2 つの想定ランタイムがあります：
        <ul>
          <li>C# 実装（.NET 上で動作する VM）</li>
          <li>WASM ネイティブ実装（aloe2wasm によって直接 WASM にコンパイルされたコード）</li>
        </ul>
        本仕様は主に「C# 実装 VM + AloeBC」の振る舞いを定義し、<br />
        WASM 側は「命令セットをほぼ 1:1 でマッピングする」「GC は WASM 実行系に任せる」という方針を示します。
      </div>
    </section>

    <!-- 1. 実行モデル -->
    <section id="vm-ch1" class="chapter">
      <h2>1. 実行モデル</h2>

      <h3>1.1 スタックマシンとしてのモデル</h3>
      <ul>
        <li>VM は <strong>オペランドスタック</strong> を中心としたスタックマシンである。</li>
        <li>算術命令・比較命令などはスタックトップから値を取り出し、結果を再びスタックに積む。</li>
        <li>ローカル変数・引数は <strong>フレーム内ローカル領域</strong> に保持される。</li>
      </ul>

      <h3>1.2 実行単位</h3>
      <ul>
        <li>実行単位は「関数（メソッド）」であり、Aloe のメソッド／main ブロックに対応する。</li>
        <li>各関数は AloeBC 内で <strong>関数テーブル</strong> に登録されており、エントリには
          <ul>
            <li>コードオフセット</li>
            <li>ローカル変数数</li>
            <li>引数数</li>
            <li>例外ハンドラテーブルへの参照</li>
          </ul>
          などを保持する。
        </li>
      </ul>

      <h3>1.3 例外処理モデル</h3>
      <ul>
        <li>Aloe の <code>try / catch / finally</code> は VM レベルでも例外ハンドラテーブルに展開される。</li>
        <li>例外は VM 内で <strong>オブジェクト参照</strong> として扱い、スロー時にスタックを巻き戻す。</li>
        <li>WASM 実装では、ホストの例外モデルまたは多値戻り＋エラーコードパターンへマッピングする。
          例外ハンドラテーブルのフォーマットは 6.6 節で定義する。</li>
      </ul>

      <h3>1.4 実行モード</h3>
      <ul>
        <li><strong>VM 実行モード</strong>:
          <ul>
            <li>C# 実装 VM が AloeBC を直接読み込み、命令を逐次解釈または JIT コンパイルする。</li>
          </ul>
        </li>
        <li><strong>WASM ネイティブモード</strong>:
          <ul>
            <li>aloe2wasm により、AloeVM 命令列をほぼ 1:1 対応で WASM 命令列へ変換し、AloeVM 自体は存在しない。</li>
            <li>GC・低レベルのメモリ管理は WASM ランタイム（実行系）に委譲する。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 2. VM 値モデル -->
    <section id="vm-ch2" class="chapter">
      <h2>2. VM 値モデル</h2>

      <h3>2.1 VM 値のカテゴリ</h3>
      <p>VM 上で扱う値は、概念的に以下のカテゴリに分かれる。</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ</th>
              <th>例</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>整数（int32）</td>
              <td><code>int</code>, <code>enum</code>, <code>bitfield enum</code></td>
              <td>32bit 符号付き整数。enum は常に int ベース。</td>
            </tr>
            <tr>
              <td>整数（その他）</td>
              <td><code>byte</code></td>
              <td>内部的には int32 にパックして扱ってもよい。</td>
            </tr>
            <tr>
              <td>浮動小数点</td>
              <td><code>float</code></td>
              <td>32bit IEEE754。</td>
            </tr>
            <tr>
              <td>decimal</td>
              <td><code>decimal</code></td>
              <td>C# decimal と同程度の精度を持つ 128bit 近似表現（実装依存）。</td>
            </tr>
            <tr>
              <td>bool</td>
              <td><code>bool</code></td>
              <td>内部表現は 1byte or int32。命令セットでは int と同じ比較命令を再利用可。</td>
            </tr>
            <tr>
              <td>char</td>
              <td><code>char</code></td>
              <td>Unicode コードポイント（実装は UTF-16 でも UTF-32 でもよい）。</td>
            </tr>
            <tr>
              <td>オブジェクト参照</td>
              <td><code>class</code> インスタンス、<code>string</code></td>
              <td>ヒープオブジェクトへのハンドル（例: 64bit ID）。</td>
            </tr>
            <tr>
              <td>構造体</td>
              <td><code>struct</code></td>
              <td>VM 上では「値の塊」であり、常に inline 値として扱われる（共通ヒープオブジェクトとしての boxing は行わない）。</td>
            </tr>
            <tr>
              <td>pipe</td>
              <td><code>pipe&lt;T&gt;</code></td>
              <td>VM レベルで専用タグを持つ。実装は OS パイプ／ソケット等。</td>
            </tr>
            <tr>
              <td>filter</td>
              <td><code>filter Foo</code></td>
              <td>VM レベルで専用タグ。関数＋接続情報のラッパ。</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note">
        <strong>enum / bitfield enum</strong> は VM レベルでは <strong>常に int32</strong> として表現される。<br />
        bitfield enum の有効ビットは 0～31（最大 32 bit）に制限される。
      </div>

      <h3>2.2 AloeObject とヒープオブジェクト</h3>
      <p>
        C# 実装 VM では、ヒープ上のオブジェクトは <strong>オブジェクト ID（例: 64bit 整数）</strong> で識別される。
      </p>
      <ul>
        <li>VM 上でのオブジェクト値:
          <ul>
            <li>スタックやローカルには単に <code>objectId: long</code> が積まれる（<strong>AloeObject</strong>）。</li>
          </ul>
        </li>
        <li>メモリマネージャ側で、オブジェクト ID → メタデータを管理する:
          <ul>
            <li>クラス／構造体の <strong>フィールドリスト（参照スロット定義）</strong></li>
            <li>フィールドごとの <strong>値スロット</strong>（プリミティブ値 or 他オブジェクト ID）</li>
            <li>trait 合成後の最終的なフィールドレイアウト</li>
          </ul>
        </li>
        <li>構造体も同じ枠組みで扱える:
          <ul>
            <li>構造体インスタンスは常に「親オブジェクト／配列／スタックフレームの一部」として inline で配置される。</li>
            <li>VM の観点では、構造体単体を AloeObject としてヒープ管理することはなく、<strong>boxing は行わない</strong>。</li>
            <li>構造体を含むクラス／配列オブジェクト自体は、通常どおり AloeObject としてスロット上に配置される。</li>
          </ul>
        </li>
      </ul>

      <h3>2.3 pipe / filter の VM タグ</h3>
      <ul>
        <li><code>pipe&lt;T&gt;</code> と <code>filter</code> は、クラスインスタンスとは別の <strong>専用 VM 値タグ</strong> を持つ。</li>
        <li>ただし WASM 対応のため、内部表現は「ref 型」（例: <code>externref</code> / <code>funcref</code> / <code>anyref</code> 相当）にマッピングしやすい構造にする。</li>
        <li>pipe は「末端バッファ＋同期オブジェクトへの参照」、filter は「バインド済みハンドラ関数＋ in/out メタ情報」などを持つ。</li>
      </ul>

      <h3>2.4 構造体のレイアウトとアライメント</h3>
      <p>構造体は VM 上では常に inline 値として扱われ、そのメモリレイアウトは以下のルールに従う。</p>
      <ul>
        <li>デフォルトレイアウト（<code>@StructLayout(Sequential)</code> または指定なし）:
          <ul>
            <li>フィールドは <strong>ソースコードで定義された順番</strong> に並べる。</li>
            <li>各フィールドの先頭オフセットは構造体先頭からの <strong>8 バイト境界</strong> に揃える。
              必要に応じて前のフィールドの直後にパディングバイトを挿入する。</li>
            <li>構造体全体のサイズも 8 バイトの倍数になるよう末尾にパディングを入れてよい。</li>
          </ul>
        </li>
        <li>明示レイアウト（<code>@StructLayout(Explicit)</code>）:
          <ul>
            <li>各フィールドに <code>@FieldOffset(n)</code> アノテーションを付与し、構造体先頭からのオフセット（バイト単位）を明示的に指定する。</li>
            <li>VM は指定されたオフセットにフィールドを配置し、重なりが発生した場合の挙動（エラー／未定義動作）は言語仕様側で定義される。</li>
          </ul>
        </li>
        <li>自動レイアウト（<code>@StructLayout(Auto)</code>）:
          <ul>
            <li>VM がフィールドの順序とパディングを自由に最適化してよい。</li>
            <li>この場合、バイトオフセットは安定した ABI とは見なさず、ユーザーコードが <code>sizeof</code> やポインタ演算で前提にしてはならない。</li>
          </ul>
        </li>
        <li>構造体の配列:
          <ul>
            <li>配列要素は <strong>構造体サイズ単位で連続</strong> に配置される。つまり <code>N</code> 要素の配列は <code>N × sizeof(Struct)</code> バイトの連続領域を占有する。</li>
            <li>このレイアウトにより、3D ベクトルなどの大量の構造体を <code>memcpy</code> 等で一括コピーしやすい。</li>
          </ul>
        </li>
      </ul>
      <div class="note">
        構造体はインタフェースを実装せず、VM から見ても仮想ディスパッチの対象にならない単純な値型として扱う。<br />
        メソッド呼び出しは「構造体を引数に取る通常の関数」として表現されるため、boxing を前提とした呼び出しパターンは存在しない。
      </div>

      <h3>2.4.1 @StructLayout アノテーションと VM メタデータ</h3>
      <p>
        本節では、言語仕様側で定義された <code>@StructLayout</code> / <code>@FieldOffset</code> アノテーションが、
        AloeVM のメタデータにどのように反映されるかを定義する。<br />
        ここで述べる内容は、<strong>レイアウト情報の保持方法と ABI 的な意味付け</strong> に限定される。
        GC や delete の挙動とは直接関係しない。
      </p>
      <ul>
        <li>コンパイル時の取り扱い:
          <ul>
            <li>Aloe のコンパイラは、構造体定義に付与された <code>@StructLayout</code> と各フィールドの <code>@FieldOffset</code> を読み取り、型テーブルの該当エントリに以下のメタデータを埋め込む:
              <ul>
                <li><strong>LayoutKind</strong>: Sequential / Explicit / Auto のいずれか</li>
                <li><strong>Pack</strong>: パディング単位（未指定時はデフォルト 8 バイト）。Auto の場合は「未定義」でもよい。</li>
                <li><strong>Size</strong>: 構造体全体のサイズ（バイト数）。Sequential の場合は「フィールド＋パディング」から計算、Explicit の場合は最大オフセット＋フィールドサイズから計算。</li>
                <li><strong>FieldOffsets[]</strong>: 各フィールドのバイトオフセット（LayoutKind が Explicit の場合のみ必須）。</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>VM 実行時の利用箇所（例）:
          <ul>
            <li>ネイティブ連携（FFI）:
              <ul>
                <li>C / C++ / Rust 等のネイティブコードと構造体をやり取りする際、型テーブル内の LayoutKind / Size / FieldOffsets を用いてマーシャリングコードを生成する。</li>
                <li>Sequential / Explicit の場合のみ「バイトレベルで安定した ABI」として扱う。Auto の場合は ABI 前提を立ててはならない。</li>
              </ul>
            </li>
            <li>低レベルメモリアクセス命令:
              <ul>
                <li>将来的に「struct の特定フィールドをオフセット指定で読み書きする」ような命令（例: <code>LD_FIELDBYOFF</code>）を追加する場合、FieldOffsets 情報を参照して実アドレスを計算する。</li>
              </ul>
            </li>
            <li>デバッグ表示:
              <ul>
                <li>デバッガやログ出力で構造体の内部レイアウトを可視化する際に、オフセットとサイズ情報を用いる。</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>GC との関係:
          <ul>
            <li>GC（親ルートチェック・スロットアリーナ・スライディングコンパクションなど）は、基本的に「どのフィールドが参照型か」という情報だけを必要とする。</li>
            <li><code>@StructLayout</code> や <code>@FieldOffset</code> は、GC の到達可能性判定や解放タイミングには影響しない。<br />
              （参照スロットの位置は型メタデータから決まるが、その計算にレイアウト情報を使うかどうかは実装依存。）</li>
          </ul>
        </li>
        <li>仕様上の保証範囲:
          <ul>
            <li>Sequential / Explicit の構造体は、「同一バージョンの AloeVM / Aloe コンパイラ」間ではバイトレベルで互換なレイアウトになることを目標とする。</li>
            <li>ただし、ターゲットプラットフォームやコンパイラオプションによっては、Pack や Size の扱いに差が出る可能性がある。</li>
            <li>Auto レイアウトの構造体については、レイアウト安定性や ABI 互換性は一切保証しない。</li>
          </ul>
        </li>
        <li>クラスとの違い:
          <ul>
            <li>クラス（参照型）に <code>@StructLayout</code> を付与した場合の扱いは、言語仕様側で追加定義されるまでは「未使用／予約」とし、本 VM 仕様では具体的な意味付けを行わない。</li>
            <li>現行の AloeVM 仕様では、<strong>構造体（struct）のみがレイアウト制御の対象</strong> として正式にサポートされる。</li>
          </ul>
        </li>
      </ul>
    </section>

    <!-- 3. コールスタックとフレーム -->
    <section id="vm-ch3" class="chapter">
      <h2>3. コールスタックとフレーム</h2>

      <h3>3.1 フレーム構造</h3>
      <p>各関数呼び出しは「フレーム」を生成する。フレームは少なくとも以下を持つ。</p>
      <ul>
        <li>戻りアドレス（次に実行する命令の PC）</li>
        <li>前のフレームへのリンク</li>
        <li>ローカル変数領域</li>
        <li>引数領域</li>
        <li>一時値スロット（必要なら）</li>
      </ul>

      <h3>3.2 呼び出し規約（概要）</h3>
      <ul>
        <li>関数呼び出し命令（例: <code>CALL</code>）は、引数をスタック上に積んだ状態で実行される。</li>
        <li>フレーム作成後、引数はローカル領域に移される（またはスタック上に残したままインデックス指定）。</li>
        <li>戻り値はスタックトップに 1 つだけ積まれる。</li>
        <li>void 関数は戻り値を積まない。</li>
      </ul>

      <h3>3.3 例外フレーム</h3>
      <ul>
        <li>例外ハンドラテーブルに基づき、スタックのどこまで巻き戻すかを決定する。</li>
        <li>巻き戻し後、catch ブロック先頭にジャンプし、例外オブジェクトをローカルまたはスタックに渡す。</li>
      </ul>
    </section>

    <!-- 4. ヒープとメモリ管理方針 -->
    <section id="vm-ch4" class="chapter">
      <h2>4. ヒープとメモリ管理方針（C# 実装 VM）</h2>

      <h3>4.1 スロットベースのヒープレイアウト</h3>
      <ul>
        <li>C# 実装 VM のヒープは、<strong>スロットサイズごとに分割された複数のアリーナ</strong>として管理される。</li>
        <li>各アリーナは固定長スロットの配列で構成され、1 スロットあたりのバイト数はそのアリーナ固有の <code>slot_size_bytes</code> で決まる。</li>
        <li>デフォルト構成では、次のサイズクラスのアリーナを用意する：
          <ul>
            <li>8 バイトスロットアリーナ</li>
            <li>16 バイトスロットアリーナ</li>
            <li>32 バイトスロットアリーナ</li>
            <li>64 バイトスロットアリーナ</li>
            <li>128 バイトスロットアリーナ</li>
            <li>256 バイトスロットアリーナ</li>
            <li>512 バイトスロットアリーナ</li>
            <li>1024 バイトスロットアリーナ</li>
          </ul>
        </li>
        <li>各アリーナの総容量は <strong>64 KiB</strong> とし、含まれるスロット数は
          <code>64 KiB / slot_size_bytes</code> の整数値となる。
          例えば 8 バイトスロットアリーナは 8192 スロットを持つ。
        </li>
        <li>すべてのヒープオブジェクトは、いずれか 1 つのアリーナに割り当てられ、そのアリーナ内の
          <strong>連続スロット</strong> を 1 個以上占有する。
          <ul>
            <li>オブジェクトの物理サイズ（バイト数）から必要スロット数 <code>lengthSlots</code> を計算し、
              <code>ceil(objectSizeBytes / slot_size_bytes)</code> スロットを確保する。</li>
          </ul>
        </li>
        <li>オブジェクトのアリーナ選択は次の方針に従う：
          <ul>
            <li><code>objectSizeBytes</code> を収容できる最小の <code>slot_size_bytes</code> を持つアリーナを選択する。</li>
            <li>例えば 40 バイトのオブジェクトは 64 バイトスロットアリーナに配置される。</li>
          </ul>
        </li>
        <li>アリーナ構成を変更したい実装は、設定ファイル等でサイズクラスや総容量を再定義してもよいが、
          「サイズごとにアリーナを分ける」「各アリーナをスロット配列として扱う」という基本方針は維持すること。</li>
      </ul>

      <h3>4.2 ハンドルと変数テーブル</h3>
      <ul>
        <li>第 2 章で述べたとおり、ヒープオブジェクトは <strong>オブジェクト ID（ハンドル）</strong> によって識別される。</li>
        <li>VM 内部では、ハンドルから実際のヒープ上の位置を引くために、
          <strong>変数テーブル（またはオブジェクトテーブル）</strong> を持つ。
          典型的には以下の情報を保持する：
          <ul>
            <li>所属アリーナ ID</li>
            <li>先頭スロット index（整数）</li>
            <li>占有スロット数（<code>lengthSlots</code>）</li>
            <li>型情報への参照（クラス／構造体のメタデータ ID）</li>
            <li>ガーベジコレクション用メタデータ
              <ul>
                <li><code>LastRootCheckEpoch</code>: 最終ルートチェックが完了した GC エポック番号</li>
                <li><code>DeleteFlag</code>: 「削除候補オブジェクト群」に含まれるかどうか</li>
                <li>親リンク／子リンク（親子関係グラフを辿るための補助情報）</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>VM のオペコードやランタイムは、<strong>生ポインタではなくハンドル</strong> を扱う。
          <ul>
            <li>ハンドル → テーブル → アリーナ内先頭スロット、という 2 段階で物理メモリに到達する。</li>
            <li>オブジェクトの移動（コンパクション）が発生しても、変数テーブルの該当エントリを更新するだけでよい。</li>
          </ul>
        </li>
      </ul>

      <h3>4.3 アクセス駆動型の寿命管理（親ルートチェック GC）</h3>
      <p>
        C# 実装 VM は、従来の「ルート集合からグラフ全体をスキャンする」方式ではなく、
        <strong>「変数アクセスをトリガとする親ルートチェック」</strong> によって到達可能性を判定する。
        これにより、長時間の stop-the-world を避けることを前提とする。
      </p>
      <ul>
        <li>基本ポリシー:
          <ul>
            <li>VM は「子 → 親」方向の参照グラフも管理しており、任意のオブジェクトから上流へ向かって親を辿れる。</li>
            <li>各 GC サイクルは <code>GcEpoch</code> という単調増加のカウンタで識別される。</li>
          </ul>
        </li>
        <li>変数アクセス時のルートチェック:
          <ol>
            <li>ある変数（ローカル／フィールド／配列要素など）に格納されているハンドル <code>obj</code> にアクセスする直前に、
              VM はそのオブジェクトの <code>LastRootCheckEpoch</code> を確認する。</li>
            <li><code>CurrentGcEpoch - LastRootCheckEpoch</code> が <strong>閾値以内</strong> の場合、
              そのオブジェクトについては直近のチェック結果を再利用し、親ルートチェックをスキップしてよい。</li>
            <li>閾値を超えている場合、VM は <strong>親ルートチェック</strong> を開始する。</li>
          </ol>
        </li>
        <li>親ルートチェックの内容（概要）:
          <ul>
            <li>対象オブジェクトから親リンクを辿りながら、「スレッドルート／グローバルルート」に到達できるかを調べる。</li>
            <li>探索途中で、<code>LastRootCheckEpoch</code> が現在の <code>GcEpoch</code> と同じ、
              もしくは閾値以内の親オブジェクトに到達した場合、その親は既に十分新しい時刻にチェック済みとみなし、
              そこから先は探索を打ち切ることができる。</li>
            <li>探索中に辿った親ノード数が上限に達した場合、
              VM バージョン 1 では <strong>保守的に「ルートに到達した」と見なす</strong>。
              この場合、対象オブジェクトおよび探索で辿った子孫オブジェクト群について、
              「ルート到達時」と同様に <code>LastRootCheckEpoch = CurrentGcEpoch</code> に更新し、
              <code>DeleteFlag</code> が立っている場合はクリアする（将来バージョンでは、
              別途「要再チェック対象キュー」を用いて再度チェックを行う拡張が入る可能性がある）。</li>
            <li>最終的に、いずれかのルートに到達した場合:
              <ul>
                <li>対象オブジェクトおよび探索で辿った子孫オブジェクト群について、
                  <code>LastRootCheckEpoch = CurrentGcEpoch</code> に更新し、<code>DeleteFlag</code> が立っている場合はクリアする。</li>
              </ul>
            </li>
            <li>どのルートにも到達しなかった場合:
              <ul>
                <li>対象オブジェクトと、そこから辿れる全ての子オブジェクトを <strong>削除候補オブジェクト群</strong> として扱い、
                  それぞれに <code>DeleteFlag</code> を立て、後述の削除キューに登録する。</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>C# 実装 VM v1 のデフォルト値:
          <ul>
            <li><strong>LastRootCheckEpoch 閾値</strong>: <code>10</code><br />
              （<code>CurrentGcEpoch - LastRootCheckEpoch &gt; 10</code> となったオブジェクトは再チェック対象とみなす。）</li>
            <li><strong>1 回の親ルートチェックで辿ってよい親ノード数の上限</strong>: <code>10</code></li>
          </ul>
        </li>
        <li>これらの閾値は、VM 起動時のコマンドライン引数や設定ファイルにより変更できるようにする。
          ただし、変更しても「アクセス駆動型 GC」「親ルートチェック」の基本アルゴリズムは変えない。</li>
        <li>この方式により、GC は「アクセスされたオブジェクト群」に対してのみ集中的にルートチェックを行う。
          <ul>
            <li>ヒープ全体を走査する stop-the-world は基本的に行わない。</li>
            <li>アプリケーションが頻繁に触れるオブジェクトほど、
              <code>LastRootCheckEpoch</code> が更新され続け、不要な探索を回避しやすくなる。</li>
          </ul>
        </li>
      </ul>

      <h3>4.4 write barrier と親子関係グラフ</h3>
      <ul>
        <li>AloeVM では、<strong>すべての参照書き換え</strong>（フィールド代入・配列要素代入・ローカル変数更新など）は
          必ず VM の <strong>write barrier</strong> を経由して行う前提とする。</li>
        <li>write barrier の責務:
          <ul>
            <li>親オブジェクトと子オブジェクトの関係を、内部の親子関係グラフに反映する。</li>
            <li>古い参照が破棄された場合、必要に応じて「親 → 子」リンクを削除する。</li>
          </ul>
        </li>
        <li>これにより、親ルートチェック時には「子 → 親」および「親 → 子」のリンクが
          一貫した状態で維持され、アクセス駆動型 GC が正しく動作する。</li>
        <li>従来の三色マーキングにおけるバリアと同様、
          「GC 中に新規に張られた参照や、切られた参照」がルート判定を不正にすることがないように設計する。</li>
      </ul>

      <h3>4.5 アクセス時スライディング・コンパクション</h3>
      <p>
        AloeVM のヒープは、断片化を防ぐために <strong>「アクセス時に少しだけ詰める」スライディング・コンパクション</strong> を行う。
        これは、オブジェクトにアクセスしたタイミングでそのオブジェクトを前方にスライドさせ、
        スロットの空きを徐々に前方へ集約していく仕組みである。
      </p>
      <ul>
        <li>変数ハンドルにアクセスする命令は、概念的に以下の処理を行う：
          <ol>
            <li>まず 4.3 で定義した <strong>親ルートチェック</strong> を必要に応じて実行し、
              削除候補オブジェクトでないことを確認する。</li>
            <li>ハンドルから変数テーブルを引き、<code>(arenaId, slotIndex, lengthSlots)</code> を取得する。</li>
            <li>同じアリーナ内で、<code>slotIndex - lengthSlots</code> から <code>slotIndex - 1</code> までのスロットが
              すべて空き（未使用）であるかを確認する。
              <ul>
                <li>単純化のため、実装では「スロット状態テーブルのフラグ」を見るだけでもよい。</li>
              </ul>
            </li>
            <li>もし上記の範囲が完全に空きであれば、
              <ul>
                <li>オブジェクトを前方に <code>lengthSlots</code> スロット分スライドさせる（コピー）。</li>
                <li>旧領域（元の <code>slotIndex ～ slotIndex + lengthSlots - 1</code>）を 0 クリアし、空きスロットとしてマークする。</li>
                <li>変数テーブル内の <code>slotIndex</code> を <code>slotIndex - lengthSlots</code> に更新する。</li>
              </ul>
            </li>
            <li>更新後の先頭スロットから、実際のオブジェクトフィールドにアクセスする。</li>
          </ol>
        </li>
        <li>このルールにより、1 回のアクセスで触るメモリ量は高々「自分のサイズ（<code>lengthSlots</code> スロット）」に抑えられる。
          <ul>
            <li>「ヒープ全体を走査して一気に詰める」タイプの stop-the-world GC を避け、
              断片化解消コストを <strong>アクセスに分散</strong> できる。</li>
          </ul>
        </li>
        <li>解放されたスロットが、同じアリーナ内の「まだ生存しているオブジェクトよりも前方（低アドレス側）」に蓄積している場合、
          後ろ側にある生存オブジェクトを順次スライドさせることで、前方から連続した空き領域を作りやすくする。</li>
        <li>「アクセス時スライド」は必須ではなく、実装によっては
          <ul>
            <li>頻度を下げる（一定回数に 1 回だけ実施）</li>
            <li>1 アクセスあたりの最大移動スロット数に上限を設ける</li>
          </ul>
          などの調整を行ってよい。</li>
      </ul>

      <h3>4.6 アロケーション戦略</h3>
      <ul>
        <li>新しいオブジェクトを確保する際、メモリマネージャは以下を行う：
          <ol>
            <li>論理的なオブジェクトサイズ（バイト数）を計算する。</li>
            <li>4.1 で述べたサイズクラスから、
              <code>objectSizeBytes</code> を収容できる最小の <code>slot_size_bytes</code> を持つアリーナを選択する。</li>
            <li>そのアリーナ内で必要なスロット数 <code>lengthSlots</code> を求め、
              <strong>十分な連続空きスロット</strong> を探索する。</li>
            <li>見つかった先頭スロットにオブジェクトを配置し、スロット状態テーブルと変数テーブルを更新する。</li>
          </ol>
        </li>
        <li>空きスロットの管理方法は実装に依存するが、典型的には以下のいずれか：
          <ul>
            <li>単純な線形探索（プロトタイプ段階）</li>
            <li>連続スロット範囲のフリーリスト</li>
            <li>ビットマップ＋first-fit/best-fit アルゴリズム</li>
          </ul>
        </li>
        <li>どのアリーナにも必要な連続空きスロットが見つからない場合：
          <ul>
            <li>アクセス時スライドの頻度を一時的に上げて断片化を軽減する。</li>
            <li>またはヒープを拡張し、新しいアリーナチャンクを追加する。</li>
          </ul>
        </li>
      </ul>

      <h3>4.7 delete と論理的寿命</h3>
      <ul>
        <li>Aloe 言語の <code>delete x;</code> は、「変数 <code>x</code> が保持しているハンドルへの参照を切る」という意味であり、
          その瞬間に物理的なメモリが解放されることは <strong>保証されない</strong>。</li>
        <li><code>delete</code> 実行時には、少なくとも次のことが行われる：
          <ul>
            <li>対象変数のスロットに <code>null</code> 相当を格納し、以降その変数からオブジェクトへは到達できなくする。</li>
            <li>必要に応じて、当該オブジェクトに対する「親ルートチェック」をすぐに実行し、
              そこから辿れる子オブジェクト群がすべてルートから到達不能であると判定された場合、
              まとめて削除候補オブジェクト群としてキューに追加してもよい（実装依存）。</li>
          </ul>
        </li>
        <li>したがって、Aloe プログラムは「delete 直後に必ずヒープ使用量が減る」とは期待してはいけない。
          あくまで <strong>「この変数からはオブジェクトをもう参照しない」という論理的な宣言</strong> に過ぎず、
          実際の解放タイミングはアクセス駆動型 GC とバックグラウンド削除スレッドの進行状況に依存する。</li>
      </ul>

      <h3>4.8 削除候補キューとバックグラウンド削除スレッド</h3>
      <p>
        親ルートチェックの結果、あるオブジェクト群がルートから到達不能であると判定された場合、
        AloeVM はそれらを <strong>削除候補オブジェクト群</strong> として扱い、
        直ちに物理メモリを解放するのではなく、<strong>専用の削除キュー</strong> に登録する。
      </p>
      <ul>
        <li>削除候補キュー:
          <ul>
            <li>エントリには少なくとも「代表オブジェクトのハンドル、またはオブジェクト群の一覧」を格納する。</li>
            <li>各オブジェクトには <code>DeleteFlag = true</code> が立てられ、
              通常の変数アクセスからは「既に死んでいるオブジェクト」として扱われる。</li>
          </ul>
        </li>
        <li>バックグラウンド削除スレッド:
          <ul>
            <li>C# 実装 VM v1 では、削除候補キューを処理するための
              <strong>バックグラウンド削除スレッドを 2 本</strong> 起動する。</li>
            <li>各スレッドは約 50 ミリ秒ごとにウェイクアップし、
              そのサイクルで処理する削除候補エントリの数は <strong>最大 5 個</strong> とする。
              キューに残りがある場合は、次回以降のサイクルで順次処理される。</li>
            <li>スレッドは、削除処理を行う前にホスト OS やランタイムが提供するメトリクスを参照し、
              おおよその CPU 使用率とヒープ使用率を取得してもよい。
              <ul>
                <li>CPU 使用率またはヒープ使用率がおおよそ 80% 以上である場合、
                  そのサイクルの削除処理をスキップする、あるいは処理数を 5 個未満に減らすといった
                  <strong>スロットリング</strong> を行ってよい。</li>
                <li>CPU／ヒープ使用率の取得方法や、どの程度削減するかといった細部は実装依存とする。</li>
              </ul>
            </li>
            <li>ヒープ使用率が高い（いわゆる「逼迫状態」）からといって、
              仕様上特別に「削除スレッドを増やす」「サイクル頻度を上げる」といった追加要件は設けない。
              あくまで上記の周期とスロットリングルールの範囲内で削除処理を行う。</li>
            <li>各エントリに含まれるオブジェクト群について、
              <ul>
                <li>その時点で新しい親リンクが追加されていないか（<code>DeleteFlag</code> のままか）を確認する。</li>
                <li>問題がなければ、アリーナ内の該当スロットを 0 クリアし、スロット状態テーブルを更新して空きスロットとする。</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>仕様上の前提（生き返り禁止）:
          <ul>
            <li>4.4 の write barrier と親ルートチェックの設計により、
              「<code>DeleteFlag</code> が立ったオブジェクト群」に対して新たな有効参照が張られるケースは
              仕様上許可しない。</li>
            <li>つまり、一度削除候補オブジェクト群としてマークされたオブジェクトは、
              <strong>論理的に生き返ることはない</strong> ものとする。</li>
            <li>この前提により、バックグラウンドでの削除処理は「安全に実行できるが、いつ実行するかは実装依存」という形にできる。</li>
          </ul>
        </li>
      </ul>

      <h3>4.9 WASM 実装時のメモリ管理</h3>
      <div class="note">
        WASM ネイティブモードでは、AloeVM 独自のスロット制メモリ管理および親ルートチェック GC は必須ではない。<br />
        GC・メモリ確保・解放は <strong>WASM 実行系およびホストランタイムに委譲</strong>する。
      </div>
      <ul>
        <li>Aloe のオブジェクトは、WASM の <code>struct</code> / <code>array</code> / <code>ref</code> などへ直接マッピングされうる。</li>
        <li>WASM GC やホストランタイム（例: .NET, JVM, JS）の GC が責務を負うため、
          本章で述べたスロットレイアウト・アクセス時スライド・親ルートチェックは C# 実装 VM の内部仕様に留まる。</li>
        <li>aloe2wasm などのコンパイラは、Aloe の抽象メモリモデルを維持しつつ、
          実際の GC はターゲット環境の仕組みに任せることが推奨される。</li>
      </ul>
    </section>

    <!-- 5. パイプ / フィルタ -->
    <section id="vm-ch5" class="chapter">
      <h2>5. パイプ / フィルタの VM 表現</h2>

      <h3>5.1 pipe&lt;T&gt;</h3>
      <ul>
        <li>VM レベルで <strong>PIPE</strong> タグを持つ値として表現する。</li>
        <li>内部には以下のような情報を持つ想定:
          <ul>
            <li>バッファ（リングバッファ／キュー）</li>
            <li>同期プリミティブ（ロック／条件変数など）</li>
            <li>要素の型情報（ランタイム型情報への参照）</li>
          </ul>
        </li>
        <li>複数スレッドからアクセスしても壊れないよう、実装はスレッドセーフであること。</li>
        <li>実装例:
          <ul>
            <li>OS パイプ／ソケット</li>
            <li>メモリマップドファイル上のリングバッファ</li>
          </ul>
        </li>
      </ul>

      <h3>5.2 filter</h3>
      <ul>
        <li>filter は専用タグ（FILTER）を持つ値として表現される。</li>
        <li>filter 値は、概念的には
          <ul>
            <li>「bound 関数へのポインタ」</li>
            <li>フィルタ定義メタ情報（in/out 型）</li>
          </ul>
          をまとめた構造体。</li>
        <li>ユーザ定義フィルタも同じ仕組みで表現できる。</li>
      </ul>

      <h3>5.3 パイプライン文の実行モデル</h3>
      <pre><code class="language-aloe">
A | filter(F) | B;
      </code></pre>
      <ul>
        <li>VM はこの文を「接続構築命令」の列に展開する。</li>
        <li>典型的な流れ:
          <ol>
            <li><code>A</code> の出力 pipe を解決する。</li>
            <li><code>filter(F)</code> のインスタンスを生成し、<code>bound(input, output)</code> を別タスク／スレッドとして起動。</li>
            <li>出力 pipe を <code>B</code> に接続する。</li>
          </ol>
        </li>
        <li>実装によっては、複数フィルタを 1 スレッド内で順次処理する最適化も可能。</li>
      </ul>

      <h3>5.4 パイプのライフサイクルと VM 命令</h3>
      <p>
        pipe は VM レベルでは、概ね次の 4 フェーズを持つライフサイクルとして扱う：
        <strong>生成</strong> → <strong>接続</strong> → <strong>切断</strong> → <strong>削除</strong>。
        それぞれのフェーズは、7 章で定義する「pipe / filter / 接続カテゴリ（カテゴリ ID = 0x0A）」の命令によって操作される。
      </p>
      <ul>
        <li><strong>生成フェーズ（Create）</strong>
          <ul>
            <li>新しい pipe インスタンスを確保し、バッファや同期オブジェクトを初期化する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_NEW</code>:
                  <ul>
                    <li>引数として要素型 ID、バッファサイズ、オプションフラグなどを取る。</li>
                    <li>戻り値として pipe ハンドル（VM 値としての PIPE タグ付きハンドル）をスタックに積む。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>接続フェーズ（Connect）</strong>
          <ul>
            <li>既存の pipe に対して、producer / consumer / filter を接続する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_BIND_PRODUCER</code>:
                  <ul>
                    <li>pipe ハンドルと producer 側エンドポイント（メソッド／タスク）を結び付ける。</li>
                  </ul>
                </li>
                <li><code>PIPE_BIND_CONSUMER</code>:
                  <ul>
                    <li>pipe ハンドルと consumer 側エンドポイントを結び付ける。</li>
                  </ul>
                </li>
                <li><code>PIPE_CONNECT</code>:
                  <ul>
                    <li>複数の pipe と filter をまとめて「パイプライン」として接続する高レベル命令として定義してもよい。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>切断フェーズ（Disconnect）</strong>
          <ul>
            <li>producer / consumer / filter を pipe から切り離し、新たなデータの流入・流出を止める。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_DISCONNECT</code>:
                  <ul>
                    <li>指定したエンドポイントを pipe から切り離す。</li>
                    <li>既にバッファ内に存在するデータの扱い（破棄する／最後まで読み出させる）は実装ポリシーで決める。</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>削除フェーズ（Delete / Close）</strong>
          <ul>
            <li>pipe 自体をクローズし、関連するバッファや同期オブジェクトを解放する。</li>
            <li>代表的な命令（例）:
              <ul>
                <li><code>PIPE_CLOSE</code>:
                  <ul>
                    <li>pipe ハンドルをクローズし、GC から見て到達不能になった時点で、ヒープ上の pipe オブジェクトが解放候補となる。</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>Aloe 言語レベルの <code>delete</code> や <code>with</code> ブロック終了時の暗黙クローズは、
              これらの命令にコンパイルされる想定である。</li>
          </ul>
        </li>
      </ul>
      <div class="note">
        producer / consumer として動作するコードは、通常は「通常の関数／メソッド＋スレッド（またはタスク）」の組み合わせで表現される。<br />
        必要に応じて、<code>PRODUCER_START</code>, <code>PRODUCER_STOP</code>, <code>CONSUMER_START</code>, <code>CONSUMER_STOP</code> のような
        制御専用命令を 0x0A カテゴリ内に追加してもよい。
      </div>
    </section>

    <!-- 6. AloeBC バイナリ形式 -->
    <section id="vm-ch6" class="chapter">
      <h2>6. AloeBC バイナリ形式</h2>

      <h3>6.1 全体構造</h3>
      <p>AloeBC（Aloe Byte Code）は、AloeVM 向けコンパイル結果を格納するバイナリフォーマットである。</p>

      <h3>6.2 ヘッダ</h3>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>オフセット</th>
              <th>サイズ</th>
              <th>フィールド</th>
              <th>内容</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0</td>
              <td>6 byte</td>
              <td>Magic</td>
              <td>ASCII 文字列 <code>"ALOEBC"</code></td>
            </tr>
            <tr>
              <td>6</td>
              <td>1 byte</td>
              <td>VersionMajor</td>
              <td>メジャーバージョン</td>
            </tr>
            <tr>
              <td>7</td>
              <td>1 byte</td>
              <td>VersionMinor</td>
              <td>マイナーバージョン</td>
            </tr>
            <tr>
              <td>8</td>
              <td>1 byte</td>
              <td>VersionBuild</td>
              <td>ビルド番号</td>
            </tr>
            <tr>
              <td>9</td>
              <td>1 byte</td>
              <td>Reserved</td>
              <td>予約（0 固定）</td>
            </tr>
            <tr>
              <td>10</td>
              <td>4 byte</td>
              <td>HeaderSize</td>
              <td>ヘッダ全体のサイズ（リトルエンディアン）</td>
            </tr>
            <tr>
              <td>14</td>
              <td>4 byte</td>
              <td>ConstPoolOffset</td>
              <td>定数プールの先頭オフセット</td>
            </tr>
            <tr>
              <td>18</td>
              <td>4 byte</td>
              <td>TypeTableOffset</td>
              <td>型テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>22</td>
              <td>4 byte</td>
              <td>FuncTableOffset</td>
              <td>関数テーブルの先頭オフセット</td>
            </tr>
            <tr>
              <td>26</td>
              <td>4 byte</td>
              <td>CodeSectionOffset</td>
              <td>コードセクションの先頭オフセット</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>エンディアンは <strong>リトルエンディアン</strong> を前提とする。</p>

      <h3>6.3 定数プール（概要）</h3>
      <ul>
        <li>文字列リテラル、数値リテラル、型情報などを一元管理する。</li>
        <li>各エントリは「タグ + 長さ + 本体」で構成される可変長レコード。</li>
        <li>タグの例:
          <ul>
            <li>0x01: UTF-8 文字列</li>
            <li>0x02: int32</li>
            <li>0x03: float32</li>
            <li>0x04: decimal</li>
          </ul>
        </li>
      </ul>

      <h3>6.4 型テーブル（概要）</h3>
      <ul>
        <li>各 Aloe 型（class / struct / enum / bitfield enum / pipe&lt;T&gt; など）に ID を割り当てる。</li>
        <li>enum / bitfield enum は VM 上では <strong>int32 値型</strong> としてフラグ付けされる。</li>
        <li>bitfield enum の有効ビット数（0～31）はメタ情報として保持してもよい（警告発生などに利用）。</li>
      </ul>

      <h3>6.5 関数テーブル・コードセクション</h3>
      <ul>
        <li>関数テーブル:
          <ul>
            <li>関数シグネチャ（引数の型、戻り値の型）</li>
            <li>ローカル変数の数</li>
            <li>コードセクション内のオフセット・長さ</li>
            <li>例外ハンドラテーブルのエントリ数および先頭オフセット</li>
          </ul>
        </li>
        <li>コードセクション:
          <ul>
            <li>VM 命令列をバイト列として格納。</li>
            <li>命令セットの詳細は第 7 章参照。</li>
          </ul>
        </li>
      </ul>

      <h3>6.6 例外ハンドラテーブル</h3>
      <p>
        各関数には 0 個以上の例外ハンドラエントリを持つテーブルを関連付ける。
        関数テーブル内の情報を用いて、当該関数のコード先頭からの相対オフセットとエントリ数を取得できる。
      </p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>フィールド名</th>
              <th>型</th>
              <th>内容</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>TryStartOffset</td>
              <td>uint32</td>
              <td>関数コード先頭からのオフセット（バイト単位）。<code>try</code> ブロックの開始位置（inclusive）。</td>
            </tr>
            <tr>
              <td>TryEndOffset</td>
              <td>uint32</td>
              <td><code>try</code> ブロックの終了位置（exclusive）。範囲は <code>[TryStartOffset, TryEndOffset)</code> と解釈する。</td>
            </tr>
            <tr>
              <td>HandlerStartOffset</td>
              <td>uint32</td>
              <td>対応するハンドラブロック（<code>catch</code> / <code>finally</code> / <code>filter</code>）の先頭オフセット。</td>
            </tr>
            <tr>
              <td>HandlerEndOffset</td>
              <td>uint32</td>
              <td>ハンドラブロックの終了オフセット（exclusive）。</td>
            </tr>
            <tr>
              <td>HandlerKind</td>
              <td>uint8</td>
              <td>
                ハンドラ種別。
                例: 0 = catch, 1 = finally, 2 = filter（将来拡張用に 3 以降は予約）。
              </td>
            </tr>
            <tr>
              <td>Reserved</td>
              <td>uint8[3]</td>
              <td>パディングおよび将来拡張用。現行仕様では 0 固定。</td>
            </tr>
            <tr>
              <td>ExceptionTypeId</td>
              <td>uint32</td>
              <td>
                <code>HandlerKind == catch</code> の場合に有効な例外型 ID（型テーブルへのインデックス）。<br />
                0 を指定した場合は「任意の例外（catch-all）」を意味する。<br />
                <code>finally</code> の場合は 0 固定、<code>filter</code> の場合の扱いは将来拡張。
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <ul>
        <li>1 つの <code>try</code> 範囲に対して複数の <code>catch</code> を持つ場合、
          <code>TryStartOffset</code> / <code>TryEndOffset</code> が同一で <code>HandlerKind = catch</code> のエントリを複数並べる。</li>
        <li><code>catch</code> の評価順序はテーブル内の並び順に従う。</li>
        <li><code>finally</code> ブロックは、同じ <code>try</code> 範囲に対して 0 または 1 個のエントリを持つことができる。</li>
      </ul>
    </section>

    <!-- 7. 命令セットと WASM 対応 -->
    <section id="vm-ch7" class="chapter">
      <h2>7. 命令セットと WASM 対応（概要）</h2>

      <h3>7.1 命令カテゴリ</h3>
      <p>命令セットはおおよそ以下のカテゴリに分かれる想定であり、各カテゴリには 1 バイトのカテゴリ ID を割り当てる。</p>
      <ul>
        <li>スタック操作命令
          <ul>
            <li>PUSH, POP, DUP, SWAP など</li>
          </ul>
        </li>
        <li>算術・論理命令
          <ul>
            <li>ADD, SUB, MUL, DIV, MOD</li>
            <li>AND, OR, XOR, SHL, SHR</li>
          </ul>
        </li>
        <li>比較命令
          <ul>
            <li>CMPEQ, CMPNE, CMPLT, CMPLE, CMPGT, CMPGE</li>
          </ul>
        </li>
        <li>制御フロー命令
          <ul>
            <li>JMP, JMP_IF_TRUE, JMP_IF_FALSE</li>
          </ul>
        </li>
        <li>関数呼び出し命令
          <ul>
            <li>CALL, RET</li>
          </ul>
        </li>
        <li>オブジェクト操作命令
          <ul>
            <li>NEWOBJ, GETFIELD, SETFIELD など</li>
          </ul>
        </li>
        <li>配列・コレクション操作命令（将来）</li>
        <li>pipe / filter / producer / consumer / 接続・切断命令</li>
        <li>例外処理・VM 管理・デバッグ命令</li>
      </ul>

      <div class="note">
        本仕様書では、命令カテゴリと ID 構成のポリシーのみを定義する。<br />
        個々の命令ごとのオペコード値やビット配置は、別資料「AloeVM 命令セットリファレンス」で詳細に定義する。
      </div>

      <h3>7.2 命令 ID の構成（カテゴリ + 連番）</h3>
      <p>
        AloeVM の各命令には、<strong>16bit（2 バイト）の命令 ID</strong> を割り当てる。<br />
        命令 ID は上位 1 バイトを <strong>カテゴリ ID</strong>、下位 1 バイトを <strong>カテゴリ内連番</strong> として扱う。
      </p>
      <ul>
        <li>16bit 命令 ID の構成:
          <ul>
            <li>上位 8bit: カテゴリ ID（例: スタック操作 = 0x01, 算術 = 0x02 など）</li>
            <li>下位 8bit: カテゴリ内での連番（そのカテゴリのオペコード表の並び順）</li>
          </ul>
        </li>
        <li>数式で表すと、命令 ID は次のように求めることができる：
          <pre><code>OpcodeID = (Category &lt;&lt; 8) | IndexInCategory</code></pre>
        </li>
        <li>具体例:
          <ul>
            <li>スタック操作カテゴリ（カテゴリ ID = <code>0x01</code>）の 1 番目の命令 → <code>0x0101</code></li>
            <li>同カテゴリの 2 番目の命令 → <code>0x0102</code></li>
            <li>算術カテゴリ（カテゴリ ID = <code>0x02</code>）の 3 番目の命令 → <code>0x0203</code></li>
          </ul>
        </li>
      </ul>

      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>カテゴリ ID（上位 1 バイト）</th>
              <th>カテゴリ名（例）</th>
              <th>備考</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0x01</td>
              <td>スタック操作命令</td>
              <td><code>PUSH</code>, <code>POP</code>, <code>DUP</code>, <code>SWAP</code> など</td>
            </tr>
            <tr>
              <td>0x02</td>
              <td>算術命令</td>
              <td><code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>, <code>MOD</code> など</td>
            </tr>
            <tr>
              <td>0x03</td>
              <td>論理・ビット演算命令</td>
              <td><code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>SHL</code>, <code>SHR</code> など</td>
            </tr>
            <tr>
              <td>0x04</td>
              <td>比較命令</td>
              <td><code>CMPEQ</code>, <code>CMPNE</code>, <code>CMPLT</code>, <code>CMPLE</code>, <code>CMPGT</code>, <code>CMPGE</code></td>
            </tr>
            <tr>
              <td>0x05</td>
              <td>制御フロー命令</td>
              <td><code>JMP</code>, <code>JMP_IF_TRUE</code>, <code>JMP_IF_FALSE</code> など</td>
            </tr>
            <tr>
              <td>0x06</td>
              <td>呼び出し・戻り命令</td>
              <td><code>CALL</code>, <code>RET</code> など</td>
            </tr>
            <tr>
              <td>0x07</td>
              <td>メモリアクセス命令</td>
              <td>ローカル／引数／グローバル／フィールドの load/store など</td>
            </tr>
            <tr>
              <td>0x08</td>
              <td>オブジェクト / 配列命令</td>
              <td><code>NEWOBJ</code>, <code>NEWARR</code>, <code>GETFIELD</code>, <code>SETFIELD</code> など</td>
            </tr>
            <tr>
              <td>0x09</td>
              <td>例外・エラー命令</td>
              <td><code>THROW</code>, <code>RETHROW</code>, <code>LEAVE</code> など</td>
            </tr>
            <tr>
              <td>0x0A</td>
              <td>pipe / filter / 接続命令</td>
              <td>pipe 生成・接続・切断・producer/consumer 起動など</td>
            </tr>
            <tr>
              <td>0x0B</td>
              <td>VM 管理・デバッグ命令</td>
              <td><code>NOP</code>, <code>HALT</code>, <code>BREAKPOINT</code> など</td>
            </tr>
            <tr>
              <td>0xF0〜0xFF</td>
              <td>実装依存・実験用命令</td>
              <td>特定実装でのみ使用される拡張命令の予約領域</td>
            </tr>
          </tbody>
        </table>
      </div>

      <h3>7.3 命令セット詳細の参照先</h3>
      <p>
        個々のオペコード ID・オペランド形式・バイナリ表現の詳細な一覧は、
        本仕様書ではなく別資料「<strong>AloeVM 命令セットリファレンス</strong>」で定義する。<br />
        実装者は、本章のポリシーとカテゴリ設計を前提としたうえで、命令セットの具体的な定義については
        命令セットリファレンスを参照すること。
      </p>

      <h3>7.4 WASM への 1:1 マッピング方針</h3>
      <ul>
        <li>基本算術・比較命令は、可能な限り WASM の <code>i32.add</code>, <code>i32.lt_s</code> などへ 1:1 でマッピングする。</li>
        <li>スタック操作も WASM のスタックマシンと概念的に一致するため、ほぼそのまま変換可能。</li>
        <li>例外処理は、WASM の exception handling 拡張またはエラーコード + ブロック構造の組み合わせで表現する。</li>
        <li>pipe / filter は、WASM の <code>ref</code> 型＋ホスト関数を用いて実装されることが多い。</li>
      </ul>

      <h3>7.5 aloe2wasm の役割</h3>
      <ul>
        <li>Aloe ソース → AloeBC → AloeVM 実行 という経路とは別に、
          <ul>
            <li>Aloe ソース → 中間 IR → WASM という <strong>ネイティブ WASM ビルド</strong> 経路を用意する。</li>
          </ul>
        </li>
        <li>このとき、AloeVM 命令セットと WASM 命令セットが近いほど、コンパイラ実装が単純になる。</li>
        <li>理想的には「AloeVM 命令列をそのまま WASM にシリアライズするだけ」で動作するレベルを目指す。</li>
      </ul>
    </section>

    <!-- 8. 未決事項・TODO -->
    <section id="vm-ch8" class="chapter">
      <h2>8. 未決事項・TODO</h2>

      <h3>8.1 まだ決まっていない事項</h3>
      <ul>
        <li>pipe / filter のスレッドモデル
          <ul>
            <li>「1 フィルタ 1 スレッド」なのか、「複数フィルタをワーカースレッドプールで共有する」のか、といった実行モデル。</li>
            <li>仕様として 1 つに固定するか、完全に実装依存とするかは、現時点では未決。</li>
          </ul>
        </li>
        <li>WASM 版での pipe / filter の標準 ABI
          <ul>
            <li>ホストとのインターフェース（関数シグネチャ、メモリレイアウト、スレッド有無 等）。</li>
            <li>複数の実装間で互換性を持たせるための最低限の ABI をどの程度まで仕様として固定するかは今後決定する。</li>
          </ul>
        </li>
      </ul>

      <h3>8.2 将来の拡張候補</h3>
      <ul>
        <li>JIT コンパイル層（ホット関数のネイティブコード化）</li>
        <li>デバッガフック（ブレークポイント・ステップ実行・変数ウォッチ）</li>
        <li>プロファイラ API（実行時間・割り当てメモリの計測）</li>
        <li>分散実行（複数プロセス／ノードにまたがる pipe のサポート）</li>
      </ul>

      <div class="note">
        現在の仕様書の内容だけでも、<strong>Aloe コンパイラ / C# 実装の AloeVM / aloe2wasm のプロトタイプ</strong>は実装可能なレベルを目指している。<br />
        ただし、命令セット表やメモリ管理の細部は試行錯誤しつつブラッシュアップしていく前提。
      </div>
    </section>

    <hr />

    <!-- Appendix: 生成AI向け編集ポリシー -->
    <section id="editor-notes">
      <h2>Appendix: 生成AI 向け編集ポリシー（仕様書本文ではない）</h2>
      <p>
        この付録は、AloeVM 仕様書を生成 AI（例: ChatGPT）で編集する際のルールを示すものであり、
        仕様書本文の一部では<strong>ない</strong>。本文の技術的内容よりも優先されることはない。
      </p>
      <ul>
        <li>本文の技術内容・仕様の意味を変更しないこと。
          誤字脱字の修正や、明らかな表記ゆれの統一は許可されるが、アルゴリズムや仕様の挙動を変えてはならない。</li>
        <li>章立てや見出しの順序は、ユーザーから明示的な指示がない限り変更しないこと。</li>
        <li>既存のサンプルコードや擬似コードのロジックは保持し、見た目だけの書き換え（不要な大文字小文字変更など）は行わないこと。</li>
        <li>「別資料で管理する」と明記された内容（例: 命令セット詳細）は、この仕様書内に勝手に再展開しないこと。
          詳細が必要な場合は「AloeVM 命令セットリファレンスを参照」といった参照文の追加にとどめる。</li>
        <li>メタ情報を更新する場合、ヘッダ内の <code>edit-version</code> と <code>edit-date</code> を必ず更新すること。</li>
        <li>
          <strong>時刻の扱い:</strong>
          <ul>
            <li><code>edit-date</code> には、必ず <strong>Asia/Tokyo の現在時刻</strong> を使用すること。</li>
            <li>形式は ISO 8601（例: <code>2025-12-03T11:45:54+09:00</code>）とし、年月日・時分秒・タイムゾーンオフセットを含めること。</li>
            <li>推測や他タイムゾーンの時刻を用いてはならない。生成 AI は、ユーザーから与えられた現在時刻（または専用ツールから取得した Asia/Tokyo の現在時刻）をそのまま書き込むこと。</li>
          </ul>
        </li>
        <li>この付録自体は、必要に応じて追記・修正してよいが、その場合も本文の仕様内容には影響を与えないようにすること。</li>
      </ul>
    </section>

  </main>
</div>
</body>
</html>
